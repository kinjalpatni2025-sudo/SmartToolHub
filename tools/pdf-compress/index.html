<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Compress PDF - Smarttool Hub</title>
  <meta name="description" content="Compress PDFs client-side by rasterizing pages to JPEG and rebuilding PDFs." />
  <link rel="icon" href="https://img.icons8.com/fluency/48/toolbox.png" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css"/>
  <style>
    :root{--bg:#0b1220;--text:#eaf2ff;--card:#182335;--border:#2a3b55;--primary:#22d3ee;--muted:#9fb3c8;--radius:12px}
    body.light{--bg:#f6f8fb;--text:#0b1220;--card:#ffffff;--border:#e6eefc;--primary:#0b74ff;--muted:#556677}
    *{box-sizing:border-box;margin:0;padding:0}
    body{font-family:Inter,system-ui,Segoe UI,Roboto,Arial;background:var(--bg);color:var(--text);min-height:100vh;display:flex;flex-direction:column;transition:background .2s,color .2s}
    .container{max-width:1200px;margin:0 auto;padding:20px;width:100%}
    header{display:flex;align-items:center;justify-content:space-between;background:var(--card);padding:12px 18px;border-radius:10px;border:1px solid var(--border)}
    .brand{display:flex;gap:12px;align-items:center}
    .brand img{width:44px;height:44px;border-radius:8px}
    .brand .title{font-weight:700;color:var(--primary)}
    .upload-area{margin-top:18px;border-radius:12px;border:2px dashed var(--border);padding:30px;text-align:center;cursor:pointer}
    .upload-area.dragover{border-color:var(--primary);background:rgba(34,211,238,0.03)}
    .file-input{display:none}
    .selected-list{display:grid;grid-template-columns:repeat(auto-fit,minmax(260px,1fr));gap:12px;margin-top:16px}
    .file-card{background:var(--card);padding:12px;border-radius:10px;border:1px solid var(--border);display:flex;gap:10px;align-items:flex-start}
    .pdf-icon{width:86px;height:86px;border-radius:8px;display:flex;align-items:center;justify-content:center;background:#0f1720;border:1px solid var(--border);font-size:2rem;color:var(--primary)}
    .file-meta h5{margin:0 0 6px 0;font-size:0.95rem}
    .file-meta p{margin:0;color:var(--muted);font-size:0.88rem}
    .file-actions{display:flex;flex-direction:column;gap:8px;margin-left:auto}
    .small-btn{padding:8px 10px;border-radius:8px;border:none;cursor:pointer;font-weight:600}
    .small-btn.primary{background:var(--primary);color:#00131f}
    .small-btn.secondary{background:transparent;border:1px solid var(--border);color:var(--text)}
    .controls{display:flex;gap:12px;align-items:center;margin-top:12px;flex-wrap:wrap}
    .btn{padding:10px 16px;border-radius:10px;border:none;font-weight:700;cursor:pointer}
    .btn-primary{background:var(--primary);color:#00131f}
    .btn-secondary{background:var(--card);border:1px solid var(--border);color:var(--text)}
    .status{margin-top:12px;padding:10px;border-radius:10px;display:none}
    .status.ok{border:1px solid #10b981;color:#10b981;background:rgba(16,185,129,0.03)}
    .status.err{border:1px solid #ef4444;color:#ef4444;background:rgba(239,68,68,0.03)}
    .option { background:var(--card);border:1px solid var(--border);padding:10px;border-radius:8px;color:var(--muted) }
    footer{margin-top:auto;padding:12px 0;text-align:center;color:var(--muted)}
    @media (max-width:720px){.file-card{flex-direction:row;align-items:center}}
  </style>
</head>
<body>
  <div class="container">
    <header>
      <div class="brand">
        <img src="https://img.icons8.com/fluency/48/toolbox.png" alt="logo">
        <div>
          <div class="title">Smarttool Hub</div>
          <div style="font-size:0.85rem;color:var(--muted)">PDF Compress — Client-side</div>
        </div>
      </div>
      <div>
        <button id="themeToggle" class="btn btn-secondary" title="Toggle theme"><i class="fa-solid fa-moon"></i></button>
      </div>
    </header>

    <div class="upload-area" id="uploadArea" title="Click or drop PDF files here">
      <div style="font-size:36px;color:var(--muted)"><i class="fa-solid fa-file-pdf"></i></div>
      <div style="margin-top:8px;font-weight:700">Drop PDF files here or click to select</div>
      <div style="margin-top:6px;color:var(--muted)">Multiple files supported — pages will be rasterized to JPEG and reassembled.</div>
      <input type="file" id="fileInput" class="file-input" accept="application/pdf" multiple>
    </div>

    <div class="controls" style="margin-top:18px">
      <div class="option">
        <div style="font-weight:700;margin-bottom:6px">JPEG Quality</div>
        <input id="quality" type="range" min="20" max="95" value="75">
        <div id="qualityVal" style="text-align:center;color:var(--muted);margin-top:6px">75%</div>
      </div>

      <div class="option">
        <div style="font-weight:700;margin-bottom:6px">Render Scale</div>
        <div style="font-size:0.9rem;color:var(--muted);margin-bottom:6px">Higher = better clarity, larger output</div>
        <input id="scale" type="range" min="0.6" max="2" step="0.1" value="1">
        <div id="scaleVal" style="text-align:center;color:var(--muted);margin-top:6px">1.0×</div>
      </div>

      <div class="option" style="display:flex;flex-direction:column;gap:8px;justify-content:center">
        <label style="display:flex;gap:8px;align-items:center"><input type="checkbox" id="mergeAll" checked> Merge all into one PDF</label>
        <label style="display:flex;gap:8px;align-items:center"><input type="checkbox" id="zipPerPage"> Also create ZIP of single-page PDFs</label>
      </div>
    </div>

    <div style="display:flex;gap:12px;margin-top:14px;flex-wrap:wrap;align-items:center">
      <button id="compressBtn" class="btn btn-primary" disabled><i class="fa-solid fa-compress"></i> Compress</button>
      <button id="downloadBtn" class="btn btn-secondary" disabled><i class="fa-solid fa-download"></i> Download Result</button>
      <button id="resetBtn" class="btn btn-secondary"><i class="fa-solid fa-rotate"></i> Reset</button>
      <div id="summary" style="margin-left:auto;color:var(--muted);font-weight:600">No files selected</div>
    </div>

    <div id="status" class="status"></div>

    <div id="selectedList" class="selected-list"></div>
  </div>

  <footer>© <span id="year"></span> Smarttool Hub — All processing in your browser.</footer>

  <!-- Dependencies -->
  <script src="https://cdn.jsdelivr.net/npm/pdf-lib/dist/pdf-lib.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.6.172/pdf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

  <script>
    // UI init
    document.getElementById('year').textContent = new Date().getFullYear();
    const themeToggle = document.getElementById('themeToggle');
    if (localStorage.getItem('sth_theme') === 'light') { document.body.classList.add('light'); themeToggle.innerHTML = '<i class="fa-solid fa-sun"></i>'; }
    themeToggle.addEventListener('click', () => {
      document.body.classList.toggle('light');
      if (document.body.classList.contains('light')) { themeToggle.innerHTML = '<i class="fa-solid fa-sun"></i>'; localStorage.setItem('sth_theme','light'); }
      else { themeToggle.innerHTML = '<i class="fa-solid fa-moon"></i>'; localStorage.removeItem('sth_theme'); }
    });

    // Elements
    const uploadArea = document.getElementById('uploadArea');
    const fileInput = document.getElementById('fileInput');
    const selectedList = document.getElementById('selectedList');
    const compressBtn = document.getElementById('compressBtn');
    const downloadBtn = document.getElementById('downloadBtn');
    const resetBtn = document.getElementById('resetBtn');
    const summary = document.getElementById('summary');
    const statusEl = document.getElementById('status');

    const qualityEl = document.getElementById('quality');
    const qualityVal = document.getElementById('qualityVal');
    const scaleEl = document.getElementById('scale');
    const scaleVal = document.getElementById('scaleVal');
    const mergeAllEl = document.getElementById('mergeAll');
    const zipPerPageEl = document.getElementById('zipPerPage');

    let filesState = []; // [{id,file,arrayBuffer,pageCount,thumbnail}]
    let resultBlob = null;
    let zipBlob = null;

    function uid(){ return 'f_'+Math.random().toString(36).slice(2,9); }
    function showStatus(msg, type='ok', autoHide=true){
      statusEl.textContent = msg;
      statusEl.className = 'status ' + (type==='ok' ? 'ok' : 'err');
      statusEl.style.display = 'block';
      if (autoHide) setTimeout(()=> statusEl.style.display='none', 5000);
    }

    qualityVal.textContent = qualityEl.value + '%';
    qualityEl.addEventListener('input', ()=> qualityVal.textContent = qualityEl.value + '%');
    scaleVal.textContent = scaleEl.value + '×';
    scaleEl.addEventListener('input', ()=> scaleVal.textContent = parseFloat(scaleEl.value).toFixed(1) + '×');

    // Drag/drop handlers
    uploadArea.addEventListener('click', ()=> fileInput.click());
    uploadArea.addEventListener('dragover', e=>{ e.preventDefault(); uploadArea.classList.add('dragover'); });
    uploadArea.addEventListener('dragleave', e=>{ e.preventDefault(); uploadArea.classList.remove('dragover'); });
    uploadArea.addEventListener('drop', e=>{ e.preventDefault(); uploadArea.classList.remove('dragover'); handleFiles(Array.from(e.dataTransfer.files || [])); });
    fileInput.addEventListener('change', e=> { handleFiles(Array.from(e.target.files || [])); fileInput.value = ''; });

    function isPdf(f){ return f && (f.type === 'application/pdf' || /\.pdf$/i.test(f.name)); }

    async function handleFiles(list){
      const incoming = list.filter(isPdf);
      const rejected = list.filter(f => !isPdf(f));
      if (rejected.length) showStatus(rejected.length + ' non-PDF file(s) ignored', 'err');

      if (!incoming.length) return;
      for (const f of incoming) {
        const id = uid();
        const entry = { id, file: f, arrayBuffer: null, pageCount: 0, thumb: null };
        filesState.push(entry);
        // read arrayBuffer
        try {
          entry.arrayBuffer = await f.arrayBuffer();
          // attempt to get page count using pdf.js or pdf-lib
          try {
            const pdfDoc = await PDFLib.PDFDocument.load(entry.arrayBuffer, { ignoreEncryption: true });
            entry.pageCount = pdfDoc.getPageCount();
          } catch (err) {
            entry.pageCount = null;
          }
          // create small thumbnail of first page (best-effort) using pdf.js
          try {
            const loadingTask = window.pdfjsLib.getDocument({ data: entry.arrayBuffer });
            const pdf = await loadingTask.promise;
            const page = await pdf.getPage(1);
            const viewport = page.getViewport({ scale: 0.5 });
            const canvas = document.createElement('canvas');
            canvas.width = Math.floor(viewport.width);
            canvas.height = Math.floor(viewport.height);
            const ctx = canvas.getContext('2d');
            await page.render({ canvasContext: ctx, viewport }).promise;
            entry.thumb = canvas.toDataURL('image/png');
            page.cleanup && page.cleanup();
            pdf.cleanup && pdf.cleanup();
          } catch (err) {
            // ignore thumbnail failure
            entry.thumb = null;
          }
        } catch (err) {
          console.error('read error', err);
          showStatus('Failed to read ' + f.name, 'err');
        }
      }
      renderList();
      updateControls();
      showStatus(incoming.length + ' file(s) added', 'ok');
    }

    function renderList(){
      selectedList.innerHTML = '';
      filesState.forEach(entry => {
        const card = document.createElement('div'); card.className = 'file-card';
        const icon = document.createElement('div'); icon.className = 'pdf-icon'; icon.innerHTML = '<i class="fa-solid fa-file-pdf"></i>';
        card.appendChild(icon);

        const meta = document.createElement('div'); meta.className = 'file-meta';
        const h5 = document.createElement('h5'); h5.textContent = entry.file.name; meta.appendChild(h5);
        const p1 = document.createElement('p'); p1.textContent = `${entry.pageCount ? entry.pageCount + ' page(s)' : 'Pages: unknown'} • ${(entry.file.size/1024).toFixed(1)} KB`; meta.appendChild(p1);
        if (entry.thumb) {
          const img = document.createElement('img'); img.src = entry.thumb; img.style.maxWidth='100%'; img.style.marginTop='8px'; img.style.borderRadius='6px';
          meta.appendChild(img);
        }
        card.appendChild(meta);

        const actions = document.createElement('div'); actions.className='file-actions';
        const removeBtn = document.createElement('button'); removeBtn.className='small-btn secondary'; removeBtn.innerHTML = '<i class="fa-solid fa-trash"></i>'; removeBtn.onclick = ()=> {
          filesState = filesState.filter(f=>f.id !== entry.id); renderList(); updateControls(); showStatus('File removed','ok');
        };
        actions.appendChild(removeBtn);
        card.appendChild(actions);
        selectedList.appendChild(card);
      });
      summary.textContent = filesState.length ? `${filesState.length} file(s) selected` : 'No files selected';
    }

    function updateControls(){
      compressBtn.disabled = filesState.length === 0;
      downloadBtn.disabled = !resultBlob && !zipBlob;
    }

    // Convert dataURL to Uint8Array
    function dataURLToUint8Array(dataURL){
      const parts = dataURL.split(',');
      const bstr = atob(parts[1]);
      const n = bstr.length;
      const u8 = new Uint8Array(n);
      for (let i=0;i<n;i++) u8[i] = bstr.charCodeAt(i);
      return u8;
    }

    // Main compress flow
    compressBtn.addEventListener('click', async () => {
      if (!filesState.length) return;
      resultBlob = null; zipBlob = null;
      downloadBtn.disabled = true;
      showStatus('Compressing — this may take a while depending on PDF size...', 'ok', false);

      try {
        const mergedDoc = await PDFLib.PDFDocument.create();
        const perPageFiles = []; // for zip if needed: {filename, bytes}

        for (let fi=0; fi<filesState.length; fi++) {
          const entry = filesState[fi];
          // load pdf via pdf.js to render pages
          const loadingTask = window.pdfjsLib.getDocument({ data: entry.arrayBuffer });
          const pdf = await loadingTask.promise;
          const pageCount = pdf.numPages || entry.pageCount || 0;

          for (let p = 1; p <= pageCount; p++) {
            // render page to canvas
            const page = await pdf.getPage(p);
            const scale = parseFloat(scaleEl.value) || 1.0;
            const viewport = page.getViewport({ scale });
            const canvas = document.createElement('canvas');
            canvas.width = Math.floor(viewport.width);
            canvas.height = Math.floor(viewport.height);
            const ctx = canvas.getContext('2d');
            // white background
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(0,0,canvas.width,canvas.height);
            await page.render({ canvasContext: ctx, viewport }).promise;

            // get JPEG dataURL at quality
            const q = Math.max(0.2, Math.min(0.95, Number(qualityEl.value)/100));
            const dataUrl = canvas.toDataURL('image/jpeg', q);

            // convert to bytes and embed into pdf-lib
            const imgBytes = dataURLToUint8Array(dataUrl);
            const embedded = await mergedDoc.embedJpg(imgBytes);
            // compute page size in pts (pdf-lib uses points). convert px -> pts (assuming 96dpi): px * 0.75
            const widthPts = Math.round(canvas.width * 0.75);
            const heightPts = Math.round(canvas.height * 0.75);
            const pageNew = mergedDoc.addPage([widthPts, heightPts]);
            pageNew.drawImage(embedded, { x: 0, y: 0, width: widthPts, height: heightPts });

            // also optionally store single-page PDF bytes for zip
            if (zipPerPageEl.checked) {
              const single = await PDFLib.PDFDocument.create();
              const emb = await single.embedJpg(imgBytes);
              const pg = single.addPage([widthPts, heightPts]);
              pg.drawImage(emb, { x:0, y:0, width: widthPts, height: heightPts });
              const singleBytes = await single.save();
              perPageFiles.push({ filename: `${entry.file.name.replace(/\.pdf$/i,'')}_page-${p}.pdf`, bytes: singleBytes });
            }

            // cleanup
            page.cleanup && page.cleanup();
          }
          pdf.cleanup && pdf.cleanup();
        }

        // finalize merged PDF or per-file PDFs
        if (mergeAllEl.checked) {
          const mergedBytes = await mergedDoc.save();
          resultBlob = new Blob([mergedBytes], { type: 'application/pdf' });
          showStatus('Compression finished — merged PDF ready', 'ok');
        } else {
          // If not merging, produce separate PDFs per original file (we created mergedDoc with all pages - so instead we will produce per-file documents)
          // Simpler approach: recreate per-file PDFs by re-processing files individually (to avoid complex splitting of mergedDoc)
          // We'll create perFile results:
          const perFileBlobs = [];
          for (let fi=0; fi<filesState.length; fi++) {
            const entry = filesState[fi];
            // Load pdf and process to single file doc similar to above but per file
            const loadingTask = window.pdfjsLib.getDocument({ data: entry.arrayBuffer });
            const pdf = await loadingTask.promise;
            const pageCount = pdf.numPages || entry.pageCount || 0;
            const singleDoc = await PDFLib.PDFDocument.create();
            for (let p=1;p<=pageCount;p++) {
              const page = await pdf.getPage(p);
              const scale = parseFloat(scaleEl.value) || 1.0;
              const viewport = page.getViewport({ scale });
              const canvas = document.createElement('canvas');
              canvas.width = Math.floor(viewport.width);
              canvas.height = Math.floor(viewport.height);
              const ctx = canvas.getContext('2d');
              ctx.fillStyle = '#FFFFFF';
              ctx.fillRect(0,0,canvas.width,canvas.height);
              await page.render({ canvasContext: ctx, viewport }).promise;
              const q = Math.max(0.2, Math.min(0.95, Number(qualityEl.value)/100));
              const dataUrl = canvas.toDataURL('image/jpeg', q);
              const imgBytes = dataURLToUint8Array(dataUrl);
              const emb = await singleDoc.embedJpg(imgBytes);
              const widthPts = Math.round(canvas.width * 0.75);
              const heightPts = Math.round(canvas.height * 0.75);
              const pg = singleDoc.addPage([widthPts, heightPts]);
              pg.drawImage(emb, { x:0, y:0, width: widthPts, height: heightPts });
              page.cleanup && page.cleanup();
            }
            pdf.cleanup && pdf.cleanup();
            const bytes = await singleDoc.save();
            perFileBlobs.push({ name: `${entry.file.name.replace(/\.pdf$/i,'')}_compressed.pdf`, bytes });
          }
          // if only per-file outputs, create a zip of them
          const zip = new JSZip();
          perFileBlobs.forEach(p => zip.file(p.name, p.bytes));
          const blobZip = await zip.generateAsync({ type: 'blob', compression: 'DEFLATE', compressionOptions: { level: 6 }});
          zipBlob = blobZip;
          showStatus('Compression finished — ZIP of compressed PDFs ready', 'ok');
        }

        // if zip of single pages requested and mergeAll also true we also prepare zip
        if (zipPerPageEl.checked && perPageFiles.length) {
          const zip = new JSZip();
          perPageFiles.forEach(p => zip.file(p.filename, p.bytes || p.bytes)); // bytes already Uint8Array
          // if perPageFiles.bytes are Uint8Array, zip accepts it
          const blobZ = await zip.generateAsync({ type: 'blob', compression: 'DEFLATE', compressionOptions: { level: 6 }});
          zipBlob = blobZ;
        }

        updateControls();
      } catch (err) {
        console.error('Compression failed', err);
        showStatus('Compression failed: ' + (err && err.message ? err.message : ''), 'err');
      }
    });

    // Download handler: prefer merged PDF if available, else zip
    downloadBtn.addEventListener('click', () => {
      if (resultBlob) {
        const url = URL.createObjectURL(resultBlob);
        const a = document.createElement('a'); a.href = url;
        const ts = new Date().toISOString().slice(0,19).replace(/[:T]/g,'-');
        a.download = `compressed_${ts}.pdf`; document.body.appendChild(a); a.click();
        setTimeout(()=>{ URL.revokeObjectURL(url); try{document.body.removeChild(a);}catch(e){} },400);
      } else if (zipBlob) {
        const url = URL.createObjectURL(zipBlob);
        const a = document.createElement('a'); a.href = url;
        const ts = new Date().toISOString().slice(0,19).replace(/[:T]/g,'-');
        a.download = `compressed_${ts}.zip`; document.body.appendChild(a); a.click();
        setTimeout(()=>{ URL.revokeObjectURL(url); try{document.body.removeChild(a);}catch(e){} },400);
      } else {
        showStatus('Nothing to download', 'err');
      }
    });

    resetBtn.addEventListener('click', ()=> {
      filesState = []; resultBlob = null; zipBlob = null; selectedList.innerHTML=''; updateControls(); showStatus('Reset complete', 'ok');
    });

    function updateControls(){
      compressBtn.disabled = filesState.length === 0;
      downloadBtn.disabled = !(resultBlob || zipBlob);
      summary.textContent = filesState.length ? `${filesState.length} file(s) ready` : 'No files selected';
    }

    // keyboard accessibility
    uploadArea.addEventListener('keydown', (e)=> { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); fileInput.click(); } });

    // init
    updateControls();

    // Expose debug helper
    window._compress_state = () => ({ files: filesState.length, ready: !!(resultBlob||zipBlob) });
  </script>
</body>
</html>
