<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>PDF Editor - Smarttool Hub</title>
  <meta name="description" content="Client-side PDF editor (add text, images, watermark) — works in-browser."/>
  <link rel="icon" href="https://img.icons8.com/fluency/48/toolbox.png"/>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css"/>
  <style>
    :root{
      --bg:#0b1220;--text:#eaf2ff;--card:#182335;--border:#2a3b55;
      --primary:#22d3ee;--muted:#9fb3c8;--radius:12px;
    }
    body.light{
      --bg:#f6f8fb;--text:#0b1220;--card:#ffffff;--border:#e6eefc;
      --primary:#0b74ff;--muted:#556677;
    }
    *{box-sizing:border-box;margin:0;padding:0}
    body{font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,Arial;background:var(--bg);color:var(--text);min-height:100vh;display:flex;flex-direction:column}
    .container{max-width:1200px;margin:0 auto;padding:20px;width:100%}
    header{display:flex;align-items:center;justify-content:space-between;gap:12px;background:var(--card);border-bottom:1px solid var(--border);padding:14px 20px;}
    .brand{display:flex;gap:12px;align-items:center}
    .brand img{width:46px;height:46px;border-radius:10px}
    .brand .title{font-size:1.25rem;font-weight:700;color:var(--primary)}
    .header-actions{display:flex;gap:10px;align-items:center}
    .btn-header{border:1px solid var(--border);background:transparent;padding:8px 12px;border-radius:8px;color:var(--text);cursor:pointer;display:flex;align-items:center;gap:6px;text-decoration:none;font-weight:600}
    .tool-content{background:var(--card);border-radius:var(--radius);border:1px solid var(--border);padding:18px;margin-top:20px;display:flex;gap:18px}
    .left-panel{width:320px}
    .right-panel{flex:1;min-height:60vh;overflow:auto;padding:8px;border-radius:10px;background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent)}
    .tool-title{font-size:1.5rem;margin-bottom:6px;color:var(--primary)}
    .tool-description{color:var(--muted);margin-bottom:14px}
    .upload-area{border:2px dashed var(--border);border-radius:var(--radius);padding:20px;text-align:center;cursor:pointer;background:transparent}
    .upload-area:hover{border-color:var(--primary)}
    .actions{display:flex;flex-direction:column;gap:8px;margin-top:12px}
    .btn{padding:10px 12px;border-radius:10px;border:none;font-weight:600;cursor:pointer;display:flex;align-items:center;gap:8px}
    .btn-primary{background:var(--primary);color:#00131f}
    .btn-ghost{background:transparent;border:1px solid var(--border);color:var(--text)}
    .small{padding:8px 10px;font-size:0.95rem}
    .pdf-canvas-wrap{display:flex;flex-direction:column;gap:24px;align-items:center;padding:12px}
    .page-wrapper{position:relative;background:#0f1724;padding:8px;border-radius:8px}
    .page-canvas{display:block;border-radius:3px;box-shadow:0 6px 20px rgba(0,0,0,0.5)}
    .overlay{position:absolute;left:8px;top:8px;right:8px;bottom:8px;pointer-events:auto}
    /* annotation elements */
    .ann {position:absolute;cursor:move;user-select:none;touch-action:none}
    .ann .content{display:inline-block;padding:6px 8px;border-radius:6px;background:rgba(255,255,255,0.9);color:#000}
    .ann .resizer{position:absolute;width:10px;height:10px;background:var(--primary);right:-5px;bottom:-5px;border-radius:2px;cursor:nwse-resize}
    /* watermark preview */
    .watermark-preview{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);font-size:40px;opacity:0.06;color:var(--text);pointer-events:none;display:none}
    .status{margin-top:12px;color:var(--muted);font-size:0.9rem}
    footer{margin-top:auto;padding:14px 20px;background:var(--card);border-top:1px solid var(--border);display:flex;justify-content:space-between;align-items:center}
    .controls-group{background:var(--bg);border:1px solid var(--border);padding:12px;border-radius:10px}
    input[type="file"]{display:none}
    label.file-btn{display:inline-flex;align-items:center;gap:8px;padding:8px 10px;border-radius:8px;border:1px dashed var(--border);cursor:pointer}
    @media (max-width:920px){.tool-content{flex-direction:column}.left-panel{width:100%}.right-panel{width:100%}}
  </style>
</head>
<body>
<header class="container">
  <div class="brand">
    <img src="https://img.icons8.com/fluency/48/toolbox.png" alt="logo">
    <div>
      <div class="title">Smarttool Hub</div>
      <div style="color:var(--muted);font-size:0.9rem">PDF Editor — client-side</div>
    </div>
  </div>
  <div class="header-actions">
    <a class="btn-header" href="#"><i class="fa-solid fa-house"></i> Home</a>
  </div>
</header>

<main class="container">
  <div class="tool-content">
    <!-- left controls -->
    <div class="left-panel">
      <div class="tool-title">PDF Editor</div>
      <div class="tool-description">Open a PDF, add text/images/watermark, then export a new PDF. Files stay in your browser.</div>

      <div class="controls-group">
        <div style="margin-bottom:10px;font-weight:600;color:var(--muted)">Open / Save</div>
        <label class="file-btn" id="openLabel"><i class="fa-solid fa-file-import"></i> Open PDF
          <input type="file" id="openFile" accept=".pdf">
        </label>
        <div style="display:flex;gap:8px;margin-top:10px">
          <button class="btn btn-primary small" id="savePdfBtn"><i class="fa-solid fa-download"></i> Save PDF</button>
          <button class="btn btn-ghost small" id="exportImageBtn"><i class="fa-solid fa-image"></i> Export Page Image</button>
        </div>
        <div class="status" id="openStatus">No document loaded</div>
      </div>

      <div class="controls-group" style="margin-top:12px">
        <div style="font-weight:600;color:var(--muted);margin-bottom:8px">Annotation Tools</div>
        <div style="display:flex;gap:8px;flex-wrap:wrap">
          <button class="btn small btn-ghost" id="addTextBtn"><i class="fa-solid fa-font"></i> Add Text</button>
          <button class="btn small btn-ghost" id="addImageBtn"><i class="fa-solid fa-image"></i> Add Image</button>
          <label class="file-btn" id="imgInputLabel"><i class="fa-solid fa-upload"></i> Image
            <input type="file" id="imgInput" accept="image/*">
          </label>
        </div>

        <div style="margin-top:12px">
          <label style="display:block;margin-bottom:6px;color:var(--muted)">Font size</label>
          <input id="fontSize" type="number" value="20" min="8" style="width:100%;padding:8px;border-radius:8px;background:var(--bg);border:1px solid var(--border);color:var(--text)">
        </div>

        <div style="margin-top:10px">
          <label style="display:block;margin-bottom:6px;color:var(--muted)">Text color</label>
          <input id="fontColor" type="color" value="#000000" style="width:100%;padding:6px;border-radius:8px;border:1px solid var(--border);background:#fff">
        </div>
      </div>

      <div class="controls-group" style="margin-top:12px">
        <div style="font-weight:600;color:var(--muted);margin-bottom:8px">Watermark</div>
        <input id="wmText" placeholder="Watermark text" style="width:100%;padding:8px;border-radius:8px;background:var(--bg);border:1px solid var(--border);color:var(--text)">
        <div style="display:flex;gap:8px;margin-top:8px">
          <input id="wmOpacity" type="range" min="0" max="100" value="8" style="flex:1">
          <span id="wmVal" style="width:34px;text-align:center;color:var(--muted)"></span>
        </div>
        <div style="display:flex;gap:8px;margin-top:8px">
          <button class="btn small btn-ghost" id="applyWmBtn"><i class="fa-solid fa-water"></i> Apply</button>
          <button class="btn small btn-ghost" id="clearWmBtn"><i class="fa-solid fa-trash-alt"></i> Clear</button>
        </div>
      </div>

      <div class="controls-group" style="margin-top:12px">
        <div style="font-weight:600;color:var(--muted);margin-bottom:8px">Page Controls</div>
        <div style="display:flex;gap:8px">
          <label class="file-btn" id="addPageBtn"><i class="fa-solid fa-plus"></i> Add Blank</label>
          <button class="btn small btn-ghost" id="removePageBtn"><i class="fa-solid fa-trash"></i> Remove Page</button>
        </div>
        <div style="margin-top:8px;color:var(--muted);font-size:0.9rem">Select a page by clicking its canvas</div>
      </div>

    </div>

    <!-- right area: pages -->
    <div class="right-panel" id="rightPanel">
      <div id="pdfCanvasWrap" class="pdf-canvas-wrap">
        <!-- pages will be appended here -->
        <div style="color:var(--muted);text-align:center">No document open — upload a PDF to begin editing.</div>
      </div>
    </div>
  </div>
</main>

<div class="watermark-preview" id="wmPreview"></div>

<footer>
  <div style="color:var(--muted)">© <span id="year"></span> Smarttool Hub</div>
  <div style="color:var(--muted)">Client-side — No uploads</div>
</footer>

<!-- Libraries -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

<script>
  // --- Setup & globals ---
  document.getElementById('year').textContent = new Date().getFullYear();
  const pdfjsLib = window.pdfjsLib || window['pdfjs-dist/build/pdf'];
  if (!pdfjsLib) { alert('PDF.js failed to load'); throw new Error('pdfjsLib not found'); }
  pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';

  const openFile = document.getElementById('openFile');
  const pdfCanvasWrap = document.getElementById('pdfCanvasWrap');
  const openStatus = document.getElementById('openStatus');
  const savePdfBtn = document.getElementById('savePdfBtn');
  const exportImageBtn = document.getElementById('exportImageBtn');
  const addTextBtn = document.getElementById('addTextBtn');
  const imgInput = document.getElementById('imgInput');
  const imgInputLabel = document.getElementById('imgInputLabel');
  const addImageBtn = document.getElementById('addImageBtn');
  const fontSizeInput = document.getElementById('fontSize');
  const fontColorInput = document.getElementById('fontColor');
  const wmText = document.getElementById('wmText');
  const wmOpacity = document.getElementById('wmOpacity');
  const wmVal = document.getElementById('wmVal');
  const applyWmBtn = document.getElementById('applyWmBtn');
  const clearWmBtn = document.getElementById('clearWmBtn');
  const wmPreview = document.getElementById('wmPreview');
  const addPageBtn = document.getElementById('addPageBtn');
  const removePageBtn = document.getElementById('removePageBtn');

  let pdfDoc = null;
  let currentFileName = 'document.pdf';
  let pages = []; // {pageNum, canvas, viewport, overlay}
  let selectedPageIndex = null;
  let annotationId = 0;

  // small helper for pointer drag + resize
  function makeDraggable(el) {
    el.style.touchAction = 'none';
    let dragging = false, startX=0, startY=0, origX=0, origY=0;
    el.addEventListener('pointerdown', (e)=>{
      if (e.target.classList.contains('resizer')) return; // resize handled separately
      dragging = true; el.setPointerCapture(e.pointerId);
      startX = e.clientX; startY = e.clientY;
      const rect = el.getBoundingClientRect();
      origX = rect.left; origY = rect.top;
    });
    window.addEventListener('pointermove', (e)=>{
      if (!dragging) return;
      const dx = e.clientX - startX, dy = e.clientY - startY;
      const parentRect = el.parentElement.getBoundingClientRect();
      // compute new pos relative to parent
      const left = (origX + dx) - parentRect.left;
      const top = (origY + dy) - parentRect.top;
      el.style.left = Math.max(0, left) + 'px';
      el.style.top = Math.max(0, top) + 'px';
    });
    window.addEventListener('pointerup', (e)=>{
      dragging = false;
    });

    // resizer
    const resizer = el.querySelector('.resizer');
    if (resizer) {
      let resizing=false, sx=0, sy=0, ow=0, oh=0;
      resizer.addEventListener('pointerdown', (e)=>{
        resizing=true; resizer.setPointerCapture(e.pointerId);
        sx = e.clientX; sy = e.clientY;
        ow = el.offsetWidth; oh = el.offsetHeight;
        e.stopPropagation();
      });
      window.addEventListener('pointermove', (e)=>{
        if (!resizing) return;
        const dx = e.clientX - sx, dy = e.clientY - sy;
        el.style.width = Math.max(30, ow + dx) + 'px';
        el.style.height = Math.max(20, oh + dy) + 'px';
      });
      window.addEventListener('pointerup', ()=>{resizing=false});
    }
  }

  // create a new annotation element (text or image)
  function createAnnotation(type, options = {}) {
    if (selectedPageIndex === null) {
      alert('Select a page canvas first by clicking it.');
      return;
    }
    const page = pages[selectedPageIndex];
    const overlay = page.overlay;

    const ann = document.createElement('div');
    ann.className = 'ann';
    ann.dataset.type = type;
    ann.dataset.id = ++annotationId;
    ann.style.left = (options.left ?? 20) + 'px';
    ann.style.top = (options.top ?? 20) + 'px';
    ann.style.width = (options.width ?? 140) + 'px';
    ann.style.height = (options.height ?? 40) + 'px';
    ann.style.zIndex = 1000 + annotationId;

    const content = document.createElement('div');
    content.className = 'content';
    content.style.fontSize = (options.fontSize ?? fontSizeInput.value) + 'px';
    content.style.color = options.color ?? fontColorInput.value;
    content.contentEditable = type === 'text' ? 'true' : 'false';
    content.style.wordBreak = 'break-word';
    content.style.minHeight = '20px';
    content.innerText = options.text ?? (type === 'text' ? 'Double-click to edit' : '');

    ann.appendChild(content);

    if (type === 'image') {
      content.contentEditable = 'false';
      content.style.background = 'transparent';
      content.style.padding = '0';
      const img = document.createElement('img');
      img.src = options.src;
      img.style.maxWidth = '100%';
      img.style.maxHeight = '100%';
      img.style.display = 'block';
      content.innerHTML = '';
      content.appendChild(img);
      // adjust size to image natural size if provided
      if (options.naturalWidth) {
        ann.style.width = Math.min(options.naturalWidth, page.canvas.width * 0.8) + 'px';
        ann.style.height = (ann.style.width.replace('px','') * (options.naturalHeight/options.naturalWidth)) + 'px';
      }
    }

    // add resizer handle
    const resizer = document.createElement('div');
    resizer.className = 'resizer';
    ann.appendChild(resizer);

    // attach to overlay and enable drag/resize
    overlay.appendChild(ann);
    makeDraggable(ann);

    // double click to edit text focus
    if (type === 'text') {
      content.addEventListener('dblclick', ()=> { content.focus(); });
    }

    // select page when clicking annotation
    ann.addEventListener('pointerdown', ()=> {
      highlightPage(selectedPageIndex);
    });

    return ann;
  }

  // ---- Render PDF pages ----
  async function loadPdfFromFile(file) {
    if (!file) return;
    currentFileName = file.name || 'document.pdf';
    const ab = await file.arrayBuffer();
    const loadingTask = pdfjsLib.getDocument({ data: ab });
    pdfDoc = await loadingTask.promise;
    renderAllPages();
    openStatus.textContent = `Loaded: ${currentFileName} — ${pdfDoc.numPages} page(s)`;
  }

  async function renderAllPages() {
    pdfCanvasWrap.innerHTML = '';
    pages = [];
    selectedPageIndex = null;
    for (let p = 1; p <= pdfDoc.numPages; p++) {
      const page = await pdfDoc.getPage(p);
      const viewport = page.getViewport({ scale: 1.5 }); // decent resolution
      const canvas = document.createElement('canvas');
      canvas.className = 'page-canvas';
      canvas.width = Math.floor(viewport.width);
      canvas.height = Math.floor(viewport.height);
      canvas.style.width = canvas.width + 'px';
      canvas.style.height = canvas.height + 'px';

      const pageWrapper = document.createElement('div');
      pageWrapper.className = 'page-wrapper';
      pageWrapper.style.display = 'inline-block';
      pageWrapper.style.maxWidth = '100%';

      const overlay = document.createElement('div');
      overlay.className = 'overlay';
      overlay.style.width = canvas.style.width;
      overlay.style.height = canvas.style.height;
      // set relative size container so overlay absolute coords match
      overlay.style.pointerEvents = 'auto';

      // draw PDF page into canvas
      const ctx = canvas.getContext('2d');
      await page.render({ canvasContext: ctx, viewport }).promise;

      // clicking canvas selects page
      canvas.addEventListener('click', ()=>{
        selectedPageIndex = pages.findIndex(item => item.canvas === canvas);
        highlightPage(selectedPageIndex);
      });

      pageWrapper.appendChild(canvas);
      pageWrapper.appendChild(overlay);
      pdfCanvasWrap.appendChild(pageWrapper);

      pages.push({ pageNum: p, canvas, viewport, overlay, wrapper: pageWrapper });
    }
    // by default select first page if exists
    if (pages.length) {
      selectedPageIndex = 0;
      highlightPage(0);
    }
  }

  function highlightPage(index) {
    pages.forEach((p, i) => {
      p.wrapper.style.boxShadow = i === index ? '0 10px 30px rgba(34,211,238,0.12)' : 'none';
      p.wrapper.style.border = i === index ? '1px solid rgba(34,211,238,0.15)' : 'none';
    });
  }

  // --- Save (compose) PDF using jsPDF by drawing page canvas and overlay annotations ---
  async function saveEditedPdf() {
    if (!pdfDoc && pages.length===0) { alert('No document to save'); return; }
    const { jsPDF } = window.jspdf;
    const doc = new jsPDF({ unit: 'pt' }); // points will match canvas px approximations
    for (let i = 0; i < pages.length; i++) {
      const p = pages[i];
      // create an offscreen canvas to composite base page + annotations
      const w = p.canvas.width, h = p.canvas.height;
      const off = document.createElement('canvas');
      off.width = w; off.height = h;
      const ctx = off.getContext('2d');

      // draw the rendered PDF page
      ctx.drawImage(p.canvas, 0, 0);

      // draw annotations from overlay children
      const anns = Array.from(p.overlay.children);
      for (const ann of anns) {
        const rect = ann.getBoundingClientRect();
        const parentRect = p.overlay.getBoundingClientRect();
        const left = (rect.left - parentRect.left) * (w / parentRect.width);
        const top = (rect.top - parentRect.top) * (h / parentRect.height);
        const aw = rect.width * (w / parentRect.width);
        const ah = rect.height * (h / parentRect.height);

        if (ann.dataset.type === 'text') {
          // draw text box
          const contentEl = ann.querySelector('.content');
          // use computed styles for font size/color
          const style = window.getComputedStyle(contentEl);
          const fontSize = parseFloat(style.fontSize) * (w / parentRect.width);
          ctx.font = `${fontSize}px sans-serif`;
          ctx.fillStyle = style.color || '#000';
          // simple wrapping:
          const txt = contentEl.innerText || '';
          const lines = wrapText(ctx, txt, aw - 8);
          ctx.textBaseline = 'top';
          const padding = 4;
          ctx.fillStyle = '#ffffffcc';
          ctx.fillRect(left, top, aw, ah);
          ctx.fillStyle = style.color || '#000';
          lines.forEach((line, idx) => {
            ctx.fillText(line, left + padding, top + padding + idx * (fontSize * 1.15));
          });
        } else if (ann.dataset.type === 'image') {
          const imgEl = ann.querySelector('img');
          // draw the image element onto the offscreen canvas
          // ensure image is loaded
          await ensureImageLoaded(imgEl);
          ctx.drawImage(imgEl, left, top, aw, ah);
        }
      }

      // watermark: if global watermark text exists and preview visible, draw center watermark
      if (wmText.value.trim()) {
        ctx.save();
        ctx.globalAlpha = parseInt(wmOpacity.value,10)/100;
        ctx.fillStyle = '#000';
        ctx.font = `${Math.floor(w/10)}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.translate(w/2,h/2);
        ctx.rotate(-Math.PI/6);
        ctx.fillText(wmText.value, 0, 0);
        ctx.restore();
      }

      // convert offscreen canvas to data URL and add to PDF
      const dataUrl = off.toDataURL('image/png');
      const imgProps = doc.getImageProperties(dataUrl);
      const pdfWidth = doc.internal.pageSize.getWidth();
      const pdfHeight = (imgProps.height * pdfWidth) / imgProps.width;
      if (i > 0) doc.addPage();
      doc.addImage(dataUrl, 'PNG', 0, 0, pdfWidth, pdfHeight);
    }
    doc.save(currentFileName.replace(/\.pdf$/i,'') + '_edited.pdf');
  }

  // helper: wrap text for canvas
  function wrapText(ctx, text, maxWidth) {
    const words = text.split(/\s+/);
    const lines = [];
    let cur = '';
    for (let w of words) {
      const test = cur ? cur + ' ' + w : w;
      const m = ctx.measureText(test).width;
      if (m > maxWidth && cur) { lines.push(cur); cur = w; } else { cur = test; }
    }
    if (cur) lines.push(cur);
    return lines;
  }

  function ensureImageLoaded(img) {
    return new Promise((res)=> {
      if (!img.complete) img.onload = ()=>res();
      else res();
    });
  }

  // --- Export current selected page as PNG ---
  function exportCurrentPageAsImage() {
    if (selectedPageIndex === null) { alert('Select a page first'); return; }
    const p = pages[selectedPageIndex];
    const off = document.createElement('canvas');
    off.width = p.canvas.width; off.height = p.canvas.height;
    const ctx = off.getContext('2d');
    ctx.drawImage(p.canvas, 0, 0);
    // draw overlay (annotations) onto off canvas similarly to save
    const anns = Array.from(p.overlay.children);
    const parentRect = p.overlay.getBoundingClientRect();
    anns.forEach(ann=>{
      const rect = ann.getBoundingClientRect();
      const left = (rect.left - parentRect.left) * (off.width / parentRect.width);
      const top = (rect.top - parentRect.top) * (off.height / parentRect.height);
      const aw = rect.width * (off.width / parentRect.width);
      const ah = rect.height * (off.height / parentRect.height);
      if (ann.dataset.type === 'text') {
        const contentEl = ann.querySelector('.content');
        const style = window.getComputedStyle(contentEl);
        const fontSize = parseFloat(style.fontSize) * (off.width / parentRect.width);
        ctx.font = `${fontSize}px sans-serif`;
        ctx.fillStyle = '#ffffffcc';
        ctx.fillRect(left, top, aw, ah);
        ctx.fillStyle = style.color || '#000';
        const lines = wrapText(ctx, contentEl.innerText || '', aw - 8);
        lines.forEach((line, idx)=>ctx.fillText(line, left+4, top+4 + idx * (fontSize * 1.15)));
      } else if (ann.dataset.type === 'image') {
        const imgEl = ann.querySelector('img');
        ctx.drawImage(imgEl, left, top, aw, ah);
      }
    });
    off.toBlob((blob)=>{
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = (currentFileName.replace(/\.pdf$/i,'')||'page') + '_page.png';
      document.body.appendChild(a); a.click(); a.remove();
      URL.revokeObjectURL(url);
    }, 'image/png');
  }

  // --- Add page / Remove page (blank) ---
  function addBlankPage() {
    // create a blank canvas size similar to first page or default
    let baseW = 612, baseH = 792; // default letter pt approximations
    if (pages.length) {
      baseW = pages[0].canvas.width;
      baseH = pages[0].canvas.height;
    }
    const canvas = document.createElement('canvas');
    canvas.className = 'page-canvas';
    canvas.width = baseW; canvas.height = baseH;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#ffffff'; ctx.fillRect(0,0,canvas.width,canvas.height);

    const pageWrapper = document.createElement('div');
    pageWrapper.className = 'page-wrapper';

    const overlay = document.createElement('div');
    overlay.className = 'overlay';
    overlay.style.width = canvas.style.width;
    overlay.style.height = canvas.style.height;

    canvas.addEventListener('click', ()=>{
      selectedPageIndex = pages.findIndex(item => item.canvas === canvas);
      highlightPage(selectedPageIndex);
    });

    pageWrapper.appendChild(canvas); pageWrapper.appendChild(overlay);
    pdfCanvasWrap.appendChild(pageWrapper);
    pages.push({ pageNum: pages.length+1, canvas, viewport: { width: canvas.width, height: canvas.height, scale:1 }, overlay, wrapper: pageWrapper });
    selectedPageIndex = pages.length-1;
    highlightPage(selectedPageIndex);
  }

  function removeCurrentPage() {
    if (selectedPageIndex === null) return alert('Select a page to remove');
    const p = pages[selectedPageIndex];
    p.wrapper.remove();
    pages.splice(selectedPageIndex,1);
    // renumber
    pages.forEach((pg, idx)=>pg.pageNum = idx+1);
    selectedPageIndex = pages.length ? Math.max(0, selectedPageIndex-1) : null;
    if (selectedPageIndex !== null) highlightPage(selectedPageIndex);
  }

  // ---- Event wiring ----
  openFile.addEventListener('change', (e)=> loadPdfFromFile(e.target.files[0]));
  savePdfBtn.addEventListener('click', saveEditedPdf);
  exportImageBtn.addEventListener('click', exportCurrentPageAsImage);
  addTextBtn.addEventListener('click', ()=> createAnnotation('text'));
  imgInput.addEventListener('change', async (e)=>{
    const f = e.target.files[0]; if (!f) return;
    const url = URL.createObjectURL(f);
    const img = new Image();
    img.src = url;
    img.onload = ()=> {
      createAnnotation('image', { src: url, naturalWidth: img.naturalWidth, naturalHeight: img.naturalHeight });
      URL.revokeObjectURL(url);
    };
  });
  addImageBtn.addEventListener('click', ()=> imgInput.click());

  // watermark controls
  wmVal.textContent = wmOpacity.value;
  wmOpacity.addEventListener('input', ()=> wmVal.textContent = wmOpacity.value);
  applyWmBtn.addEventListener('click', ()=> {
    const txt = wmText.value.trim();
    if (!txt) return alert('Enter watermark text');
    wmPreview.style.display = 'block';
    wmPreview.style.opacity = (wmOpacity.value/100);
    wmPreview.innerText = txt;
    // small transform to mimic rotated watermark
    wmPreview.style.transform = 'translate(-50%,-50%) rotate(-12deg) scale(1.0)';
  });
  clearWmBtn.addEventListener('click', ()=> { wmPreview.style.display = 'none'; wmText.value = ''; });

  // add/remove page
  addPageBtn.addEventListener('click', addBlankPage);
  removePageBtn.addEventListener('click', removeCurrentPage);

  // small helper: clicking outside annotation deselects
  document.addEventListener('click', (e)=>{
    // nothing for now
  });

  // utility: simple load sample for quick testing (optional)
  // You can remove or comment the following block in production
  // fetch a small sample PDF from a public URL — commented out.
  /*
  (async function sampleLoad(){
    const resp = await fetch('https://cors-anywhere.herokuapp.com/https://arxiv.org/pdf/quant-ph/0410100.pdf');
    const buf = await resp.arrayBuffer();
    const file = new File([buf],"sample.pdf",{type:"application/pdf"});
    await loadPdfFromFile(file);
  })();
  */

  // helper for debugging: log pages
  console.log('PDF Editor ready');
</script>
</body>
</html>
