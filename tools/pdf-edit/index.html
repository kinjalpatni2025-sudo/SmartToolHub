<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Edit PDF Online — Add Text, Shapes & Highlights — Smarttool Hub</title>
<meta name="description" content="Edit PDF online: add text, shapes, highlights and save back to PDF. 100% client-side. Vector annotations preserved using pdf-lib." />
<meta name="keywords" content="edit pdf online, pdf editor, add text to pdf, highlight pdf, annotate pdf, pdf shapes client-side" />
<link rel="icon" href="https://img.icons8.com/fluency/48/edit-file.png" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" />
<style>
:root{--bg:#0b1220;--text:#eaf2ff;--card:#182335;--border:#2a3b55;--primary:#22d3ee;--muted:#9fb3c8}
body.light{--bg:#f6f8fb;--text:#0b1220;--card:#fff;--border:#e6eefc;--primary:#0b74ff;--muted:#556677}
*{box-sizing:border-box}
body{margin:0;font-family:Inter,system-ui,Arial;background:var(--bg);color:var(--text);transition:.18s}
.container{max-width:1200px;margin:0 auto;padding:18px}
header{display:flex;justify-content:space-between;align-items:center;background:var(--card);padding:12px;border-bottom:1px solid var(--border)}
.brand a{display:flex;gap:12px;align-items:center;text-decoration:none;color:inherit}
.brand img{width:46px;height:46px;border-radius:8px}
.title{font-weight:700;color:var(--primary)}
.tag{font-size:.85rem;color:var(--muted)}
.header-actions{display:flex;gap:8px;align-items:center}
.btn-header{border:1px solid var(--border);background:transparent;padding:8px 12px;border-radius:8px;color:var(--text);cursor:pointer;display:flex;gap:8px;align-items:center;text-decoration:none;font-weight:600}

main{padding:18px 0}
.uploader{min-height:90px;border-radius:12px;border:2px dashed var(--border);display:flex;flex-direction:column;align-items:center;justify-content:center;padding:18px;background:var(--card);cursor:pointer}
.uploader:hover{border-color:var(--primary)}
input[type=file]{display:none}

/* editor layout */
.editor-wrap{display:flex;gap:14px;align-items:flex-start;margin-top:14px}
.left-panel{width:260px;background:var(--card);border-radius:10px;padding:12px;border:1px solid var(--border)}
.toolbar{display:flex;flex-direction:column;gap:10px}
.tool-btn{display:flex;align-items:center;gap:8px;padding:10px;border-radius:8px;border:1px solid var(--border);background:transparent;cursor:pointer;color:var(--text)}
.tool-btn.active{background:var(--primary);color:#00131f;border-color:transparent}
.small{font-size:.9rem;padding:8px;border-radius:8px;border:1px solid var(--border);background:transparent;color:var(--text);width:100%}
.center{display:flex;align-items:center;gap:8px;justify-content:space-between}

.viewer{flex:1;display:flex;flex-direction:column;gap:12px}
.viewer-top{display:flex;gap:12px;align-items:center}
.page-area{background:var(--card);padding:12px;border-radius:10px;border:1px solid var(--border);display:flex;flex-direction:column;gap:10px;align-items:center}

/* page container: canvas + svg overlay */
.page-container{position:relative;background:#ffffff;border-radius:6px;overflow:hidden;box-shadow:0 6px 18px rgba(0,0,0,0.25)}
.page-canvas{display:block;max-width:100%;height:auto;display:block}
.svg-overlay{position:absolute;left:0;top:0;pointer-events:auto}

/* annotation visuals */
.annot-text{font-family:Inter, system-ui, Arial; cursor:move}
.annot-rect{fill:transparent;stroke-width:1.6;stroke:var(--primary);cursor:move}
.annot-highlight{fill:yellow;opacity:0.35;cursor:move}

/* resize handles container (SVG foreignObject) */
.handle{fill:#ffffff;stroke:#222;stroke-width:1;cursor:nwse-resize}

/* progress bar */
.progress{height:10px;background:var(--border);border-radius:999px;overflow:hidden}
.progress-bar{height:100%;width:0;background:var(--primary);transition:width .2s}

/* footer */
.footer{margin-top:18px;padding:12px 0;background:var(--card);border-top:1px solid var(--border);text-align:center;color:var(--muted)}

/* responsive */
@media(max-width:980px){.editor-wrap{flex-direction:column}.left-panel{width:100%}.viewer{width:100%}}
</style>
</head>
<body>
<header class="container">
  <div class="brand">
    <a href="../../index.html" title="Smarttool Hub home">
      <img src="https://img.icons8.com/fluency/48/edit-file.png" alt="logo">
      <div>
        <div class="title">Smarttool Hub</div>
        <div class="tag">Fast • Private • Client-side</div>
      </div>
    </a>
  </div>
  <div class="header-actions">
    <a href="../../index.html" class="btn-header" title="Home"><i class="fa-solid fa-house"></i></a>
    <button id="themeBtn" class="btn-header" title="Toggle theme"><i id="themeIcon" class="fa-solid fa-moon"></i></button>
  </div>
</header>

<main class="container">
  <h1 style="color:var(--primary);margin:8px 0">PDF Editor — Add Text, Shapes & Highlights</h1>
  <p style="color:var(--muted)">Upload a PDF, add annotations (text, rectangle, ellipse, highlights), move and resize them, and export a new PDF with vector annotations — all in your browser.</p>

  <label id="uploader" class="uploader" title="Click or drop PDF">
    <div style="font-size:22px;color:var(--primary)"><i class="fa-solid fa-file-pdf"></i></div>
    <div style="font-weight:700;margin-top:8px">Click or drag & drop a PDF to start</div>
    <div style="color:var(--muted);margin-top:6px">Supported: .pdf (single file). No upload.</div>
    <input id="fileInput" type="file" accept="application/pdf">
  </label>

  <div class="editor-wrap">
    <!-- left toolbar -->
    <aside class="left-panel" aria-label="tools">
      <div style="font-weight:800;color:var(--primary)">Tools</div>
      <div class="toolbar" id="toolbar">
        <button class="tool-btn" data-tool="select" id="tool-select"><i class="fa-solid fa-arrow-pointer"></i> Select/Move</button>
        <button class="tool-btn" data-tool="text" id="tool-text"><i class="fa-solid fa-font"></i> Add Text</button>
        <button class="tool-btn" data-tool="highlight" id="tool-highlight"><i class="fa-solid fa-highlighter"></i> Highlight</button>
        <button class="tool-btn" data-tool="rect" id="tool-rect"><i class="fa-solid fa-square-full"></i> Rectangle</button>
        <button class="tool-btn" data-tool="ellipse" id="tool-ellipse"><i class="fa-solid fa-circle"></i> Ellipse</button>
      </div>

      <div style="margin-top:12px">
        <label class="small">Annotation color</label>
        <input id="annotColor" type="color" value="#ffd200" class="small" style="width:100%;padding:6px"/>
      </div>

      <div style="margin-top:10px">
        <label class="small">Text size</label>
        <input id="textSize" type="number" min="8" max="72" value="14" class="small"/>
      </div>

      <div style="margin-top:12px">
        <button id="prevPage" class="tool-btn"><i class="fa-solid fa-chevron-left"></i> Prev Page</button>
        <button id="nextPage" class="tool-btn"><i class="fa-solid fa-chevron-right"></i> Next Page</button>
      </div>

      <div style="margin-top:12px">
        <button id="exportBtn" class="tool-btn" style="background:var(--primary);color:#00131f"><i class="fa-solid fa-download"></i> Export PDF</button>
      </div>

      <div style="margin-top:14px;color:var(--muted);font-size:.92rem">
        <strong>How to use</strong>
        <ul>
          <li>Choose a tool, then click (text) or drag (shapes/highlight) on the page.</li>
          <li>Double-click text to edit. Drag to move annotations. Click to select and use corner handles to resize. Delete to remove.</li>
          <li>Export creates a new PDF with vector annotations added.</li>
        </ul>
      </div>
    </aside>

    <!-- viewer -->
    <section class="viewer">
      <div class="viewer-top center">
        <div style="display:flex;gap:10px;align-items:center">
          <div><strong>Page</strong> <span id="pageNumber">0</span> / <span id="pageCount">0</span></div>
        </div>
        <div style="min-width:280px">
          <div class="progress"><div class="progress-bar" id="progressBar" style="width:0%"></div></div>
        </div>
      </div>

      <div class="page-area" id="pageArea">
        <!-- page container created dynamically -->
      </div>

      <div style="color:var(--muted)">Tip: annotations are saved in-memory — export to download the edited PDF.</div>
    </section>
  </div>

  <div class="footer">
    © <span id="year"></span> Smarttool Hub — Privacy • Terms • Contact
  </div>
</main>

<!-- FAQ JSON-LD -->
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"FAQPage","mainEntity":[{"@type":"Question","name":"Can I edit PDF text content?","acceptedAnswer":{"@type":"Answer","text":"This editor lets you add new text annotations. It does not alter the original embedded text streams; it adds vector text annotations on top."}},{"@type":"Question","name":"Are files uploaded to a server?","acceptedAnswer":{"@type":"Answer","text":"No. All processing is done inside your browser; files are not uploaded."}}]}
</script>

<!-- libs -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
<script>pdfjsLib.GlobalWorkerOptions.workerSrc='https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';</script>
<script src="https://unpkg.com/pdf-lib/dist/pdf-lib.min.js"></script>

<script>
// ========== PDF Editor with Resize Handles ==========

let pdfDocJS = null;
let pdfFileBuffer = null;
let pageCount = 0;
let currentPage = 0;
const annotations = {}; // annotations[pageIndex] = [ ... ]
let activeTool = 'select';
let annotColor = '#ffd200';
let textSize = 14;

const fileInput = document.getElementById('fileInput');
const uploader = document.getElementById('uploader');
const pageArea = document.getElementById('pageArea');
const progressBar = document.getElementById('progressBar');
const pageNumberEl = document.getElementById('pageNumber');
const pageCountEl = document.getElementById('pageCount');
const toolbar = document.getElementById('toolbar');
const toolButtons = document.querySelectorAll('.tool-btn');
const annotColorInput = document.getElementById('annotColor');
const textSizeInput = document.getElementById('textSize');
const prevPageBtn = document.getElementById('prevPage');
const nextPageBtn = document.getElementById('nextPage');
const exportBtn = document.getElementById('exportBtn');
const themeBtn = document.getElementById('themeBtn');
const themeIcon = document.getElementById('themeIcon');

document.getElementById('year').textContent = new Date().getFullYear();

if(localStorage.getItem('sth_theme') === 'light'){ document.body.classList.add('light'); themeIcon.className='fa-solid fa-sun'; }
themeBtn.addEventListener('click', ()=> {
  document.body.classList.toggle('light');
  if(document.body.classList.contains('light')){ localStorage.setItem('sth_theme','light'); themeIcon.className='fa-solid fa-sun'; }
  else { localStorage.removeItem('sth_theme'); themeIcon.className='fa-solid fa-moon'; }
});

uploader.addEventListener('click', ()=> fileInput.click());
uploader.addEventListener('dragover', e=> { e.preventDefault(); uploader.style.borderColor = 'var(--primary)'; });
uploader.addEventListener('dragleave', e=> { uploader.style.borderColor = ''; });
uploader.addEventListener('drop', e=> { e.preventDefault(); uploader.style.borderColor = ''; handleFile(e.dataTransfer.files[0]); });
fileInput.addEventListener('change', e => handleFile(e.target.files[0]));

async function handleFile(file){
  if(!file) return;
  if(!(file.type === 'application/pdf' || file.name.toLowerCase().endsWith('.pdf'))){
    alert('Please select a PDF file.');
    return;
  }
  resetState();
  setProgress(3);
  const buf = await file.arrayBuffer();
  pdfFileBuffer = buf;
  try{
    pdfDocJS = await pdfjsLib.getDocument({data:buf}).promise;
    pageCount = pdfDocJS.numPages;
    pageCountEl.textContent = pageCount;
    currentPage = 1;
    for(let i=1;i<=pageCount;i++) if(!annotations[i]) annotations[i] = [];
    await renderPage(currentPage);
    setProgress(100);
  } catch(err){
    console.error('Failed to load PDF', err);
    alert('Failed to load PDF.');
  } finally { setTimeout(()=> setProgress(0), 400); }
}

function setProgress(p){ progressBar.style.width = Math.min(100,Math.max(0,Math.round(p))) + '%'; }

toolButtons.forEach(btn => btn.addEventListener('click', () => {
  toolButtons.forEach(b => b.classList.remove('active'));
  btn.classList.add('active');
  activeTool = btn.dataset.tool;
}));

annotColorInput.addEventListener('input', (e) => annotColor = e.target.value);
textSizeInput.addEventListener('change', (e) => textSize = Number(e.target.value) || 14);

prevPageBtn.addEventListener('click', ()=> { if(currentPage>1) renderPage(currentPage-1); });
nextPageBtn.addEventListener('click', ()=> { if(currentPage<pageCount) renderPage(currentPage+1); });

async function renderPage(pageNum){
  if(!pdfDocJS) return;
  setProgress(5);
  currentPage = pageNum;
  pageNumberEl.textContent = pageNum;
  pageArea.innerHTML = '';
  const page = await pdfDocJS.getPage(pageNum);
  const viewport = page.getViewport({ scale: 1.5 });
  const canvas = document.createElement('canvas');
  canvas.className = 'page-canvas';
  canvas.width = Math.round(viewport.width);
  canvas.height = Math.round(viewport.height);
  const ctx = canvas.getContext('2d');
  ctx.fillStyle = '#fff'; ctx.fillRect(0,0,canvas.width,canvas.height);
  await page.render({ canvasContext: ctx, viewport }).promise;
  const container = document.createElement('div');
  container.className = 'page-container';
  container.style.width = canvas.width + 'px';
  container.style.height = canvas.height + 'px';
  const svgNS = 'http://www.w3.org/2000/svg';
  const svg = document.createElementNS(svgNS, 'svg');
  svg.setAttribute('width', canvas.width);
  svg.setAttribute('height', canvas.height);
  svg.classList.add('svg-overlay');
  svg.style.width = canvas.width + 'px';
  svg.style.height = canvas.height + 'px';
  svg.style.pointerEvents = 'auto';
  const pageAnn = annotations[pageNum] || [];
  pageAnn.forEach(a => drawAnnotationOnSVG(svg, a, canvas.width, canvas.height));
  attachSvgEvents(svg, canvas, pageNum);
  container.appendChild(canvas);
  container.appendChild(svg);
  pageArea.appendChild(container);
  setProgress(60);
  await new Promise(r=>setTimeout(r,50));
  setProgress(100);
  setTimeout(()=> setProgress(0),200);
}

function drawAnnotationOnSVG(svg, ann, pageW, pageH){
  const svgNS = 'http://www.w3.org/2000/svg';
  const elId = ann.id || ('a'+Math.random().toString(36).slice(2,9));
  ann.id = elId;
  if(ann.type === 'text'){
    const t = document.createElementNS(svgNS, 'text');
    t.setAttribute('x', ann.x * pageW);
    t.setAttribute('y', ann.y * pageH);
    t.setAttribute('fill', ann.color || '#000');
    t.setAttribute('font-size', ann.size || 14);
    t.setAttribute('class', 'annot-text');
    t.setAttribute('data-id', elId);
    t.textContent = ann.text || 'Text';
    t.addEventListener('dblclick', (ev)=> {
      ev.stopPropagation();
      const newText = prompt('Edit text', ann.text || '');
      if(newText !== null){ ann.text = newText; t.textContent = newText; }
    });
    makeDraggableSVG(t, ann, svg, pageW, pageH);
    svg.appendChild(t);
    addResizeHandlesSVG(svg, t, ann, pageW, pageH);
  } else if(ann.type === 'rect' || ann.type === 'highlight'){
    const r = document.createElementNS(svgNS, 'rect');
    r.setAttribute('x', ann.x * pageW);
    r.setAttribute('y', ann.y * pageH);
    r.setAttribute('width', (ann.w || 0) * pageW);
    r.setAttribute('height', (ann.h || 0) * pageH);
    r.setAttribute('stroke', ann.color || '#000');
    r.setAttribute('fill', ann.type === 'highlight' ? (ann.color || '#ffff00') : 'transparent');
    if(ann.type === 'highlight') r.setAttribute('fill-opacity', ann.opacity ?? 0.35);
    r.setAttribute('stroke-width', 1.5);
    r.setAttribute('class', ann.type === 'highlight' ? 'annot-highlight' : 'annot-rect');
    r.setAttribute('data-id', elId);
    makeDraggableSVG(r, ann, svg, pageW, pageH);
    svg.appendChild(r);
    addResizeHandlesSVG(svg, r, ann, pageW, pageH);
  } else if(ann.type === 'ellipse'){
    const e = document.createElementNS(svgNS, 'ellipse');
    const cx = (ann.x + (ann.w || 0)/2) * pageW;
    const cy = (ann.y + (ann.h || 0)/2) * pageH;
    const rx = (ann.w || 0) * pageW / 2;
    const ry = (ann.h || 0) * pageH / 2;
    e.setAttribute('cx', cx); e.setAttribute('cy', cy); e.setAttribute('rx', rx); e.setAttribute('ry', ry);
    e.setAttribute('stroke', ann.color || '#000'); e.setAttribute('fill','transparent'); e.setAttribute('stroke-width',1.6);
    e.setAttribute('data-id', elId);
    makeDraggableSVG(e, ann, svg, pageW, pageH);
    svg.appendChild(e);
    addResizeHandlesSVG(svg, e, ann, pageW, pageH);
  }
}

// Make an SVG element draggable AND track normalized coords
function makeDraggableSVG(svgEl, ann, svgRoot, pageW, pageH){
  svgEl.style.cursor = 'move';
  let isDown=false, startX=0, startY=0, origX=0, origY=0;
  svgEl.addEventListener('mousedown', (e)=> {
    e.stopPropagation();
    if(activeTool !== 'select') return; // only move in select mode
    isDown=true;
    const pt = svgRoot.getBoundingClientRect();
    startX = e.clientX - pt.left; startY = e.clientY - pt.top;
    origX = (ann.x || 0) * pageW; origY = (ann.y || 0) * pageH;
    highlightSelected(svgEl);
  });
  window.addEventListener('mousemove', (e)=> {
    if(!isDown) return;
    const pt = svgRoot.getBoundingClientRect();
    const curX = e.clientX - pt.left, curY = e.clientY - pt.top;
    const dx = curX - startX, dy = curY - startY;
    if(ann.type === 'text'){
      const newX = origX + dx, newY = origY + dy;
      svgEl.setAttribute('x', newX); svgEl.setAttribute('y', newY);
      ann.x = newX / pageW; ann.y = newY / pageH;
      // update handles position if present
      updateHandlesPosition(svgRoot, ann, pageW, pageH);
    } else if(ann.type === 'rect' || ann.type === 'highlight'){
      const newX = origX + dx, newY = origY + dy;
      svgEl.setAttribute('x', newX); svgEl.setAttribute('y', newY);
      ann.x = newX / pageW; ann.y = newY / pageH;
      updateHandlesPosition(svgRoot, ann, pageW, pageH);
    } else if(ann.type === 'ellipse'){
      const newCx = (origX + dx) + ((ann.w||0)*pageW)/2;
      const newCy = (origY + dy) + ((ann.h||0)*pageH)/2;
      svgEl.setAttribute('cx', newCx); svgEl.setAttribute('cy', newCy);
      ann.x = (newCx - ((ann.w||0)*pageW)/2) / pageW;
      ann.y = (newCy - ((ann.h||0)*pageH)/2) / pageH;
      updateHandlesPosition(svgRoot, ann, pageW, pageH);
    }
  });
  window.addEventListener('mouseup', ()=> { if(isDown) isDown=false; });
  svgEl.addEventListener('click', (e)=> { e.stopPropagation(); selectAnnotation(svgEl, ann, svgRoot); });
}

/* ----- Resize handles -----
   We'll add 4 small square handles (TL, TR, BR, BL). Dragging a handle resizes the annotation.
   Resize math updates ann.x, ann.y, ann.w, ann.h (normalized).
*/
function addResizeHandlesSVG(svgRoot, svgEl, ann, pageW, pageH){
  // ensure there's a group container for handles per annotation id
  const svgNS = 'http://www.w3.org/2000/svg';
  const gid = 'handles_' + ann.id;
  // remove existing handles if any (to avoid duplicates)
  const old = svgRoot.querySelector('#' + gid);
  if(old) old.remove();
  const g = document.createElementNS(svgNS, 'g');
  g.setAttribute('id', gid);
  // compute bbox depending on annotation type
  let x=0,y=0,w=0,h=0;
  if(ann.type === 'text'){
    x = (ann.x || 0) * pageW; y = (ann.y || 0) * pageH; w = (ann.w || 0) * pageW || 60; h = (ann.h || 0) * pageH || parseFloat(ann.size || 14);
  } else if(ann.type === 'rect' || ann.type === 'highlight'){
    x = (ann.x || 0) * pageW; y = (ann.y || 0) * pageH; w = (ann.w || 0) * pageW; h = (ann.h || 0) * pageH;
  } else if(ann.type === 'ellipse'){
    x = (ann.x || 0) * pageW; y = (ann.y || 0) * pageH; w = (ann.w || 0) * pageW; h = (ann.h || 0) * pageH;
  }
  // if zero-size, don't add handles
  if(w <= 2 && h <= 2) return;
  // handle positions: tl,tr,br,bl
  const size = 10;
  const points = [
    {cx: x,      cy: y,       name:'tl', cursor:'nwse-resize'},
    {cx: x + w,  cy: y,       name:'tr', cursor:'nesw-resize'},
    {cx: x + w,  cy: y + h,   name:'br', cursor:'nwse-resize'},
    {cx: x,      cy: y + h,   name:'bl', cursor:'nesw-resize'}
  ];
  points.forEach(pt => {
    const rect = document.createElementNS(svgNS, 'rect');
    rect.setAttribute('x', pt.cx - size/2); rect.setAttribute('y', pt.cy - size/2);
    rect.setAttribute('width', size); rect.setAttribute('height', size);
    rect.setAttribute('fill', '#fff'); rect.setAttribute('stroke', '#222'); rect.setAttribute('stroke-width', 1);
    rect.setAttribute('class', 'annot-handle');
    rect.style.cursor = pt.cursor;
    rect.dataset.handle = pt.name;
    // attach drag handlers
    makeHandleDraggable(rect, ann, svgRoot, pageW, pageH);
    g.appendChild(rect);
  });
  svgRoot.appendChild(g);
}

// update handles position after move or resize
function updateHandlesPosition(svgRoot, ann, pageW, pageH){
  const gid = 'handles_' + ann.id;
  const g = svgRoot.querySelector('#' + gid);
  if(!g) return;
  let x=0,y=0,w=0,h=0;
  if(ann.type === 'text'){ x = (ann.x || 0) * pageW; y = (ann.y || 0) * pageH; w = (ann.w || 0) * pageW || 60; h = (ann.h || 0) * pageH || (ann.size||14); }
  else { x = (ann.x || 0) * pageW; y = (ann.y || 0) * pageH; w = (ann.w || 0) * pageW; h = (ann.h || 0) * pageH; }
  const rects = g.querySelectorAll('rect.annot-handle');
  const size = 10;
  rects.forEach(r => {
    const name = r.dataset.handle;
    let cx=0, cy=0;
    if(name === 'tl'){ cx = x; cy = y; }
    if(name === 'tr'){ cx = x + w; cy = y; }
    if(name === 'br'){ cx = x + w; cy = y + h; }
    if(name === 'bl'){ cx = x; cy = y + h; }
    r.setAttribute('x', cx - size/2); r.setAttribute('y', cy - size/2);
  });
}

// Drag logic for a handle -> resize ann
function makeHandleDraggable(handleEl, ann, svgRoot, pageW, pageH){
  let dragging = false, startX=0,startY=0, startAnn = null;
  handleEl.addEventListener('mousedown', (e)=> {
    e.stopPropagation();
    dragging = true;
    const rect = svgRoot.getBoundingClientRect();
    startX = e.clientX - rect.left; startY = e.clientY - rect.top;
    // clone ann for baseline
    startAnn = Object.assign({}, ann);
    // prevent selection of other elements
    window.addEventListener('mousemove', onMove);
    window.addEventListener('mouseup', onUp);
  });
  function onMove(e){
    if(!dragging) return;
    const rect = svgRoot.getBoundingClientRect();
    const curX = e.clientX - rect.left, curY = e.clientY - rect.top;
    const dx = curX - startX, dy = curY - startY;
    // compute original absolute values
    const ox = (startAnn.x || 0) * pageW, oy = (startAnn.y || 0) * pageH;
    const ow = (startAnn.w || 0) * pageW, oh = (startAnn.h || 0) * pageH;
    const handleName = handleEl.dataset.handle;
    // Depending on handle, compute new bbox
    let nx=ox, ny=oy, nw=ow, nh=oh;
    if(handleName === 'tl'){
      nx = ox + dx; ny = oy + dy; nw = ow - dx; nh = oh - dy;
    } else if(handleName === 'tr'){
      nx = ox; ny = oy + dy; nw = ow + dx; nh = oh - dy;
    } else if(handleName === 'br'){
      nx = ox; ny = oy; nw = ow + dx; nh = oh + dy;
    } else if(handleName === 'bl'){
      nx = ox + dx; ny = oy; nw = ow - dx; nh = oh + dy;
    }
    // Prevent negative sizes: clamp
    if(nw < 4){ nw = 4; if(handleName === 'tl' || handleName === 'bl') nx = ox + ow - nw; }
    if(nh < 4){ nh = 4; if(handleName === 'tl' || handleName === 'tr') ny = oy + oh - nh; }
    // Update ann normalized
    ann.x = nx / pageW; ann.y = ny / pageH; ann.w = nw / pageW; ann.h = nh / pageH;
    // Update the corresponding SVG element visuals
    refreshSVG(svgRoot, getPageForSVG(svgRoot), pageW, pageH);
  }
  function onUp(e){
    dragging = false;
    window.removeEventListener('mousemove', onMove);
    window.removeEventListener('mouseup', onUp);
  }
}

// helper to get current page index for a given svgRoot — locate container and compute page index from DOM
function getPageForSVG(svgRoot){
  // the svgRoot lives inside pageArea -> container -> index among children corresponds to page? we only show one page at a time, so return currentPage
  return currentPage;
}

let selectedSVGEl = null;
function highlightSelected(svgEl){
  if(selectedSVGEl){ selectedSVGEl.style.outline = 'none'; }
  selectedSVGEl = svgEl;
  svgEl.style.outline = '2px dashed rgba(255,255,255,0.12)';
  window.addEventListener('keydown', onKeyDownDelete);
}
function onKeyDownDelete(e){
  if(e.key === 'Delete' || e.key === 'Backspace'){
    if(!selectedSVGEl) return;
    const id = selectedSVGEl.getAttribute('data-id');
    if(!id) return;
    const anns = annotations[currentPage] || [];
    const idx = anns.findIndex(a => a.id === id);
    if(idx >= 0){ anns.splice(idx,1); selectedSVGEl.remove(); selectedSVGEl = null; refreshPage(); }
    window.removeEventListener('keydown', onKeyDownDelete);
  }
}

function selectAnnotation(svgEl, ann, svgRoot){
  highlightSelected(svgEl);
  // ensure handles are visible (handled by drawAnnotationOnSVG which creates handles)
}

// click on empty space deselects
document.addEventListener('click', (e)=> {
  if(selectedSVGEl){ selectedSVGEl.style.outline = 'none'; selectedSVGEl = null; window.removeEventListener('keydown', onKeyDownDelete); }
});

// Creation interactions (click to add text, drag to add shapes)
function attachSvgEvents(svg, canvas, pageNum){
  let isDrawing=false, startX=0, startY=0, curTemp=null;
  const pageW = canvas.width, pageH = canvas.height;
  svg.addEventListener('mousedown', (e)=> {
    if(activeTool === 'select') return;
    const rect = svg.getBoundingClientRect();
    startX = e.clientX - rect.left; startY = e.clientY - rect.top;
    isDrawing = true;
    if(activeTool === 'text'){
      const normX = startX / pageW, normY = startY / pageH;
      const ann = { id:'a'+Math.random().toString(36).slice(2,9), type:'text', x: normX, y: normY, color: annotColor, size: textSize, text:'New text' };
      annotations[pageNum].push(ann);
      drawAnnotationOnSVG(svg, ann, pageW, pageH);
      setTimeout(()=> {
        const newText = prompt('Edit text', ann.text);
        if(newText !== null){ ann.text = newText; refreshSVG(svg, pageNum, pageW, pageH); }
      }, 40);
      isDrawing = false;
    } else if(activeTool === 'highlight' || activeTool === 'rect' || activeTool === 'ellipse'){
      const svgNS = 'http://www.w3.org/2000/svg';
      if(activeTool === 'highlight' || activeTool === 'rect'){
        curTemp = document.createElementNS(svgNS,'rect');
        curTemp.setAttribute('x', startX); curTemp.setAttribute('y', startY); curTemp.setAttribute('width', 0); curTemp.setAttribute('height', 0);
        curTemp.setAttribute('fill', activeTool === 'highlight' ? annotColor : 'transparent');
        if(activeTool === 'highlight') curTemp.setAttribute('fill-opacity', 0.35);
        curTemp.setAttribute('stroke', annotColor); curTemp.setAttribute('stroke-width', 1.5);
        svg.appendChild(curTemp);
      } else if(activeTool === 'ellipse'){
        curTemp = document.createElementNS('http://www.w3.org/2000/svg','ellipse');
        curTemp.setAttribute('cx', startX); curTemp.setAttribute('cy', startY); curTemp.setAttribute('rx',0); curTemp.setAttribute('ry',0);
        curTemp.setAttribute('stroke', annotColor); curTemp.setAttribute('fill','transparent'); curTemp.setAttribute('stroke-width',1.6);
        svg.appendChild(curTemp);
      }
    }
  });
  svg.addEventListener('mousemove', (e)=> {
    if(!isDrawing || !curTemp) return;
    const rect = svg.getBoundingClientRect();
    const mx = e.clientX - rect.left, my = e.clientY - rect.top;
    const x = Math.min(startX, mx), y = Math.min(startY, my), w = Math.abs(mx - startX), h = Math.abs(my - startY);
    if(curTemp.tagName === 'rect'){ curTemp.setAttribute('x', x); curTemp.setAttribute('y', y); curTemp.setAttribute('width', w); curTemp.setAttribute('height', h); }
    else if(curTemp.tagName === 'ellipse'){ curTemp.setAttribute('cx', x + w/2); curTemp.setAttribute('cy', y + h/2); curTemp.setAttribute('rx', w/2); curTemp.setAttribute('ry', h/2); }
  });
  svg.addEventListener('mouseup', (e)=> {
    if(isDrawing && curTemp){
      const rectBox = curTemp.getBBox();
      const ann = { id:'a'+Math.random().toString(36).slice(2,9), type: (activeTool === 'highlight' ? 'highlight' : (activeTool==='rect'?'rect':'ellipse')), x: rectBox.x / pageW, y: rectBox.y / pageH, w: rectBox.width / pageW, h: rectBox.height / pageH, color: annotColor, opacity: 0.35 };
      annotations[pageNum].push(ann);
      curTemp.remove(); curTemp = null;
      drawAnnotationOnSVG(svg, ann, pageW, pageH);
    }
    isDrawing = false;
  });
  svg.addEventListener('click', (e)=> {
    // clicking empty area deselects
    if(selectedSVGEl){ selectedSVGEl.style.outline = 'none'; selectedSVGEl = null; window.removeEventListener('keydown', onKeyDownDelete); }
  });
}

// refresh svg overlay (clear & redraw)
function refreshSVG(svg, pageNum, pageW, pageH){
  while(svg.firstChild) svg.removeChild(svg.firstChild);
  const pageAnn = annotations[pageNum] || [];
  pageAnn.forEach(a => drawAnnotationOnSVG(svg, a, pageW, pageH));
}

// Export using pdf-lib
exportBtn.addEventListener('click', async ()=>{
  if(!pdfFileBuffer) { alert('Load a PDF first'); return; }
  try{
    setProgress(5);
    const src = await PDFLib.PDFDocument.load(pdfFileBuffer, { ignoreEncryption: true });
    const out = await PDFLib.PDFDocument.create();
    const total = src.getPageCount();
    const copiedPages = await out.copyPages(src, Array.from({length: total}, (_,i)=>i));
    for(let i=0;i<total;i++) out.addPage(copiedPages[i]);
    setProgress(30);
    for(let i=1;i<=total;i++){
      const page = out.getPage(i-1);
      const annList = annotations[i] || [];
      if(annList.length === 0){ setProgress(30 + (i/total)*60); continue; }
      const { width, height } = page.getSize();
      for(const ann of annList){
        if(ann.type === 'text'){
          const x = ann.x * width;
          const y = height - (ann.y * height);
          page.drawText(ann.text || '', { x: x, y: y, size: ann.size || 14, color: PDFLib.rgb(...hexToRgbNormalized(ann.color || '#000')) });
        } else if(ann.type === 'rect' || ann.type === 'highlight'){
          const x = ann.x * width;
          const y = height - (ann.y * height) - (ann.h * height);
          const w = ann.w * width;
          const h = ann.h * height;
          const colorRgb = hexToRgbNormalized(ann.color || '#000');
          if(ann.type === 'rect'){
            page.drawRectangle({ x, y, width: w, height: h, borderColor: PDFLib.rgb(...colorRgb), borderWidth: 1.4 });
          } else {
            page.drawRectangle({ x, y, width: w, height: h, color: PDFLib.rgb(...colorRgb), opacity: ann.opacity ?? 0.35 });
          }
        } else if(ann.type === 'ellipse'){
          const cx = ann.x * width + (ann.w * width)/2;
          const cy = height - (ann.y * height) - (ann.h * height)/2;
          const rx = (ann.w * width)/2;
          const ry = (ann.h * height)/2;
          // pdf-lib supports drawEllipse in recent builds; use it if available
          if(typeof page.drawEllipse === 'function'){
            page.drawEllipse({ x: cx, y: cy, xScale: rx, yScale: ry, borderColor: PDFLib.rgb(...hexToRgbNormalized(ann.color||'#000')), borderWidth: 1.4 });
          } else {
            // fallback: draw rectangle border as approximation
            page.drawRectangle({ x: cx - rx, y: cy - ry, width: rx*2, height: ry*2, borderColor: PDFLib.rgb(...hexToRgbNormalized(ann.color||'#000')), borderWidth: 1.4 });
          }
        }
      }
      setProgress(30 + (i/total)*60);
    }
    setProgress(95);
    const bytes = await out.save();
    const blob = new Blob([bytes], { type: 'application/pdf' });
    downloadBlob(blob, 'edited_' + (new Date().toISOString().replace(/[:.]/g,'-')) + '.pdf');
    setProgress(100);
    setTimeout(()=> setProgress(0), 800);
    alert('Export complete. Download should start automatically.');
  } catch(err){
    console.error(err);
    alert('Export failed — see console for details.');
    setProgress(0);
  }
});

function downloadBlob(blob, filename){
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  setTimeout(()=> URL.revokeObjectURL(a.href), 4000);
}
function hexToRgbNormalized(hex){
  const c = hex.replace('#','');
  const full = c.length===3 ? c.split('').map(ch=>ch+ch).join('') : c;
  const bigint = parseInt(full, 16);
  const r = (bigint >> 16) & 255, g = (bigint >> 8) & 255, b = bigint & 255;
  return [r/255, g/255, b/255];
}
function resetState(){ pdfDocJS = null; pdfFileBuffer = null; pageCount = 0; currentPage = 0; for(const k in annotations) delete annotations[k]; pageArea.innerHTML = ''; pageNumberEl.textContent = '0'; pageCountEl.textContent = '0'; }
</script>
</body>
</html>
