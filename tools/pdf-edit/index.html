<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Edit PDF Online - Smarttool Hub (Fixed Upload)</title>
  <meta name="description" content="Edit PDF pages in the browser: draw, add text, add images, then download the edited PDF. Fixed upload handling." />
  <link rel="icon" href="https://img.icons8.com/fluency/48/toolbox.png" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css"/>
  <style>
    /* Design preserved exactly like your uploaded tools */
    :root{--bg:#0b1220;--text:#eaf2ff;--card:#182335;--border:#2a3b55;--primary:#22d3ee;--muted:#9fb3c8;--radius:12px}
    body.light{--bg:#f6f8fb;--text:#0b1220;--card:#ffffff;--border:#e6eefc;--primary:#0b74ff;--muted:#556677}
    *{box-sizing:border-box;margin:0;padding:0}
    body{font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial;background:var(--bg);color:var(--text);min-height:100vh;display:flex;flex-direction:column;transition:background .25s,color .25s}
    .container{max-width:1200px;margin:0 auto;padding:20px;width:100%}
    header{display:flex;align-items:center;justify-content:space-between;gap:12px;background:var(--card);border-bottom:1px solid var(--border);padding:14px 20px}
    .brand{display:flex;gap:12px;align-items:center}
    .brand img{width:46px;height:46px;border-radius:10px}
    .brand .title{font-size:1.25rem;font-weight:700;color:var(--primary);margin:0}
    .brand .tag{font-size:.9rem;color:var(--muted)}
    .header-actions{display:flex;gap:10px;align-items:center}
    .btn-header{border:1px solid var(--border);background:transparent;padding:8px 12px;border-radius:8px;color:var(--text);cursor:pointer;display:flex;align-items:center;gap:6px;text-decoration:none;font-weight:600}
    .btn-header:hover{border-color:var(--primary);color:var(--primary)}

    .tool-content { background:var(--card);border-radius:var(--radius);border:1px solid var(--border);padding:18px;margin-top:20px; }
    .tool-title { font-size:1.6rem;margin-bottom:5px;color:var(--primary); }
    .tool-description { color:var(--muted);margin-bottom:14px; }

    .layout { display:grid; grid-template-columns: 320px 1fr 360px; gap:16px; align-items:start; }
    @media (max-width:1100px){ .layout{ grid-template-columns: 1fr; } }

    .panel { background:var(--bg); border:1px solid var(--border); padding:12px; border-radius:10px; }
    .upload-area { border:2px dashed var(--border); border-radius:10px; padding:12px; text-align:center; cursor:pointer; background:transparent; user-select:none; }
    .upload-area.dragover { border-color:var(--primary); background:rgba(34,211,238,0.03); }

    .thumbs { display:flex; flex-direction:column; gap:8px; max-height:56vh; overflow:auto; padding:6px; }
    .thumb { display:flex; gap:8px; align-items:center; padding:8px; border-radius:8px; border:1px solid var(--border); cursor:pointer; background:var(--card); }
    .thumb.active { border-color:var(--primary); box-shadow:0 4px 20px rgba(34,211,238,0.06); }
    .thumb .tmeta { font-size:0.9rem; color:var(--muted); }

    .viewer { position:relative; display:flex; flex-direction:column; align-items:center; gap:8px; min-height:60vh; justify-content:flex-start; }
    .page-wrap { position:relative; background:#0b0f13; border-radius:8px; padding:10px; border:1px solid var(--border); }
    canvas.baseCanvas { display:block; max-width:100%; height:auto; border-radius:4px; background:white; }
    canvas.overlayCanvas { position:absolute; left:10px; top:10px; pointer-events:auto; touch-action:none; border-radius:4px; }

    .tools { display:flex; gap:8px; flex-wrap:wrap; margin-bottom:8px; }
    .btn { padding:8px 12px; border-radius:8px; border:none; cursor:pointer; font-weight:700; display:inline-flex; align-items:center; gap:8px; }
    .btn-primary { background:var(--primary); color:#00131f; }
    .btn-secondary { background:var(--card); color:var(--text); border:1px solid var(--border); }
    .tool-control { display:flex; gap:8px; align-items:center; color:var(--muted); }

    .right-panel { display:flex; flex-direction:column; gap:10px; max-height:80vh; overflow:auto; }
    .panel h4 { margin:0 0 8px 0; color:var(--primary); }

    .status { color:var(--muted); font-size:0.9rem; margin-top:6px; }
    .text-box { position:absolute; min-width:60px; min-height:28px; padding:6px 8px; border-radius:6px; background:rgba(255,255,255,0.9); color:#00131f; border:1px dashed rgba(0,0,0,0.12); cursor:move; resize:both; overflow:auto; }
    footer{margin-top:auto;padding:14px 0;background:var(--card);border-top:1px solid var(--border)}
  </style>
</head>
<body>
  <header class="container">
    <div class="brand">
      <a href="index.html" style="display:flex;align-items:center;gap:12px;text-decoration:none;">
        <img src="https://img.icons8.com/fluency/48/toolbox.png" alt="Smarttool Hub Logo">
        <div>
          <div class="title">Smarttool Hub</div>
          <div class="tag">Fast • Private • 100% Client-side</div>
        </div>
      </a>
    </div>
    <div class="header-actions">
      <a href="index.html" class="btn-header"><i class="fa-solid fa-house"></i> Home</a>
      <button class="btn-header" id="themeToggle" title="Toggle dark/light mode"><i class="fa-solid fa-moon"></i></button>
    </div>
  </header>

  <main class="container">
    <div class="tool-content">
      <div style="display:flex;justify-content:space-between;align-items:center;gap:12px">
        <div>
          <h1 class="tool-title">Edit PDF Online</h1>
          <div class="tool-description">Upload a PDF, edit pages (draw, add text, add images) and download the edited PDF. Fixed upload handling.</div>
        </div>
        <div class="status" id="statusMsg">Ready</div>
      </div>

      <div class="layout" style="margin-top:12px;">
        <!-- Left -->
        <div class="panel">
          <div class="upload-area" id="uploadArea" title="Click or drop a PDF here">
            <div style="font-weight:700;color:var(--muted)"><i class="fa-solid fa-file-pdf"></i> Drop PDF here or click to choose</div>
            <div style="margin-top:8px;color:var(--muted);font-size:0.9rem">Single PDF supported for editing</div>
            <input type="file" id="fileInput" accept="application/pdf" style="display:none">
          </div>

          <div style="margin-top:10px">
            <div style="display:flex;gap:8px">
              <button id="zoomIn" class="btn btn-secondary"><i class="fa-solid fa-magnifying-glass-plus"></i> Zoom In</button>
              <button id="zoomOut" class="btn btn-secondary"><i class="fa-solid fa-magnifying-glass-minus"></i> Zoom Out</button>
              <button id="fitWidth" class="btn btn-secondary"><i class="fa-solid fa-expand"></i> Fit Width</button>
            </div>
          </div>

          <h4 style="margin-top:12px">Pages</h4>
          <div class="thumbs" id="thumbs"></div>
        </div>

        <!-- Center -->
        <div class="panel viewer">
          <div class="tools" id="toolbar">
            <div class="tool-control">
              <button id="selectTool" class="btn btn-secondary"><i class="fa-solid fa-mouse-pointer"></i> Select</button>
              <button id="drawTool" class="btn btn-secondary"><i class="fa-solid fa-pen"></i> Draw</button>
              <button id="textTool" class="btn btn-secondary"><i class="fa-solid fa-font"></i> Text</button>
              <button id="imageTool" class="btn btn-secondary"><i class="fa-solid fa-image"></i> Image</button>
            </div>

            <div class="tool-control">
              <label style="font-weight:700;color:var(--muted)">Color</label>
              <input type="color" id="toolColor" value="#ff0000" style="height:34px;border-radius:6px;border:1px solid var(--border)"/>
              <label style="font-weight:700;color:var(--muted)">Size</label>
              <input type="range" id="toolSize" min="1" max="48" value="4"/>
              <span id="sizeVal" style="color:var(--muted);min-width:36px;text-align:center">4</span>
            </div>

            <div class="tool-control" style="margin-left:auto">
              <button id="undoBtn" class="btn btn-secondary"><i class="fa-solid fa-rotate-left"></i> Undo</button>
              <button id="clearBtn" class="btn btn-secondary"><i class="fa-solid fa-trash"></i> Clear</button>
              <button id="savePageBtn" class="btn btn-primary"><i class="fa-solid fa-save"></i> Save Page</button>
            </div>
          </div>

          <div id="pageContainer" style="width:100%;display:flex;justify-content:center;align-items:center;">
            <div class="page-wrap" id="pageWrap" style="display:none;"></div>
          </div>

          <div style="width:100%;display:flex;justify-content:space-between;align-items:center;margin-top:8px">
            <div style="color:var(--muted)"><span id="currentPageLabel">Page 0 / 0</span></div>
            <div style="display:flex;gap:8px">
              <button id="prevPage" class="btn btn-secondary"><i class="fa-solid fa-chevron-left"></i> Prev</button>
              <button id="nextPage" class="btn btn-secondary">Next <i class="fa-solid fa-chevron-right"></i></button>
            </div>
          </div>
        </div>

        <!-- Right -->
        <div class="panel right-panel">
          <div>
            <h4>Tools / Items</h4>
            <div id="itemsList" style="display:flex;flex-direction:column;gap:8px"></div>
          </div>

          <div>
            <h4>Add Image</h4>
            <input type="file" id="stampInput" accept="image/*" />
            <div class="status" style="margin-top:6px">Upload small PNG/JPG to stamp on pages.</div>
          </div>

          <div>
            <h4>Download</h4>
            <div style="display:flex;gap:8px;flex-wrap:wrap">
              <button id="downloadEditedPdf" class="btn btn-primary" disabled><i class="fa-solid fa-file-arrow-down"></i> Download Edited PDF</button>
              <button id="downloadCurrentPage" class="btn btn-secondary" disabled><i class="fa-solid fa-download"></i> Download Current Page</button>
              <button id="resetAll" class="btn btn-secondary"><i class="fa-solid fa-redo"></i> Reset</button>
            </div>
            <div class="status" id="downloadStatus" style="margin-top:8px"></div>
          </div>
        </div>
      </div>

    </div>
  </main>

  <footer class="container">
    <div class="footer-inner">
      <div>© <span id="year"></span> Smarttool Hub</div>
      <div class="footer-links">
        <a href="privacy.html">Privacy</a>
        <a href="terms.html">Terms</a>
        <a href="contact.html">Contact</a>
      </div>
    </div>
  </footer>

  <!-- Libraries -->
  <script src="https://cdn.jsdelivr.net/npm/pdf-lib/dist/pdf-lib.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/pdfjs-dist@3.10.120/build/pdf.min.js"></script>

  <script>
    // UI init
    document.getElementById('year').textContent = new Date().getFullYear();
    const themeToggle = document.getElementById('themeToggle');
    if (localStorage.getItem('sth_theme') === 'light') { document.body.classList.add('light'); themeToggle.innerHTML = '<i class="fa-solid fa-sun"></i>'; }
    themeToggle.onclick = () => {
      document.body.classList.toggle('light');
      if (document.body.classList.contains('light')) { themeToggle.innerHTML = '<i class="fa-solid fa-sun"></i>'; localStorage.setItem('sth_theme','light'); }
      else { themeToggle.innerHTML = '<i class="fa-solid fa-moon"></i>'; localStorage.removeItem('sth_theme'); }
    };

    // Set pdf.js worker (use jsDelivr) — important fix for many upload/load failures
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdn.jsdelivr.net/npm/pdfjs-dist@3.10.120/build/pdf.worker.min.js';

    // Elements
    const uploadArea = document.getElementById('uploadArea');
    const fileInput = document.getElementById('fileInput');
    const thumbs = document.getElementById('thumbs');
    const pageWrap = document.getElementById('pageWrap');
    const pageCountLabel = document.getElementById('currentPageLabel');
    const statusMsg = document.getElementById('statusMsg');

    const selectTool = document.getElementById('selectTool');
    const drawTool = document.getElementById('drawTool');
    const textTool = document.getElementById('textTool');
    const imageTool = document.getElementById('imageTool');
    const toolColor = document.getElementById('toolColor');
    const toolSize = document.getElementById('toolSize');
    const sizeVal = document.getElementById('sizeVal');
    const undoBtn = document.getElementById('undoBtn');
    const clearBtn = document.getElementById('clearBtn');
    const savePageBtn = document.getElementById('savePageBtn');
    const prevPage = document.getElementById('prevPage');
    const nextPage = document.getElementById('nextPage');
    const zoomIn = document.getElementById('zoomIn');
    const zoomOut = document.getElementById('zoomOut');
    const fitWidth = document.getElementById('fitWidth');

    const itemsList = document.getElementById('itemsList');
    const stampInput = document.getElementById('stampInput');
    const downloadEditedPdf = document.getElementById('downloadEditedPdf');
    const downloadCurrentPage = document.getElementById('downloadCurrentPage');
    const resetAll = document.getElementById('resetAll');

    // State
    let pdfDoc = null;
    let pdfArrayBuffer = null;
    let currentPageIndex = 0;
    let scale = 1.0;
    let baseCanvas = null;
    let overlayCanvas = null;
    let overlayCtx = null;
    let pageImagesCache = {};
    let pagesMeta = [];
    let activeTool = 'select';
    let drawing = false;
    let currentStroke = null;
    let stampImageBlob = null;

    // helpers
    function setStatus(msg) { statusMsg.textContent = msg; }
    function enableButton(btn, en) { btn.disabled = !en; }

    // Robust drag/drop: handle files and items
    uploadArea.addEventListener('click', () => fileInput.click());
    uploadArea.addEventListener('dragover', (e) => { e.preventDefault(); e.dataTransfer.dropEffect = 'copy'; uploadArea.classList.add('dragover'); });
    uploadArea.addEventListener('dragleave', (e) => { uploadArea.classList.remove('dragover'); });
    uploadArea.addEventListener('drop', async (e) => {
      e.preventDefault(); uploadArea.classList.remove('dragover');
      try {
        const files = [];
        if (e.dataTransfer && e.dataTransfer.files && e.dataTransfer.files.length) {
          for (let i=0;i<e.dataTransfer.files.length;i++) files.push(e.dataTransfer.files[i]);
        } else if (e.dataTransfer && e.dataTransfer.items && e.dataTransfer.items.length) {
          for (let i=0;i<e.dataTransfer.items.length;i++){
            const it = e.dataTransfer.items[i];
            if (it.kind === 'file') {
              const f = it.getAsFile();
              if (f) files.push(f);
            }
          }
        }
        if (!files.length) { setStatus('No file detected in drop'); return; }
        // pick first PDF file
        const pdfFile = files.find(f => f.type === 'application/pdf' || /\.pdf$/i.test(f.name));
        if (!pdfFile) { setStatus('No PDF file found in dropped items'); return; }
        await handlePdfFile(pdfFile);
      } catch (err) {
        console.error('drop handler error', err);
        setStatus('Drop failed: ' + (err && err.message ? err.message : 'unknown error'));
      }
    });

    // file input change
    fileInput.addEventListener('change', async (e) => {
      const f = e.target.files && e.target.files[0];
      if (!f) return;
      await handlePdfFile(f);
      fileInput.value = '';
    });

    // zoom controls
    zoomIn.addEventListener('click', () => { scale = Math.min(3, scale + 0.1); renderCurrentPage(); });
    zoomOut.addEventListener('click', () => { scale = Math.max(0.2, scale - 0.1); renderCurrentPage(); });
    fitWidth.addEventListener('click', () => { scale = 1; renderCurrentPage(); });

    // tool UI
    toolSize.addEventListener('input', () => { sizeVal.textContent = toolSize.value; });
    selectTool.addEventListener('click', () => setActiveTool('select'));
    drawTool.addEventListener('click', () => setActiveTool('draw'));
    textTool.addEventListener('click', () => setActiveTool('text'));
    imageTool.addEventListener('click', () => setActiveTool('image'));
    undoBtn.addEventListener('click', undoLast);
    clearBtn.addEventListener('click', clearOverlays);
    savePageBtn.addEventListener('click', saveCurrentPageEdits);

    prevPage.addEventListener('click', () => { if (!pdfDoc) return; if (currentPageIndex > 0) { currentPageIndex--; switchToPage(currentPageIndex); } });
    nextPage.addEventListener('click', () => { if (!pdfDoc) return; if (currentPageIndex < pdfDoc.numPages - 1) { currentPageIndex++; switchToPage(currentPageIndex); } });

    stampInput.addEventListener('change', async (e) => {
      const f = e.target.files && e.target.files[0];
      if (!f) return;
      stampImageBlob = f;
      setStatus('Stamp image loaded. Use Image tool to place it on page.');
    });

    resetAll.addEventListener('click', () => {
      pdfDoc = null; pdfArrayBuffer = null; pagesMeta = []; pageImagesCache = {}; currentPageIndex = 0;
      thumbs.innerHTML = ''; pageWrap.style.display='none'; setStatus('Reset complete'); downloadEditedPdf.disabled = true; downloadCurrentPage.disabled = true;
    });

    downloadCurrentPage.addEventListener('click', async () => {
      if (!pdfDoc) return;
      const blob = await exportSinglePageBlob(currentPageIndex);
      downloadBlob(blob, `page-${currentPageIndex+1}.pdf`);
    });

    downloadEditedPdf.addEventListener('click', async () => {
      if (!pdfDoc) return;
      setStatus('Preparing edited PDF — please wait...');
      downloadEditedPdf.disabled = true;
      try {
        const mergedBlob = await buildEditedPdf();
        downloadBlob(mergedBlob, `edited_${new Date().toISOString().slice(0,19).replace(/[:T]/g,'-')}.pdf`);
        setStatus('Edited PDF ready.');
      } catch (err) {
        console.error(err);
        setStatus('Failed to build edited PDF.');
      } finally {
        downloadEditedPdf.disabled = false;
      }
    });

    // utility downloads
    function downloadBlob(blob, filename) {
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = filename; document.body.appendChild(a); a.click();
      setTimeout(()=>{ URL.revokeObjectURL(url); try{ document.body.removeChild(a);}catch(e){} }, 500);
    }

    function dataURLToUint8Array(dataURL) {
      const arr = dataURL.split(',');
      const bstr = atob(arr[1]);
      let n = bstr.length;
      const u8 = new Uint8Array(n);
      while (n--) u8[n] = bstr.charCodeAt(n);
      return u8;
    }

    // Main: handle PDF file robustly
    async function handlePdfFile(file) {
      if (!file) { setStatus('No file provided'); return; }
      if (!file.type || (!file.type.includes('pdf') && !/\.pdf$/i.test(file.name))) {
        setStatus('Selected file is not a PDF');
        return;
      }
      setStatus('Loading PDF — please wait...');
      try {
        const ab = await file.arrayBuffer();
        pdfArrayBuffer = ab;
        // load pdf.js document
        const loadingTask = pdfjsLib.getDocument({ data: ab });
        const loadedDoc = await loadingTask.promise;
        pdfDoc = loadedDoc;
        // init pages meta
        pagesMeta = [];
        for (let i=0;i<pdfDoc.numPages;i++){
          pagesMeta.push({ width:0, height:0, viewport:null, edits: { drawStrokes:[], textBoxes:[], images:[] }, edited:false });
        }
        // render thumbnails (lightweight)
        thumbs.innerHTML = '';
        for (let i=0;i<pdfDoc.numPages;i++){
          try {
            const page = await pdfDoc.getPage(i+1);
            const viewport = page.getViewport({ scale: 0.22 });
            const canvas = document.createElement('canvas');
            canvas.width = Math.floor(viewport.width);
            canvas.height = Math.floor(viewport.height);
            const ctx = canvas.getContext('2d');
            await page.render({ canvasContext: ctx, viewport }).promise;
            const thumb = document.createElement('div'); thumb.className='thumb'; thumb.dataset.index = i;
            const img = document.createElement('img'); img.src = canvas.toDataURL('image/png'); img.style.width='60px'; img.style.height='80px'; img.style.objectFit='cover'; img.style.borderRadius='6px';
            const meta = document.createElement('div'); meta.style.flex='1';
            const title = document.createElement('div'); title.textContent = `Page ${i+1}`;
            const tmeta = document.createElement('div'); tmeta.className='tmeta'; tmeta.textContent = `${Math.round(viewport.width)} x ${Math.round(viewport.height)}`;
            meta.appendChild(title); meta.appendChild(tmeta);
            thumb.appendChild(img); thumb.appendChild(meta);
            thumb.addEventListener('click', () => { switchToPage(i); });
            thumbs.appendChild(thumb);
            page.cleanup?.();
          } catch (perr) {
            console.warn('Thumb render failed for page', i+1, perr);
          }
        }
        currentPageIndex = 0;
        await switchToPage(0);
        setStatus('PDF loaded. You can edit pages now.');
        downloadEditedPdf.disabled = false;
        downloadCurrentPage.disabled = false;
      } catch (err) {
        console.error('Failed to load PDF', err);
        setStatus('Failed to load PDF: ' + (err && err.message ? err.message : 'unknown error'));
      }
    }

    // Switch that page index and render base + overlay
    async function switchToPage(index) {
      if (!pdfDoc) return;
      currentPageIndex = index;
      Array.from(thumbs.children).forEach(ch => ch.classList.toggle('active', Number(ch.dataset.index) === index));
      pageWrap.style.display = 'block';
      pageWrap.innerHTML = '';
      try {
        const page = await pdfDoc.getPage(index+1);
        const viewport = page.getViewport({ scale });
        pagesMeta[index].width = viewport.width;
        pagesMeta[index].height = viewport.height;
        pagesMeta[index].viewport = viewport;

        baseCanvas = document.createElement('canvas');
        baseCanvas.className = 'baseCanvas';
        baseCanvas.width = Math.floor(viewport.width);
        baseCanvas.height = Math.floor(viewport.height);
        baseCanvas.style.maxWidth = '100%';
        baseCanvas.style.height = 'auto';
        const baseCtx = baseCanvas.getContext('2d');
        await page.render({ canvasContext: baseCtx, viewport }).promise;

        overlayCanvas = document.createElement('canvas');
        overlayCanvas.className = 'overlayCanvas';
        overlayCanvas.width = baseCanvas.width;
        overlayCanvas.height = baseCanvas.height;
        overlayCanvas.style.left = baseCanvas.offsetLeft + 'px';
        overlayCanvas.style.top = baseCanvas.offsetTop + 'px';
        overlayCanvas.style.width = baseCanvas.style.width;
        overlayCanvas.style.height = baseCanvas.style.height;
        overlayCanvas.style.pointerEvents = 'auto';
        overlayCtx = overlayCanvas.getContext('2d');
        overlayCtx.clearRect(0,0,overlayCanvas.width, overlayCanvas.height);

        pageWrap.appendChild(baseCanvas);
        pageWrap.appendChild(overlayCanvas);

        // render saved edits if present
        renderEditsForPage(index);

        attachOverlayEvents();
        pageCountLabel.textContent = `Page ${currentPageIndex+1} / ${pdfDoc.numPages}`;
        updateItemsList();
      } catch (err) {
        console.error('render page failed', err);
        setStatus('Failed to render page: ' + (err && err.message ? err.message : 'unknown'));
      }
    }

    function attachOverlayEvents() {
      // replace existing to avoid duplicate listeners
      const newOverlay = overlayCanvas.cloneNode(true);
      overlayCanvas.parentNode.replaceChild(newOverlay, overlayCanvas);
      overlayCanvas = newOverlay;
      overlayCtx = overlayCanvas.getContext('2d');
      overlayCanvas.addEventListener('pointerdown', startPointer);
      overlayCanvas.addEventListener('pointermove', movePointer);
      overlayCanvas.addEventListener('pointerup', endPointer);
      overlayCanvas.addEventListener('pointercancel', endPointer);
      overlayCanvas.addEventListener('pointerleave', endPointer);
      overlayCanvas.addEventListener('dblclick', (e) => {
        if (activeTool !== 'text') return;
        const rect = overlayCanvas.getBoundingClientRect();
        const x = Math.round((e.clientX - rect.left) * (overlayCanvas.width / rect.width));
        const y = Math.round((e.clientY - rect.top) * (overlayCanvas.height / rect.height));
        createTextBoxAt(x, y);
      });
    }

    function startPointer(e) {
      if (activeTool === 'draw') {
        drawing = true;
        currentStroke = { color: toolColor.value, size: Number(toolSize.value), path: [] };
        const pt = toLocalPoint(e);
        currentStroke.path.push(pt);
        drawStrokeOnCanvas(currentStroke);
      } else if (activeTool === 'image') {
        if (!stampImageBlob) { setStatus('Upload stamp image first from right panel'); return; }
        (async () => {
          const dataUrl = await fileToDataUrl(stampImageBlob);
          const rect = overlayCanvas.getBoundingClientRect();
          const x = Math.round((e.clientX - rect.left) * (overlayCanvas.width / rect.width));
          const y = Math.round((e.clientY - rect.top) * (overlayCanvas.height / rect.height));
          createImageOnPage(dataUrl, x, y);
        })();
      }
    }

    function movePointer(e) {
      if (!drawing || !currentStroke) return;
      const pt = toLocalPoint(e);
      currentStroke.path.push(pt);
      drawStrokeOnCanvas(currentStroke);
    }

    function endPointer(e) {
      if (drawing && currentStroke) {
        pagesMeta[currentPageIndex].edits.drawStrokes.push(currentStroke);
        pagesMeta[currentPageIndex].edited = true;
        currentStroke = null;
        drawing = false;
        updateItemsList();
      }
    }

    function toLocalPoint(e) {
      const rect = overlayCanvas.getBoundingClientRect();
      const x = Math.round((e.clientX - rect.left) * (overlayCanvas.width / rect.width));
      const y = Math.round((e.clientY - rect.top) * (overlayCanvas.height / rect.height));
      return { x, y };
    }

    function drawStrokeOnCanvas(stroke) {
      overlayCtx.lineJoin = 'round';
      overlayCtx.lineCap = 'round';
      overlayCtx.strokeStyle = stroke.color;
      overlayCtx.lineWidth = stroke.size;
      overlayCtx.beginPath();
      const pts = stroke.path;
      if (!pts || !pts.length) return;
      overlayCtx.moveTo(pts[0].x, pts[0].y);
      for (let i=1;i<pts.length;i++){
        overlayCtx.lineTo(pts[i].x, pts[i].y);
      }
      overlayCtx.stroke();
    }

    function renderEditsForPage(pageIndex) {
      overlayCtx.clearRect(0,0,overlayCanvas.width, overlayCanvas.height);
      const meta = pagesMeta[pageIndex];
      if (!meta) return;
      (meta.edits.drawStrokes || []).forEach(stroke => {
        overlayCtx.lineJoin = 'round';
        overlayCtx.lineCap = 'round';
        overlayCtx.strokeStyle = stroke.color;
        overlayCtx.lineWidth = stroke.size;
        overlayCtx.beginPath();
        const pts = stroke.path;
        if (!pts || !pts.length) return;
        overlayCtx.moveTo(pts[0].x, pts[0].y);
        for (let i=1;i<pts.length;i++) overlayCtx.lineTo(pts[i].x, pts[i].y);
        overlayCtx.stroke();
      });
      // Remove any existing DOM text/image nodes
      Array.from(pageWrap.querySelectorAll('.text-box, .placed-image')).forEach(n => n.remove());
      (meta.edits.textBoxes || []).forEach(tb => createTextBoxFromMeta(tb));
      (meta.edits.images || []).forEach(im => createImageElementFromMeta(im));
    }

    // Text boxes
    function createTextBoxAt(x, y) {
      const tb = { html: 'Text', x, y, w: 160, h: 40, fontSize: 16, color: '#00131f' };
      pagesMeta[currentPageIndex].edits.textBoxes.push(tb);
      pagesMeta[currentPageIndex].edited = true;
      createTextBoxFromMeta(tb, true);
      updateItemsList();
    }

    function createTextBoxFromMeta(tb, focus=false) {
      const el = document.createElement('div');
      el.className = 'text-box';
      el.contentEditable = 'true';
      el.innerText = tb.html;
      // position relative to pageWrap size
      const parentW = overlayCanvas.width, parentH = overlayCanvas.height;
      const wrapRect = pageWrap.getBoundingClientRect();
      el.style.left = (10 + (tb.x * (wrapRect.width - 20) / parentW)) + 'px';
      el.style.top = (10 + (tb.y * (wrapRect.height - 20) / parentH)) + 'px';
      el.style.width = (tb.w * (wrapRect.width - 20) / parentW) + 'px';
      el.style.height = (tb.h * (wrapRect.height - 20) / parentH) + 'px';
      el.style.fontSize = (tb.fontSize * (wrapRect.width - 20) / parentW) + 'px';
      el.style.color = tb.color;
      el.style.zIndex = 20;
      makeDraggable(el, (left, top, width, height) => {
        const relX = Math.round(((left - 10) * overlayCanvas.width) / (wrapRect.width - 20));
        const relY = Math.round(((top - 10) * overlayCanvas.height) / (wrapRect.height - 20));
        const relW = Math.round((width * overlayCanvas.width) / (wrapRect.width - 20));
        const relH = Math.round((height * overlayCanvas.height) / (wrapRect.height - 20));
        tb.x = relX; tb.y = relY; tb.w = relW; tb.h = relH; pagesMeta[currentPageIndex].edited = true; updateItemsList();
      });
      el.addEventListener('blur', () => { tb.html = el.innerText; });
      pageWrap.appendChild(el);
      if (focus) {
        el.focus();
        document.execCommand('selectAll', false, null);
        document.getSelection().collapseToEnd();
      }
    }

    // Make draggable (simple)
    function makeDraggable(el, onUpdate) {
      let dragging = false, startX=0, startY=0, origLeft=0, origTop=0;
      el.addEventListener('pointerdown', (e) => {
        dragging = true; startX = e.clientX; startY = e.clientY;
        const rect = el.getBoundingClientRect(); const parentRect = pageWrap.getBoundingClientRect();
        origLeft = rect.left - parentRect.left; origTop = rect.top - parentRect.top;
        el.setPointerCapture(e.pointerId);
      });
      window.addEventListener('pointermove', (e) => {
        if (!dragging) return;
        const dx = e.clientX - startX; const dy = e.clientY - startY;
        const newLeft = Math.max(0, origLeft + dx); const newTop = Math.max(0, origTop + dy);
        el.style.left = (10 + newLeft) + 'px'; el.style.top = (10 + newTop) + 'px';
      });
      window.addEventListener('pointerup', (e) => {
        if (dragging) {
          dragging = false;
          const rect = el.getBoundingClientRect(); const parentRect = pageWrap.getBoundingClientRect();
          const left = rect.left - parentRect.left; const top = rect.top - parentRect.top;
          const width = rect.width; const height = rect.height;
          onUpdate(left, top, width, height);
        }
      });
    }

    // Images
    function createImageOnPage(dataUrl, x, y) {
      const imgMeta = { dataUrl, x, y, w: 160, h: 120 };
      pagesMeta[currentPageIndex].edits.images.push(imgMeta);
      pagesMeta[currentPageIndex].edited = true;
      createImageElementFromMeta(imgMeta);
      updateItemsList();
    }

    function createImageElementFromMeta(imgMeta) {
      const el = document.createElement('img');
      el.className = 'placed-image';
      el.src = imgMeta.dataUrl;
      el.style.position = 'absolute';
      const wrapRect = pageWrap.getBoundingClientRect();
      el.style.left = (10 + (imgMeta.x * (wrapRect.width - 20) / overlayCanvas.width)) + 'px';
      el.style.top = (10 + (imgMeta.y * (wrapRect.height - 20) / overlayCanvas.height)) + 'px';
      el.style.width = (imgMeta.w * (wrapRect.width - 20) / overlayCanvas.width) + 'px';
      el.style.height = (imgMeta.h * (wrapRect.height - 20) / overlayCanvas.height) + 'px';
      el.style.zIndex = 30;
      makeDraggable(el, (left, top, width, height) => {
        imgMeta.x = Math.round(((left - 10) * overlayCanvas.width) / (wrapRect.width - 20));
        imgMeta.y = Math.round(((top - 10) * overlayCanvas.height) / (wrapRect.height - 20));
        imgMeta.w = Math.round((width * overlayCanvas.width) / (wrapRect.width - 20));
        imgMeta.h = Math.round((height * overlayCanvas.height) / (wrapRect.height - 20));
        pagesMeta[currentPageIndex].edited = true;
        updateItemsList();
      });
      pageWrap.appendChild(el);
    }

    function undoLast() {
      const meta = pagesMeta[currentPageIndex];
      if (!meta) return;
      if ((meta.edits.drawStrokes || []).length) { meta.edits.drawStrokes.pop(); meta.edited = true; renderEditsForPage(currentPageIndex); updateItemsList(); return; }
      if ((meta.edits.images || []).length) { meta.edits.images.pop(); meta.edited = true; renderEditsForPage(currentPageIndex); updateItemsList(); return; }
      if ((meta.edits.textBoxes || []).length) { meta.edits.textBoxes.pop(); meta.edited = true; renderEditsForPage(currentPageIndex); updateItemsList(); return; }
      setStatus('Nothing to undo on this page');
    }

    function clearOverlays() {
      const meta = pagesMeta[currentPageIndex];
      if (!meta) return;
      meta.edits = { drawStrokes: [], textBoxes: [], images: [] };
      meta.edited = true;
      renderEditsForPage(currentPageIndex);
      updateItemsList();
    }

    async function saveCurrentPageEdits() {
      setStatus('Flattening page edits — please wait...');
      try {
        const tmp = document.createElement('canvas');
        tmp.width = baseCanvas.width; tmp.height = baseCanvas.height;
        const ctx = tmp.getContext('2d');
        ctx.drawImage(baseCanvas, 0, 0, tmp.width, tmp.height);
        const meta = pagesMeta[currentPageIndex];
        (meta.edits.drawStrokes || []).forEach(stroke => {
          ctx.lineJoin = 'round'; ctx.lineCap = 'round'; ctx.strokeStyle = stroke.color; ctx.lineWidth = stroke.size; ctx.beginPath();
          const pts = stroke.path; if (!pts || !pts.length) return;
          ctx.moveTo(pts[0].x, pts[0].y);
          for (let i=1;i<pts.length;i++) ctx.lineTo(pts[i].x, pts[i].y);
          ctx.stroke();
        });
        for (const im of (meta.edits.images || [])) {
          const img = await loadImage(im.dataUrl);
          ctx.drawImage(img, im.x, im.y, im.w, im.h);
        }
        ctx.fillStyle = '#ffffff';
        ctx.textBaseline = 'top';
        for (const tb of (meta.edits.textBoxes || [])) {
          ctx.fillStyle = 'rgba(255,255,255,0.95)';
          ctx.fillRect(tb.x, tb.y, tb.w, tb.h);
          ctx.fillStyle = tb.color || '#00131f';
          const fontSize = tb.fontSize || 16; ctx.font = `${fontSize}px sans-serif`;
          const lines = (tb.html || '').split('\n'); let y = tb.y + 4;
          for (const line of lines) { ctx.fillText(line, tb.x + 6, y); y += fontSize + 2; }
        }
        const dataUrl = tmp.toDataURL('image/png');
        pageImagesCache[currentPageIndex] = dataUrl;
        pagesMeta[currentPageIndex].edited = true;
        setStatus('Page flattened and cached.');
      } catch (err) { console.error('flatten failed', err); setStatus('Flatten failed for page'); }
    }

    function loadImage(src) {
      return new Promise((resolve, reject) => { const i = new Image(); i.onload = () => resolve(i); i.onerror = reject; i.src = src; });
    }

    async function exportSinglePageBlob(pageIndex) {
      if (!pdfDoc) throw new Error('No PDF loaded');
      try {
        const { PDFDocument } = PDFLib;
        const srcPdf = await PDFDocument.load(pdfArrayBuffer, { ignoreEncryption: true });
        if (!pagesMeta[pageIndex].edited || !pageImagesCache[pageIndex]) {
          const newPdf = await PDFDocument.create();
          const [copied] = await newPdf.copyPages(srcPdf, [pageIndex]);
          newPdf.addPage(copied);
          const bytes = await newPdf.save();
          return new Blob([bytes], { type: 'application/pdf' });
        } else {
          const imgDataUrl = pageImagesCache[pageIndex];
          const imgBytes = dataURLToUint8Array(imgDataUrl);
          const newPdf = await PDFDocument.create();
          const img = await newPdf.embedPng(imgBytes);
          const width = pagesMeta[pageIndex].width;
          const height = pagesMeta[pageIndex].height;
          const page = newPdf.addPage([width, height]);
          page.drawImage(img, { x: 0, y: 0, width, height });
          const bytes = await newPdf.save();
          return new Blob([bytes], { type: 'application/pdf' });
        }
      } catch (err) { console.error('exportSinglePageBlob failed', err); throw err; }
    }

    async function buildEditedPdf() {
      const { PDFDocument } = PDFLib;
      const srcPdf = await PDFDocument.load(pdfArrayBuffer, { ignoreEncryption: true });
      const mergedPdf = await PDFDocument.create();
      for (let i=0;i<srcPdf.getPageCount();i++){
        if (pagesMeta[i] && pagesMeta[i].edited && pageImagesCache[i]) {
          const imgBytes = dataURLToUint8Array(pageImagesCache[i]);
          const imgEmbed = await mergedPdf.embedPng(imgBytes);
          const width = pagesMeta[i].width; const height = pagesMeta[i].height;
          const page = mergedPdf.addPage([width, height]);
          page.drawImage(imgEmbed, { x: 0, y: 0, width, height });
        } else {
          const [copied] = await mergedPdf.copyPages(srcPdf, [i]);
          mergedPdf.addPage(copied);
        }
      }
      const bytes = await mergedPdf.save();
      return new Blob([bytes], { type: 'application/pdf' });
    }

    function updateItemsList() {
      itemsList.innerHTML = '';
      const meta = pagesMeta[currentPageIndex];
      if (!meta) return;
      const strokes = (meta.edits.drawStrokes || []).length;
      const texts = (meta.edits.textBoxes || []).length;
      const imgs = (meta.edits.images || []).length;
      const edited = meta.edited ? 'Yes' : 'No';
      const makeRow = (label, val) => {
        const r = document.createElement('div'); r.style.display='flex'; r.style.justifyContent='space-between'; r.style.alignItems='center';
        const l = document.createElement('div'); l.textContent = label; l.style.color='var(--muted)';
        const v = document.createElement('div'); v.textContent = val; v.style.fontWeight='700';
        r.appendChild(l); r.appendChild(v); return r;
      };
      itemsList.appendChild(makeRow('Draw strokes', strokes));
      itemsList.appendChild(makeRow('Text boxes', texts));
      itemsList.appendChild(makeRow('Images', imgs));
      itemsList.appendChild(makeRow('Edited?', edited));
    }

    function fileToDataUrl(file) {
      return new Promise((resolve, reject) => {
        const r = new FileReader();
        r.onload = e => resolve(e.target.result);
        r.onerror = reject;
        r.readAsDataURL(file);
      });
    }

    // initial
    setStatus('Ready');
    setActiveTool('select');

    // Expose debug state
    window._editor_state = () => ({ pagesMeta, pageImagesCache, currentPageIndex, pdfLoaded: !!pdfDoc });

    // helper: setActiveTool defined here to avoid hoisting issues
    function setActiveTool(tool) {
      activeTool = tool;
      [selectTool, drawTool, textTool, imageTool].forEach(btn => btn.classList.remove('btn-primary'));
      if (tool === 'select') selectTool.classList.add('btn-primary');
      if (tool === 'draw') drawTool.classList.add('btn-primary');
      if (tool === 'text') textTool.classList.add('btn-primary');
      if (tool === 'image') imageTool.classList.add('btn-primary');
      setStatus(`Tool: ${tool}`);
    }
  </script>
</body>
</html>
