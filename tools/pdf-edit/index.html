<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>PDF Edit Tool - Smarttool Hub</title>
  <meta name="description" content="Edit PDF pages (reorder, rotate, delete) in your browser. No server uploads."/>
  <link rel="icon" href="https://img.icons8.com/fluency/48/toolbox.png"/>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css"/>
  <style>
    /* Theme variables (same as watermark tool) */
    :root{
      --bg:#0b1220;
      --text:#eaf2ff;
      --card:#182335;
      --border:#2a3b55;
      --primary:#22d3ee;
      --muted:#9fb3c8;
      --accent:#7ee7ff;
      --radius:12px;
      --input-bg: #09111a;
    }
    body.light{
      --bg:#f6f8fb;
      --text:#0b1220;
      --card:#ffffff;
      --border:#e6eefc;
      --primary:#0b74ff;
      --muted:#556677;
      --accent:#7aa8ff;
      --input-bg: #ffffff;
    }

    *{box-sizing:border-box;margin:0;padding:0}
    html,body{height:100%}
    body{
      font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial;
      background:var(--bg);color:var(--text);min-height:100vh;display:flex;flex-direction:column;-webkit-font-smoothing:antialiased;
    }
    a{color:var(--primary)}
    .container{max-width:1200px;margin:0 auto;padding:20px;width:100%}

    header{
      display:flex;align-items:center;justify-content:space-between;gap:12px;background:var(--card);border-bottom:1px solid var(--border);padding:14px 20px;
    }
    .brand{display:flex;gap:12px;align-items:center}
    .brand img{width:46px;height:46px;border-radius:10px}
    .brand .title{font-size:1.25rem;font-weight:700;color:var(--primary);margin:0}
    .brand .tag{font-size:.9rem;color:var(--muted)}
    .header-actions{display:flex;gap:10px;align-items:center}
    .btn-header{border:1px solid var(--border);background:transparent;padding:8px 12px;border-radius:8px;color:var(--text);cursor:pointer;display:flex;align-items:center;gap:6px;text-decoration:none;font-weight:600}

    /* Card */
    .tool-content{background:var(--card);border-radius:var(--radius);border:1px solid var(--border);padding:25px;margin-top:20px;}
    .tool-title{ font-size:2rem; margin-bottom:8px; color:var(--text); font-weight:800; }
    .tool-description{ color:var(--muted); margin-bottom:18px; font-size:1rem; }

    /* Upload area */
    .upload-area{border:2px dashed var(--border);border-radius:var(--radius);padding:48px 28px;text-align:center;margin-bottom:20px;background:var(--bg);color:var(--muted)}
    .upload-area.dragover{border-color:var(--primary);background:rgba(34,211,238,0.03)}
    .upload-icon{font-size:56px;color:var(--muted);margin-bottom:12px}
    .upload-text{color:var(--text);font-weight:700;margin-bottom:6px}
    .upload-subtext{color:var(--muted)}

    .selected-file{display:flex;align-items:center;gap:12px;padding:12px;background:var(--input-bg);border-radius:10px;border:1px solid var(--border);margin-bottom:18px}
    .file-icon{font-size:18px;color:var(--primary)}
    .file-info{flex:1}
    .file-name{font-weight:700;color:var(--text)}
    .file-size{color:var(--muted);font-size:0.9rem}
    .remove-file{background:transparent;border:none;color:var(--muted);cursor:pointer}

    /* Controls + preview */
    .editor-layout{display:grid;grid-template-columns: 360px 1fr; gap:18px}
    @media (max-width:980px){ .editor-layout{grid-template-columns:1fr} }

    .panel{
      background:var(--input-bg); border:1px solid var(--border); border-radius:12px; padding:14px;
    }
    .panel h3{margin-bottom:8px;color:var(--text);font-size:1.05rem}
    .panel p{color:var(--muted);font-size:0.92rem;margin-bottom:12px}

    /* Thumbnails list */
    .thumb-list{ display:flex; flex-direction:column; gap:10px; max-height:560px; overflow:auto; padding-right:6px }
    .thumb-item{
      display:flex; gap:10px; align-items:center; padding:8px; border-radius:10px; border:1px solid var(--border); background:var(--card);
    }
    .thumb-preview{ width:86px; height:110px; background:#fff;border-radius:6px; display:flex; align-items:center; justify-content:center; overflow:hidden; }
    .thumb-preview canvas{ width:100%; height:auto; display:block; }
    .thumb-meta{ flex:1 }
    .thumb-meta .label{ font-weight:700; color:var(--text); margin-bottom:6px; font-size:0.95rem }
    .thumb-meta .actions{ display:flex; gap:6px; flex-wrap:wrap }
    .small-btn{ padding:6px 8px; border-radius:8px; border:1px solid var(--border); background:transparent; color:var(--text); cursor:pointer; font-weight:700 }

    .thumb-order{ display:flex; gap:6px; align-items:center }

    /* Preview area */
    .preview-area{ border:1px solid var(--border); border-radius:var(--radius); padding:12px; background:var(--bg); min-height:300px; overflow:auto }
    .preview-grid{ display:flex; gap:12px; flex-wrap:wrap; align-items:flex-start; padding:6px }

    .preview-card{ background:var(--card); border-radius:10px; padding:8px; border:1px solid var(--border); min-width:200px; display:flex; flex-direction:column; gap:8px; align-items:center; }
    .preview-card canvas{ background:#fff; border-radius:6px; display:block; max-width:100% }

    /* action area */
    .action-buttons{ display:flex; gap:12px; flex-wrap:wrap; margin-top:12px; align-items:center }
    .btn{ padding:10px 14px; border-radius:10px; border:none; font-weight:700; cursor:pointer; display:inline-flex; align-items:center; gap:8px }
    .btn-primary{ background:linear-gradient(90deg,var(--primary),var(--accent)); color:#00131f }
    .btn-secondary{ background:var(--input-bg); color:var(--text); border:1px solid var(--border) }

    .status-message{ margin-top:8px; padding:10px; border-radius:10px; background:transparent; border:1px solid var(--border); color:var(--muted); display:none }
    .status-success{ border-color:#10b981; color:#10b981 }
    .status-error{ border-color:#ef4444; color:#ef4444 }

    .progress{ width:100%; height:12px; background:rgba(255,255,255,0.03); border-radius:8px; overflow:hidden; margin-top:8px; border:1px solid var(--border) }
    .progress-bar{ height:100%; width:0%; background:linear-gradient(90deg,var(--primary),var(--accent)); transition:width .25s }

    footer{ margin-top:auto; padding:18px 0; background:var(--card); border-top:1px solid var(--border) }
    .footer-inner{ display:flex; align-items:center; justify-content:space-between; gap:12px; flex-wrap:wrap }
    .footer-inner div{ color:var(--muted) }
    .footer-links{ display:flex; gap:14px; flex-wrap:wrap }
    .footer-links a{ color:var(--primary); font-weight:700 }

    @media (max-width:720px){
      header{ flex-direction:column; align-items:flex-start; gap:8px }
    }
  </style>
</head>
<body>
<header class="container">
  <div class="brand">
    <a href="index.html" style="display:flex;align-items:center;gap:12px;text-decoration:none;">
      <img src="https://img.icons8.com/fluency/48/toolbox.png" alt="Smarttool Hub Logo">
      <div>
        <div class="title">Smarttool Hub</div>
        <div class="tag">Fast • Private • 100% Client-side</div>
      </div>
    </a>
  </div>
  <div class="header-actions">
    <a href="index.html" class="btn-header"><i class="fa-solid fa-house"></i> Home</a>
    <button class="btn-header" id="themeToggle" title="Toggle dark/light mode"><i class="fa-solid fa-moon"></i></button>
  </div>
</header>

<main class="container">
  <div class="tool-content">
    <h1 class="tool-title">PDF Edit Tool</h1>
    <p class="tool-description">Edit PDF pages in your browser — reorder, rotate, delete, then download the updated PDF. No files leave your device.</p>

    <div class="upload-area" id="uploadArea">
      <div class="upload-icon"><i class="fas fa-file-pdf"></i></div>
      <div class="upload-text">Drop your PDF file here or click to browse</div>
      <div class="upload-subtext">Maximum file size: 100MB</div>
      <input type="file" id="fileInput" class="file-input" accept=".pdf">
    </div>

    <div id="selectedFileContainer" style="display:none;" class="selected-file">
      <div class="file-icon"><i class="fas fa-file-pdf"></i></div>
      <div class="file-info">
        <div class="file-name" id="fileName"></div>
        <div class="file-size" id="fileSize"></div>
      </div>
      <button class="remove-file" id="removeFile" title="Remove file"><i class="fas fa-times"></i></button>
    </div>

    <div class="editor-layout" style="margin-top:12px;">
      <!-- left panel: page thumbnails & controls -->
      <div class="panel">
        <h3>Pages</h3>
        <p>Manage pages: rotate, move or delete. Click a thumbnail to open a larger preview.</p>
        <div class="thumb-list" id="thumbList" aria-live="polite"></div>

        <div class="action-buttons" style="margin-top:12px;">
          <button class="btn btn-primary" id="downloadBtn" disabled><i class="fas fa-download"></i> Download Edited PDF</button>
          <button class="btn btn-secondary" id="resetBtn"><i class="fas fa-redo"></i> Reset</button>
        </div>

        <div id="progressWrap" style="display:none;margin-top:12px;">
          <div style="display:flex;justify-content:space-between;align-items:center;">
            <div style="font-size:0.95rem;color:var(--muted)">Processing: <span id="progressText">0%</span></div>
            <div style="font-size:0.9rem;color:var(--muted)"><span id="progressStage">Idle</span></div>
          </div>
          <div class="progress"><div class="progress-bar" id="progressBar"></div></div>
        </div>

        <div id="statusMessage" class="status-message" style="margin-top:12px;"></div>
      </div>

      <!-- right panel: page preview large -->
      <div class="panel preview-area">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px;">
          <div style="font-weight:700;color:var(--muted)">Preview</div>
          <div style="font-size:0.92rem;color:var(--muted)">Click a thumbnail to open full-size</div>
        </div>
        <div class="preview-grid" id="previewGrid"></div>
      </div>
    </div>

  </div>
</main>

<footer class="container">
  <div class="footer-inner">
    <div>© <span id="year"></span> Smarttool Hub</div>
    <div class="footer-links">
      <a href="privacy.html">Privacy</a>
      <a href="terms.html">Terms</a>
      <a href="contact.html">Contact</a>
      <a href="comments.html">Comments</a>
      <a href="faq.html">FAQ</a>
    </div>
  </div>
</footer>

<script>
  document.getElementById('year').textContent = new Date().getFullYear();
</script>

<script>
/* Multi-CDN loader for pdf.js and jsPDF (same robust pattern used previously) */
(async function loader() {
  const pdfJsCDNs = [
    'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js',
    'https://cdn.jsdelivr.net/npm/pdfjs-dist@2.16.105/build/pdf.min.js',
    'https://unpkg.com/pdfjs-dist@2.16.105/build/pdf.min.js'
  ];
  const pdfWorkerCDNs = [
    'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js',
    'https://cdn.jsdelivr.net/npm/pdfjs-dist@2.16.105/build/pdf.worker.min.js',
    'https://unpkg.com/pdfjs-dist@2.16.105/build/pdf.worker.min.js'
  ];
  const jsPdfCDNs = [
    'https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js',
    'https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js',
    'https://unpkg.com/jspdf@2.5.1/dist/jspdf.umd.min.js'
  ];

  async function tryLoad(urls, globalName, timeout=9000) {
    for (const url of urls) {
      try {
        await loadScriptWithTimeout(url, timeout);
        await new Promise(r=>setTimeout(r,50));
        if (!globalName || window[globalName] || (globalName==='pdfjsLib' && window.pdfjsLib) || (globalName==='jspdf' && window.jspdf)) return true;
      } catch(e) {
        console.warn('Failed to load', url, e);
      }
    }
    return false;
  }
  function loadScriptWithTimeout(src, timeoutMs) {
    return new Promise((resolve,reject) => {
      const s = document.createElement('script');
      let done = false;
      const t = setTimeout(()=>{ if(!done){ done=true; s.onerror=s.onload=null; if(s.parentNode) s.parentNode.removeChild(s); reject(new Error('Timeout ' + src)); }}, timeoutMs);
      s.onload = ()=>{ if(!done){ done=true; clearTimeout(t); resolve(); } };
      s.onerror = (e)=>{ if(!done){ done=true; clearTimeout(t); reject(e); } };
      s.src = src; s.async = true; document.head.appendChild(s);
    });
  }

  const pdfOk = await tryLoad(pdfJsCDNs, 'pdfjsLib', 9000);
  if (pdfOk && window.pdfjsLib) pdfjsLib.GlobalWorkerOptions.workerSrc = pdfWorkerCDNs[0];
  const jsOk = await tryLoad(jsPdfCDNs, 'jspdf', 9000);

  if (!pdfOk && !jsOk) {
    alert('Required libraries (pdf.js and jsPDF) failed to load from CDNs. See help box on the page for options.');
    const libHelp = document.getElementById('statusMessage');
    libHelp.style.display = 'block';
    libHelp.className = 'status-message';
    libHelp.innerHTML = '<strong>Libraries failed to load.</strong><br>Allowlist CDN domains (cdnjs.cloudflare.com, cdn.jsdelivr.net, unpkg.com) or host <code>pdf.min.js</code>, <code>pdf.worker.min.js</code>, and <code>jspdf.umd.min.js</code> locally.';
  }

  startApp({ pdfAvailable: pdfOk && !!window.pdfjsLib, jsAvailable: jsOk && !!window.jspdf });
})();

/* Main app */
function startApp(env = { pdfAvailable:true, jsAvailable:true }) {
  // DOM refs
  const uploadArea = document.getElementById('uploadArea');
  const fileInput = document.getElementById('fileInput');
  const selectedFileContainer = document.getElementById('selectedFileContainer');
  const fileNameEl = document.getElementById('fileName');
  const fileSizeEl = document.getElementById('fileSize');
  const removeFileBtn = document.getElementById('removeFile');
  const thumbList = document.getElementById('thumbList');
  const previewGrid = document.getElementById('previewGrid');
  const downloadBtn = document.getElementById('downloadBtn');
  const resetBtn = document.getElementById('resetBtn');
  const progressWrap = document.getElementById('progressWrap');
  const progressBar = document.getElementById('progressBar');
  const progressText = document.getElementById('progressText');
  const progressStage = document.getElementById('progressStage');
  const statusMessage = document.getElementById('statusMessage');
  const themeToggle = document.getElementById('themeToggle');

  if (localStorage.getItem('sth_theme') === 'light') { document.body.classList.add('light'); themeToggle.innerHTML = '<i class="fa-solid fa-sun"></i>'; }
  themeToggle.onclick = () => { document.body.classList.toggle('light'); if(document.body.classList.contains('light')){ themeToggle.innerHTML='<i class="fa-solid fa-sun"></i>'; localStorage.setItem('sth_theme','light'); } else { themeToggle.innerHTML='<i class="fa-solid fa-moon"></i>'; localStorage.removeItem('sth_theme'); } };

  let selectedFile = null;
  let pdfDoc = null;
  let pages = []; // page objects: { pageNum, rotation (deg), canvasThumb (canvas), viewport, renderedCanvasFull (canvas) }

  // listeners
  uploadArea.addEventListener('click', ()=>fileInput.click());
  uploadArea.addEventListener('dragover', e => { e.preventDefault(); uploadArea.classList.add('dragover'); });
  uploadArea.addEventListener('dragleave', e => { e.preventDefault(); uploadArea.classList.remove('dragover'); });
  uploadArea.addEventListener('drop', e => { e.preventDefault(); uploadArea.classList.remove('dragover'); const f = e.dataTransfer.files[0]; if (f && f.type==='application/pdf') handleFile(f); else showStatus('Please drop a PDF file','error'); });
  fileInput.addEventListener('change', e => { const f = e.target.files[0]; if (f && f.type==='application/pdf') handleFile(f); else if (f) showStatus('Please select a PDF file','error'); });
  removeFileBtn.addEventListener('click', resetAll);
  resetBtn.addEventListener('click', resetAll);
  downloadBtn.addEventListener('click', downloadEditedPdf);

  function showStatus(msg, type='info') {
    statusMessage.textContent = msg;
    statusMessage.style.display = 'block';
    statusMessage.className = 'status-message';
    if (type === 'success') statusMessage.classList.add('status-success');
    if (type === 'error') statusMessage.classList.add('status-error');
    if (type !== 'info') setTimeout(()=> statusMessage.style.display='none', 4500);
  }
  function setProgress(p){ progressBar.style.width = `${p}%`; progressText.textContent = `${Math.round(p)}%`; }

  async function handleFile(file) {
    resetUI();
    selectedFile = file;
    fileNameEl.textContent = file.name;
    fileSizeEl.textContent = formatFileSize(file.size);
    selectedFileContainer.style.display = 'flex';
    downloadBtn.disabled = false;
    showStatus('PDF selected', 'success');

    if (!env.pdfAvailable || !window.pdfjsLib) {
      showStatus('pdf.js not available — previews disabled. Cannot edit without pdf.js.', 'error');
      downloadBtn.disabled = true;
      return;
    }

    try {
      progressWrap.style.display = 'block';
      progressStage.textContent = 'Loading PDF';
      setProgress(5);
      const arrayBuffer = await file.arrayBuffer();
      setProgress(15);
      pdfDoc = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
      setProgress(30);
      await loadPagesToThumbnails(pdfDoc);
      setProgress(100);
      setTimeout(()=> progressWrap.style.display='none', 300);
    } catch (err) {
      console.error(err);
      showStatus('Error loading PDF: ' + (err.message || err), 'error');
      progressWrap.style.display = 'none';
    }
  }

  async function loadPagesToThumbnails(pdf) {
    pages = [];
    thumbList.innerHTML = '';
    previewGrid.innerHTML = '';
    const total = pdf.numPages;
    for (let p=1;p<=total;p++) {
      progressStage.textContent = `Rendering page ${p} / ${total}`;
      setProgress(30 + (p/total)*50);
      try {
        const page = await pdf.getPage(p);
        const viewport = page.getViewport({ scale: 1.0 });
        // create thumbnail canvas (small)
        const thumbScale = Math.min(160 / viewport.width, 110 / viewport.height);
        const thumbViewport = page.getViewport({ scale: thumbScale });
        const thumbCanvas = document.createElement('canvas');
        thumbCanvas.width = Math.round(thumbViewport.width);
        thumbCanvas.height = Math.round(thumbViewport.height);
        await page.render({ canvasContext: thumbCanvas.getContext('2d'), viewport: thumbViewport }).promise;

        // store page state (rotation degrees 0,90,180,270)
        const pg = { pageNum: p, rotation: 0, thumbCanvas, viewport, renderedCanvasFull: null };
        pages.push(pg);

        // create thumbnail element
        addThumbElement(pg);
      } catch (err) {
        console.error('Page render error', p, err);
      }
      await new Promise(r=>setTimeout(r,30));
    }
    setProgress(95);
    showPreviewGrid();
    setTimeout(()=> setProgress(100), 120);
  }

  function addThumbElement(pg) {
    const item = document.createElement('div');
    item.className = 'thumb-item';
    item.dataset.p = pg.pageNum;

    const previewWrap = document.createElement('div');
    previewWrap.className = 'thumb-preview';
    previewWrap.appendChild(pg.thumbCanvas);

    const meta = document.createElement('div');
    meta.className = 'thumb-meta';
    const label = document.createElement('div'); label.className = 'label'; label.textContent = `Page ${pg.pageNum}`;
    const actions = document.createElement('div'); actions.className = 'actions';

    const btnRotate = document.createElement('button'); btnRotate.className = 'small-btn'; btnRotate.title = 'Rotate 90° clockwise'; btnRotate.innerHTML = '<i class="fas fa-rotate-right"></i>';
    btnRotate.onclick = () => rotatePage(pg.pageNum);

    const btnDel = document.createElement('button'); btnDel.className = 'small-btn'; btnDel.title = 'Delete page'; btnDel.innerHTML = '<i class="fas fa-trash"></i>';
    btnDel.onclick = () => deletePage(pg.pageNum);

    const btnLeft = document.createElement('button'); btnLeft.className = 'small-btn'; btnLeft.title = 'Move left'; btnLeft.innerHTML = '<i class="fas fa-arrow-left"></i>';
    btnLeft.onclick = () => movePageLeft(pg.pageNum);

    const btnRight = document.createElement('button'); btnRight.className = 'small-btn'; btnRight.title = 'Move right'; btnRight.innerHTML = '<i class="fas fa-arrow-right"></i>';
    btnRight.onclick = () => movePageRight(pg.pageNum);

    actions.appendChild(btnLeft);
    actions.appendChild(btnRight);
    actions.appendChild(btnRotate);
    actions.appendChild(btnDel);

    meta.appendChild(label);
    meta.appendChild(actions);

    item.appendChild(previewWrap);
    item.appendChild(meta);

    // clicking thumbnail opens full preview of this page
    previewWrap.addEventListener('click', () => openFullPreview(pg.pageNum));

    thumbList.appendChild(item);
  }

  function showPreviewGrid() {
    previewGrid.innerHTML = '';
    for (const pg of pages) {
      const card = document.createElement('div');
      card.className = 'preview-card';
      const canvas = document.createElement('canvas');
      // use thumb canvas scaled up for preview OR render full-size later
      canvas.width = pg.thumbCanvas.width * 2;
      canvas.height = pg.thumbCanvas.height * 2;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(pg.thumbCanvas, 0, 0, canvas.width, canvas.height);
      card.appendChild(canvas);
      const lbl = document.createElement('div'); lbl.style.color='var(--muted)'; lbl.style.fontSize='0.9rem'; lbl.textContent = `Page ${pg.pageNum}`;
      card.appendChild(lbl);
      previewGrid.appendChild(card);
      // click to open full preview
      card.addEventListener('click', () => openFullPreview(pg.pageNum));
    }
  }

  async function openFullPreview(pageNum) {
    // find page state
    const pgIndex = pages.findIndex(p => p.pageNum === pageNum);
    if (pgIndex === -1) return;
    const state = pages[pgIndex];

    // If we already rendered a full-resolution canvas for this page and rotation hasn't changed, show it; otherwise render full
    if (state.renderedCanvasFull && state.renderedCanvasFull.rotation === state.rotation) {
      showPopupImage(state.renderedCanvasFull.canvas.toDataURL());
      return;
    }

    // render full page using pdf.js at higher scale
    try {
      progressWrap.style.display = 'block';
      progressStage.textContent = 'Rendering full page';
      setProgress(10);
      const page = await pdfDoc.getPage(state.pageNum);
      setProgress(30);
      const scale = 1.6; // scale for full preview
      const viewport = page.getViewport({ scale });
      const canvas = document.createElement('canvas');
      canvas.width = Math.round(viewport.width);
      canvas.height = Math.round(viewport.height);
      const ctx = canvas.getContext('2d');
      await page.render({ canvasContext: ctx, viewport }).promise;
      // apply rotation visually on canvas for preview
      if (state.rotation % 360 !== 0) {
        const rotated = rotateCanvasCanvas(canvas, state.rotation);
        state.renderedCanvasFull = { canvas: rotated, rotation: state.rotation };
        showPopupImage(rotated.toDataURL());
      } else {
        state.renderedCanvasFull = { canvas, rotation: state.rotation };
        showPopupImage(canvas.toDataURL());
      }
      setProgress(100);
      setTimeout(()=> progressWrap.style.display='none', 300);
    } catch (err) {
      console.error(err);
      showStatus('Error rendering full page: ' + (err.message || err),'error');
      progressWrap.style.display = 'none';
    }
  }

  function rotateCanvasCanvas(srcCanvas, degrees) {
    const d = ((degrees % 360) + 360) % 360;
    if (d === 0) return srcCanvas;
    const w = srcCanvas.width, h = srcCanvas.height;
    const out = document.createElement('canvas');
    if (d === 90 || d === 270) { out.width = h; out.height = w; } else { out.width = w; out.height = h; }
    const ctx = out.getContext('2d');
    ctx.translate(out.width/2, out.height/2);
    ctx.rotate(d * Math.PI / 180);
    ctx.drawImage(srcCanvas, -w/2, -h/2);
    return out;
  }

  function rotatePage(pageNum) {
    const idx = pages.findIndex(p => p.pageNum === pageNum);
    if (idx === -1) return;
    pages[idx].rotation = (pages[idx].rotation + 90) % 360;
    // update thumbnail visually by rotating its canvas copy
    const thumbCanvas = pages[idx].thumbCanvas;
    const rotated = rotateCanvasCanvas(thumbCanvas, 90);
    pages[idx].thumbCanvas = rotated;
    // update thumb DOM
    refreshThumbnailsUI();
    showPreviewGrid();
  }

  function deletePage(pageNum) {
    const idx = pages.findIndex(p => p.pageNum === pageNum);
    if (idx === -1) return;
    pages.splice(idx, 1);
    refreshNumbering();
    refreshThumbnailsUI();
    showPreviewGrid();
  }

  function movePageLeft(pageNum) {
    const idx = pages.findIndex(p => p.pageNum === pageNum);
    if (idx > 0) {
      const temp = pages[idx-1];
      pages[idx-1] = pages[idx];
      pages[idx] = temp;
      refreshNumbering();
      refreshThumbnailsUI();
      showPreviewGrid();
    }
  }

  function movePageRight(pageNum) {
    const idx = pages.findIndex(p => p.pageNum === pageNum);
    if (idx !== -1 && idx < pages.length - 1) {
      const temp = pages[idx+1];
      pages[idx+1] = pages[idx];
      pages[idx] = temp;
      refreshNumbering();
      refreshThumbnailsUI();
      showPreviewGrid();
    }
  }

  function refreshNumbering() {
    // reset pageNum to their position index+1 to preserve order for final PDF
    for (let i=0;i<pages.length;i++) pages[i].pageNum = i+1;
  }

  function refreshThumbnailsUI() {
    // clear and rebuild thumb list (keeps click handlers simple)
    thumbList.innerHTML = '';
    for (const pg of pages) addThumbElement(pg);
  }

  async function downloadEditedPdf() {
    if (!env.jsAvailable || !window.jspdf) { showStatus('jsPDF not available — cannot create final PDF.','error'); return; }
    if (!pages.length) { showStatus('No pages to save', 'error'); return; }

    try {
      progressWrap.style.display = 'block';
      progressStage.textContent = 'Rendering pages';
      setProgress(5);
      const { jsPDF } = window.jspdf;
      let doc = null;
      const total = pages.length;
      for (let i=0;i<total;i++) {
        const pg = pages[i];
        setProgress(5 + ((i+1)/total)*80);
        // render full page (if not cached) at scale for print quality
        let canvas = pg.renderedCanvasFull ? pg.renderedCanvasFull.canvas : null;
        if (!canvas) {
          const srcPage = await pdfDoc.getPage(pg.pageNum); // note: pageNum is now ordering index (but pdfDoc pages are original indices)
          // IMPORTANT: original pdfDoc.getPage expects original page number. We must map to original page numbers.
          // To preserve original mapping, when we reordered pages we updated pageNum; but pdfDoc pages are based on original order.
          // To handle this, store originalIndex in pages initial load. We'll revise: pages must have originalIndex property.
          // but we didn't store it earlier — fix: pages array initial load should include originalIndex; implement by checking for origIndex.
        }
      }
      // OOPS: we need original page mapping to request correct pages from pdfDoc.
      // To fix, rebuild pages to include originalIndex when pages were first loaded.
      // We'll re-implement: if pages[].originalIndex is missing, assume pageNum maps to original index at load time.
    } catch (err) {
      console.error(err);
      showStatus('Error creating PDF: ' + (err.message || err), 'error');
      progressWrap.style.display = 'none';
    }

    // Because of above mapping nuance we re-implement the download logic from scratch below (complete version).
    return downloadEditedPdf_v2();
  }

  // Updated, complete download builder handling original page mapping
  async function downloadEditedPdf_v2() {
    try {
      // Ensure pages have originalIndex property (set at load time). If not present, assume initial mapping: originalIndex==indexAtLoad
      if (!pages.length) { showStatus('No pages to save','error'); return; }
      // If originalIndex missing, construct from current order by assuming initial load order - but we must have saved originalIndex when loading.
      // We'll attempt to use stored originalIndex; otherwise best-effort: treat pageNum as original index.
      progressWrap.style.display = 'block';
      progressStage.textContent = 'Preparing final PDF';
      setProgress(5);
      const { jsPDF } = window.jspdf;
      let doc = null;
      const total = pages.length;
      for (let i=0;i<total;i++) {
        const pg = pages[i];
        progressStage.textContent = `Rendering page ${i+1} / ${total}`;
        // Render the page at scale 2.0 for decent quality if canvas not cached or rotation changed
        let canvas = null;
        if (pg.renderedCanvasFull && pg.renderedCanvasFull.rotation === pg.rotation) {
          canvas = pg.renderedCanvasFull.canvas;
        } else {
          // We need to fetch the original PDF page by its original index.
          const origIndex = (typeof pg.originalIndex === 'number') ? pg.originalIndex : pg.pageNum; // fallback
          const page = await pdfDoc.getPage(origIndex);
          const scale = 2.0;
          const viewport = page.getViewport({ scale });
          const c = document.createElement('canvas');
          c.width = Math.round(viewport.width);
          c.height = Math.round(viewport.height);
          await page.render({ canvasContext: c.getContext('2d'), viewport }).promise;
          // apply rotation
          if (pg.rotation % 360 !== 0) {
            const rotated = rotateCanvasCanvas(c, pg.rotation);
            canvas = rotated;
          } else {
            canvas = c;
          }
          pg.renderedCanvasFull = { canvas: canvas, rotation: pg.rotation };
        }

        const imgData = canvas.toDataURL('image/jpeg', 0.92);
        const orientation = (canvas.width > canvas.height) ? 'l' : 'p';
        const scaleForPdf = 96 * 2.0; // 96dpi assumption times render scale
        const pxToMm = (px) => (px * 25.4) / scaleForPdf;
        const wmm = pxToMm(canvas.width);
        const hmm = pxToMm(canvas.height);

        if (i === 0) {
          doc = new jsPDF({ unit: 'mm', format: [wmm, hmm], orientation });
          doc.addImage(imgData, 'JPEG', 0, 0, wmm, hmm);
        } else {
          doc.addPage([wmm, hmm], orientation);
          doc.addImage(imgData, 'JPEG', 0, 0, wmm, hmm);
        }
        setProgress(5 + ((i+1)/total)*85);
        await new Promise(r=>setTimeout(r,50));
      }
      progressStage.textContent = 'Finalizing';
      setProgress(95);
      doc.save(`edited-${selectedFile.name}`);
      setProgress(100);
      showStatus('Edited PDF downloaded', 'success');
      setTimeout(()=>{ progressWrap.style.display='none'; setProgress(0); }, 700);
    } catch (err) {
      console.error(err);
      showStatus('Error generating edited PDF: ' + (err.message || err),'error');
      progressWrap.style.display = 'none';
    }
  }

  // Reset UI & state
  function resetAll() {
    selectedFile = null;
    pdfDoc = null;
    pages = [];
    thumbList.innerHTML = '';
    previewGrid.innerHTML = '';
    selectedFileContainer.style.display = 'none';
    downloadBtn.disabled = true;
    fileInput.value = '';
    showStatus('Editor reset', 'success');
  }

  // Utility helpers
  function formatFileSize(bytes){ if(!bytes) return '0 Bytes'; const k=1024; const sizes=['Bytes','KB','MB','GB']; const i=Math.floor(Math.log(bytes)/Math.log(k)); return parseFloat((bytes/Math.pow(k,i)).toFixed(2)) + ' ' + sizes[i]; }

  // When first loading pages, store originalIndex property so we can reference original PDF pages later
  // Modify loadPagesToThumbnails to set originalIndex when creating pg object
  // But we already did above; fix by adjusting pages creation here:
  // To ensure pages have originalIndex, override loadPagesToThumbnails with a wrapper that sets originalIndex
  // However since loadPagesToThumbnails already pushed pg.pageNum=p, we need to update pages[].originalIndex
  // We'll attach originalIndex after load (if missing).
  // Do that now after loadPagesToThumbnails completes in handleFile: ensure pages[i].originalIndex = originalOrderIndex

  // Small fix: attach originalIndex after pages created
  // We'll monkey-patch loadPagesToThumbnails call to set originalIndex. Update: implement a small wrapper above.
  // To keep code flow clean, after pdf loaded and pages array built, set originalIndex values:
  (function ensureOriginalIndex() {
    // This closure will run every time pages array changes via loadPagesToThumbnails.
    // We will patch addThumbElement to set pg.originalIndex if missing.
    const origAddThumb = addThumbElement;
    addThumbElement = function(pg) {
      if (typeof pg.originalIndex === 'undefined') pg.originalIndex = pg.pageNum; // initial mapping
      origAddThumb(pg);
    };
  })();

  // End startApp
} // end startApp
</script>
</body>
</html>
