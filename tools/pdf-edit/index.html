<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Edit PDF Online - Smarttool Hub</title>
  <meta name="description" content="Edit PDFs in the browser: annotate, draw, add text/images and export edited PDF. Client-side only." />
  <link rel="icon" href="https://img.icons8.com/fluency/48/toolbox.png" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css"/>
  <style>
    /* Design kept identical to your uploaded tools (header, cards, colors, spacing) */
    :root{--bg:#0b1220;--text:#eaf2ff;--card:#182335;--border:#2a3b55;--primary:#22d3ee;--muted:#9fb3c8;--radius:12px}
    body.light{--bg:#f6f8fb;--text:#0b1220;--card:#ffffff;--border:#e6eefc;--primary:#0b74ff;--muted:#556677}
    *{box-sizing:border-box;margin:0;padding:0}
    body{font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial;background:var(--bg);color:var(--text);min-height:100vh;display:flex;flex-direction:column;transition:background .25s,color .25s}
    .container{max-width:1200px;margin:0 auto;padding:20px;width:100%}
    header{display:flex;align-items:center;justify-content:space-between;gap:12px;background:var(--card);border-bottom:1px solid var(--border);padding:14px 20px}
    .brand{display:flex;gap:12px;align-items:center}
    .brand img{width:46px;height:46px;border-radius:10px}
    .brand .title{font-size:1.25rem;font-weight:700;color:var(--primary);margin:0}
    .brand .tag{font-size:.9rem;color:var(--muted)}
    .header-actions{display:flex;gap:10px;align-items:center}
    .btn-header{border:1px solid var(--border);background:transparent;padding:8px 12px;border-radius:8px;color:var(--text);cursor:pointer;display:flex;align-items:center;gap:6px;text-decoration:none;font-weight:600}
    .btn-header:hover{border-color:var(--primary);color:var(--primary)}

    .tool-content { background:var(--card);border-radius:var(--radius);border:1px solid var(--border);padding:18px;margin-top:20px; }
    .tool-title { font-size:1.6rem;margin-bottom:6px;color:var(--primary); }
    .tool-description { color:var(--muted);margin-bottom:14px; }

    .layout { display:grid; grid-template-columns: 360px 1fr; gap:16px; align-items:start; }
    @media (max-width:980px){ .layout { grid-template-columns: 1fr; } }

    .sidebar { background:var(--bg);border:1px solid var(--border);padding:12px;border-radius:10px; display:flex;flex-direction:column;gap:12px; }
    .upload-area { border:2px dashed var(--border);border-radius:8px;padding:14px;text-align:center;cursor:pointer;background:var(--card) }
    .file-input { display:none; }
    .small { color:var(--muted); font-size:0.9rem; }

    .controls { display:flex;flex-direction:column;gap:8px; }
    .controls .row { display:flex;gap:8px;align-items:center;flex-wrap:wrap; }
    .controls select, .controls input[type="color"], .controls button { background:var(--card);border:1px solid var(--border);color:var(--text);padding:8px;border-radius:8px; }
    .controls .btn { padding:8px 12px;border-radius:8px;border:none;cursor:pointer;font-weight:700; }
    .btn-primary { background:var(--primary);color:#00131f; }
    .btn-secondary { background:transparent;border:1px solid var(--border);color:var(--text); }

    .viewer { background:transparent;border-radius:8px;padding:6px;min-height:520px;overflow:auto;display:flex;flex-direction:column;gap:12px;align-items:center; }
    .page-wrapper { position:relative;background:#0f1720;padding:8px;border-radius:10px;border:1px solid var(--border); }
    canvas.renderCanvas { display:block; max-width:100%; height:auto; border-radius:6px; background:white }
    canvas.annotCanvas { position:absolute; left:8px; top:8px; touch-action:none; cursor:crosshair }

    .page-tools { display:flex;gap:8px;align-items:center;flex-wrap:wrap; }

    .status { color:var(--muted);font-size:0.9rem; }

    footer{margin-top:auto;padding:18px 0;background:var(--card);border-top:1px solid var(--border)}
    .footer-inner{display:flex;align-items:center;justify-content:space-between;gap:12px;flex-wrap:wrap}
    .footer-links{display:flex;gap:14px;flex-wrap:wrap}
    .footer-links a{color:var(--primary);text-decoration:none;font-weight:600}
  </style>
</head>
<body>
  <header class="container">
    <div class="brand">
      <a href="index.html" style="display:flex;align-items:center;gap:12px;text-decoration:none;">
        <img src="https://img.icons8.com/fluency/48/toolbox.png" alt="Smarttool Hub Logo">
        <div>
          <div class="title">Smarttool Hub</div>
          <div class="tag">Fast • Private • 100% Client-side</div>
        </div>
      </a>
    </div>
    <div class="header-actions">
      <a href="index.html" class="btn-header"><i class="fa-solid fa-house"></i> Home</a>
      <button class="btn-header" id="themeToggle" title="Toggle dark/light mode"><i class="fa-solid fa-moon"></i></button>
    </div>
  </header>

  <main class="container">
    <div class="tool-content">
      <div class="tool-title">Edit PDF Online</div>
      <div class="tool-description">Upload PDF, annotate pages (draw, add text, add image), then export the edited PDF. Everything runs in your browser — files never leave your device.</div>

      <div class="layout">
        <!-- Sidebar -->
        <div class="sidebar">
          <div class="upload-area" id="uploadArea" title="Click or drop a PDF to edit">
            <div style="font-weight:700;color:var(--primary)">Upload PDF</div>
            <div class="small">Drop PDF here or click to browse (supports multi-page PDFs)</div>
            <input id="fileInput" class="file-input" type="file" accept="application/pdf">
          </div>

          <div class="controls">
            <div style="font-weight:700">Tools</div>

            <div class="row">
              <button class="btn btn-secondary" id="toolPan"><i class="fa-solid fa-hand-paper"></i> Pan</button>
              <button class="btn btn-primary" id="toolDraw"><i class="fa-solid fa-pen"></i> Draw</button>
              <button class="btn btn-secondary" id="toolText"><i class="fa-solid fa-font"></i> Text</button>
              <button class="btn btn-secondary" id="toolImage"><i class="fa-solid fa-image"></i> Add Image</button>
              <input id="imgInput" type="file" accept="image/*" style="display:none">
            </div>

            <div class="row">
              <label class="small">Color</label>
              <input type="color" id="penColor" value="#ffeb3b">
              <label class="small">Size</label>
              <select id="penSize">
                <option value="2">2px</option>
                <option value="4" selected>4px</option>
                <option value="8">8px</option>
                <option value="12">12px</option>
                <option value="20">20px</option>
              </select>
            </div>

            <div class="row">
              <button class="btn btn-secondary" id="undoBtn"><i class="fa-solid fa-rotate-left"></i> Undo</button>
              <button class="btn btn-secondary" id="clearBtn"><i class="fa-solid fa-trash"></i> Clear Page</button>
            </div>

            <div style="border-top:1px dashed var(--border);padding-top:8px;">
              <div style="font-weight:700">Export</div>
              <div class="row">
                <button class="btn btn-primary" id="savePdfBtn"><i class="fa-solid fa-file-export"></i> Export Edited PDF</button>
                <button class="btn btn-secondary" id="downloadPagesBtn"><i class="fa-solid fa-download"></i> Download Pages (Images)</button>
              </div>
              <div class="small status" id="status">No file loaded</div>
            </div>
          </div>
        </div>

        <!-- Viewer -->
        <div class="viewer" id="viewer">
          <!-- pages will be injected here -->
          <div class="small">Upload a PDF to begin editing — each page shows the original rendering with an annotation layer on top.</div>
        </div>
      </div>
    </div>
  </main>

  <footer class="container">
    <div class="footer-inner">
      <div>© <span id="year"></span> Smarttool Hub</div>
      <div class="footer-links">
        <a href="privacy.html">Privacy</a>
        <a href="terms.html">Terms</a>
        <a href="contact.html">Contact</a>
      </div>
    </div>
  </footer>

  <!-- Dependencies: PDF.js for rendering, jsPDF for export -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>

  <script>
    // Setup
    document.getElementById('year').textContent = new Date().getFullYear();
    const themeToggle = document.getElementById('themeToggle');
    if (localStorage.getItem('sth_theme') === 'light') { document.body.classList.add('light'); themeToggle.innerHTML = '<i class="fa-solid fa-sun"></i>'; }
    themeToggle.onclick = () => {
      document.body.classList.toggle('light');
      if (document.body.classList.contains('light')) { themeToggle.innerHTML = '<i class="fa-solid fa-sun"></i>'; localStorage.setItem('sth_theme','light'); }
      else { themeToggle.innerHTML = '<i class="fa-solid fa-moon"></i>'; localStorage.removeItem('sth_theme'); }
    };

    // pdf.js worker setup
    if (pdfjsLib && pdfjsLib.GlobalWorkerOptions) {
      // use CDN worker (pdfjs-dist exposes worker)
      pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';
    }

    // Elements
    const uploadArea = document.getElementById('uploadArea');
    const fileInput = document.getElementById('fileInput');
    const viewer = document.getElementById('viewer');
    const statusEl = document.getElementById('status');

    const toolPan = document.getElementById('toolPan');
    const toolDraw = document.getElementById('toolDraw');
    const toolText = document.getElementById('toolText');
    const toolImage = document.getElementById('toolImage');
    const imgInput = document.getElementById('imgInput');

    const penColor = document.getElementById('penColor');
    const penSize = document.getElementById('penSize');
    const undoBtn = document.getElementById('undoBtn');
    const clearBtn = document.getElementById('clearBtn');

    const savePdfBtn = document.getElementById('savePdfBtn');
    const downloadPagesBtn = document.getElementById('downloadPagesBtn');

    // State
    let pdfDoc = null;
    let pages = []; // array of {pageNumber, renderCanvas, annotCanvas, scale, actions: [strokes/texts/images], imgElements}
    let currentTool = 'draw'; // 'pan','draw','text','image'
    let activePointer = null;

    // Utility
    function setStatus(txt) { statusEl.textContent = txt; }
    function uid() { return 'id_' + Math.random().toString(36).slice(2,9); }

    // Upload handlers
    uploadArea.addEventListener('click', () => fileInput.click());
    uploadArea.addEventListener('dragover', (e) => { e.preventDefault(); uploadArea.classList.add('dragover'); });
    uploadArea.addEventListener('dragleave', (e) => { e.preventDefault(); uploadArea.classList.remove('dragover'); });
    uploadArea.addEventListener('drop', (e) => { e.preventDefault(); uploadArea.classList.remove('dragover'); const f = e.dataTransfer.files && e.dataTransfer.files[0]; if (f) handleFile(f); });

    fileInput.addEventListener('change', (e) => {
      const f = e.target.files && e.target.files[0];
      if (f) handleFile(f);
      fileInput.value = '';
    });

    async function handleFile(file) {
      if (!file || !/\.pdf$/i.test(file.name) && file.type !== 'application/pdf') { setStatus('Please select a PDF file'); return; }
      setStatus('Loading PDF...');
      pages = [];
      viewer.innerHTML = '';
      try {
        const arrayBuffer = await file.arrayBuffer();
        pdfDoc = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
        setStatus(`PDF loaded — ${pdfDoc.numPages} page(s). Rendering...`);
        // render pages sequentially to avoid heavy parallel work
        for (let p=1; p<=pdfDoc.numPages; p++) {
          await renderPage(p);
        }
        setStatus('Rendering complete. Use tools to annotate. Export when ready.');
      } catch (err) {
        console.error(err);
        setStatus('Failed to load PDF: ' + (err.message || err));
      }
    }

    // Render a single PDF page and attach an annotation canvas above it
    async function renderPage(pageNumber) {
      const page = await pdfDoc.getPage(pageNumber);
      // reasonable scale to render at good quality
      const viewport = page.getViewport({ scale: 1 });
      const desiredWidth = Math.min(viewport.width, 1200); // cap width for UI
      const scale = desiredWidth / viewport.width;
      const renderViewport = page.getViewport({ scale });

      // container
      const wrapper = document.createElement('div');
      wrapper.className = 'page-wrapper';
      wrapper.dataset.page = pageNumber;

      // renderer canvas
      const renderCanvas = document.createElement('canvas');
      renderCanvas.className = 'renderCanvas';
      // use devicePixelRatio for crisp rendering
      const dpr = window.devicePixelRatio || 1;
      renderCanvas.width = Math.floor(renderViewport.width * dpr);
      renderCanvas.height = Math.floor(renderViewport.height * dpr);
      renderCanvas.style.width = Math.floor(renderViewport.width) + 'px';
      renderCanvas.style.height = Math.floor(renderViewport.height) + 'px';
      const rctx = renderCanvas.getContext('2d');
      rctx.scale(dpr, dpr);

      // draw using pdf.js render
      await page.render({ canvasContext: rctx, viewport: renderViewport }).promise;

      // annotation canvas (overlay)
      const annotCanvas = document.createElement('canvas');
      annotCanvas.className = 'annotCanvas';
      annotCanvas.width = renderCanvas.width;
      annotCanvas.height = renderCanvas.height;
      annotCanvas.style.width = renderCanvas.style.width;
      annotCanvas.style.height = renderCanvas.style.height;
      annotCanvas.style.left = '8px'; annotCanvas.style.top = '8px';
      annotCanvas.style.pointerEvents = 'auto';

      // ensure wrapper size matches
      wrapper.style.width = renderCanvas.style.width;
      wrapper.style.height = renderCanvas.style.height;
      wrapper.appendChild(renderCanvas);
      wrapper.appendChild(annotCanvas);

      // page tools row
      const toolsRow = document.createElement('div');
      toolsRow.className = 'page-tools';
      toolsRow.style.marginTop = '8px';
      toolsRow.innerHTML = `<div style="color:var(--muted);font-weight:700">Page ${pageNumber}</div>`;
      wrapper.appendChild(toolsRow);

      viewer.appendChild(wrapper);

      // page state
      const pageState = {
        pageNumber,
        renderCanvas,
        annotCanvas,
        dpr,
        scale,
        actions: [], // each action: {type:'stroke'|'text'|'image', data:...}
        undone: []
      };
      pages.push(pageState);

      // bind annotation events
      bindAnnotEvents(pageState);
    }

    // Annotation: draw strokes, add text, add image. Keep actions stack to support undo.
    function bindAnnotEvents(pageState) {
      const canvas = pageState.annotCanvas;
      const ctx = canvas.getContext('2d');
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';

      let drawing = false;
      let currentStroke = null;

      // utility to get pointer pos scaled to canvas pixel coords
      function getPos(e) {
        const rect = canvas.getBoundingClientRect();
        let clientX, clientY;
        if (e.touches && e.touches[0]) { clientX=e.touches[0].clientX; clientY=e.touches[0].clientY; }
        else { clientX=e.clientX; clientY=e.clientY; }
        const x = (clientX - rect.left) * (canvas.width / rect.width);
        const y = (clientY - rect.top) * (canvas.height / rect.height);
        return { x, y };
      }

      // drawing handlers (pointer events)
      function pointerDown(e) {
        if (currentTool !== 'draw') return;
        drawing = true;
        currentStroke = { type: 'stroke', color: penColor.value, size: Number(penSize.value), points: [] };
        const pt = getPos(e);
        currentStroke.points.push(pt);
        drawStrokeSegment(ctx, currentStroke);
        canvas.setPointerCapture && canvas.setPointerCapture(e.pointerId);
      }
      function pointerMove(e) {
        if (!drawing || !currentStroke) return;
        const pt = getPos(e);
        currentStroke.points.push(pt);
        drawStrokeSegment(ctx, currentStroke);
      }
      function pointerUp(e) {
        if (!drawing) return;
        drawing = false;
        if (currentStroke && currentStroke.points.length) {
          pageState.actions.push(currentStroke);
          pageState.undone = [];
        }
        currentStroke = null;
        canvas.releasePointerCapture && canvas.releasePointerCapture(e.pointerId);
      }

      // support mouse & touch fallback
      canvas.addEventListener('pointerdown', (e)=> {
        if (currentTool === 'draw') pointerDown(e);
        else if (currentTool === 'text') handleTextPlace(e, pageState);
        // image handled separately
      });
      canvas.addEventListener('pointermove', pointerMove);
      canvas.addEventListener('pointerup', pointerUp);
      canvas.addEventListener('pointercancel', pointerUp);
      canvas.addEventListener('touchstart', (e)=>{ /* prevent scrolling */ }, {passive:false});

      // Draw current actions to canvas (clear and re-render)
      function redrawAll() {
        ctx.clearRect(0,0,canvas.width,canvas.height);
        for (const act of pageState.actions) {
          if (act.type === 'stroke') drawStroke(ctx, act);
          else if (act.type === 'text') drawText(ctx, act);
          else if (act.type === 'image') drawImageAction(ctx, act);
        }
      }
      pageState.redrawAll = redrawAll;

      // initial draw
      redrawAll();

      // helper functions for drawing strokes/text/images
      function drawStrokeSegment(ctx, stroke) {
        // draw incremental last segment for performance
        const pts = stroke.points;
        const last = pts.length - 1;
        if (last < 1) {
          // single point (dot)
          ctx.fillStyle = stroke.color;
          const r = stroke.size/2;
          ctx.beginPath(); ctx.arc(pts[0].x, pts[0].y, r, 0, Math.PI*2); ctx.fill();
          return;
        }
        ctx.strokeStyle = stroke.color;
        ctx.lineWidth = stroke.size;
        ctx.beginPath();
        ctx.moveTo(pts[last-1].x, pts[last-1].y);
        ctx.lineTo(pts[last].x, pts[last].y);
        ctx.stroke();
      }
      function drawStroke(ctx, stroke) {
        if (!stroke.points || !stroke.points.length) return;
        ctx.strokeStyle = stroke.color;
        ctx.lineWidth = stroke.size;
        ctx.beginPath();
        ctx.moveTo(stroke.points[0].x, stroke.points[0].y);
        for (let i=1;i<stroke.points.length;i++) ctx.lineTo(stroke.points[i].x, stroke.points[i].y);
        ctx.stroke();
      }
      function drawText(ctx, act) {
        ctx.save();
        ctx.fillStyle = act.color || '#000';
        const fontSize = act.size || 16;
        ctx.font = `${fontSize}px sans-serif`;
        // simple text wrap: draw single line
        ctx.fillText(act.text, act.x, act.y);
        ctx.restore();
      }
      function drawImageAction(ctx, act) {
        // act.img is an HTMLImageElement already loaded
        ctx.drawImage(act.img, act.x, act.y, act.w, act.h);
      }

      // text placement
      async function handleTextPlace(e, pageState) {
        const pos = getPos(e);
        const userText = prompt('Enter text to add to this page (simple plaintext):');
        if (!userText) return;
        const size = parseInt(prompt('Font size in px (e.g. 16):', '18')) || 18;
        const txtAct = { type:'text', text: userText, x: pos.x, y: pos.y, color: penColor.value || '#000', size };
        pageState.actions.push(txtAct);
        pageState.undone = [];
        pageState.redrawAll();
      }

      // image placement
      imgInput.addEventListener('change', async (ev) => {
        const file = ev.target.files && ev.target.files[0];
        if (!file) return;
        if (currentTool !== 'image') return;
        const img = new Image();
        img.onload = () => {
          // scale image to fit page width if too large
          const maxW = canvas.width * 0.5;
          const scale = Math.min(1, maxW / img.naturalWidth);
          const w = img.naturalWidth * scale;
          const h = img.naturalHeight * scale;
          // place at center
          const x = (canvas.width - w)/2;
          const y = (canvas.height - h)/2;
          const act = { type:'image', img, x, y, w, h };
          pageState.actions.push(act);
          pageState.undone = [];
          pageState.redrawAll();
        };
        img.onerror = () => alert('Failed to load image');
        img.src = URL.createObjectURL(file);
        imgInput.value = '';
      });

      // undo and clear bindings per page (wired later globally)
    }

    // Global tool buttons
    function setTool(tool) {
      currentTool = tool;
      [toolPan, toolDraw, toolText, toolImage].forEach(btn => btn.classList.remove('btn-primary'));
      if (tool === 'pan') toolPan.classList.add('btn-primary'); 
      if (tool === 'draw') toolDraw.classList.add('btn-primary');
      if (tool === 'text') toolText.classList.add('btn-primary');
      if (tool === 'image') toolImage.classList.add('btn-primary');
      setStatus('Tool: ' + tool);
      if (tool === 'image') imgInput.click(); // prompt image upload when selecting image tool
    }
    toolPan.addEventListener('click', ()=> setTool('pan'));
    toolDraw.addEventListener('click', ()=> setTool('draw'));
    toolText.addEventListener('click', ()=> setTool('text'));
    toolImage.addEventListener('click', ()=> setTool('image'));

    // Undo and Clear (applies to currently visible page under cursor or first page if none)
    undoBtn.addEventListener('click', () => {
      const ps = getVisiblePageState();
      if (!ps) return;
      if (ps.actions && ps.actions.length) {
        const act = ps.actions.pop();
        ps.undone.push(act);
        ps.redrawAll && ps.redrawAll();
        setStatus('Undid last action on page ' + ps.pageNumber);
      } else {
        setStatus('Nothing to undo on this page');
      }
    });

    clearBtn.addEventListener('click', () => {
      const ps = getVisiblePageState();
      if (!ps) return;
      if (confirm('Clear all annotations on this page?')) {
        ps.actions = [];
        ps.undone = [];
        ps.redrawAll && ps.redrawAll();
        setStatus('Cleared annotations on page ' + ps.pageNumber);
      }
    });

    // Helper: pick page under center of viewport or first page
    function getVisiblePageState() {
      if (!pages.length) return null;
      // pick the first page for simplicity, or you can inspect scroll position to choose nearest
      // We'll choose the page whose wrapper is closest to top of viewer (most visible)
      let best = pages[0];
      let bestDist = Infinity;
      for (const ps of pages) {
        const rect = ps.annotCanvas.getBoundingClientRect();
        const vRect = viewer.getBoundingClientRect();
        const dist = Math.abs(rect.top - vRect.top);
        if (dist < bestDist) { bestDist = dist; best = ps; }
      }
      return best;
    }

    // Export edited PDF: merge renderCanvas + annotCanvas into image per page and add to jsPDF
    savePdfBtn.addEventListener('click', async () => {
      if (!pages.length) { setStatus('No pages to export'); return; }
      setStatus('Preparing edited PDF — this may take a moment...');
      try {
        const { jsPDF } = window.jspdf;
        // use A4 as format with dynamic page sizes based on canvas mm conversion
        const doc = new jsPDF({ unit: 'mm', format: 'a4' }); // placeholder; we will set custom size per page by using addImage with specified w/h
        // We'll start by removing the initial blank page created by jsPDF (it always starts with one). We'll instead create pages manually.
        // Workaround: create new doc and immediately delete initial page later by using setPage? Simpler: create first page with proper content, then addPage for others.
        let firstAdded = false;

        for (let i=0;i<pages.length;i++) {
          const ps = pages[i];
          // Merge render + annotations into one canvas
          const merged = document.createElement('canvas');
          merged.width = ps.renderCanvas.width;
          merged.height = ps.renderCanvas.height;
          const mctx = merged.getContext('2d');
          // draw base (render)
          mctx.drawImage(ps.renderCanvas, 0, 0, merged.width, merged.height);
          // draw annotations
          mctx.drawImage(ps.annotCanvas, 0, 0, merged.width, merged.height);

          // Convert to dataURL PNG
          const dataUrl = merged.toDataURL('image/png');

          // compute dimensions in mm for jsPDF: px -> mm (assume 96 DPI)
          const px = merged.width / (ps.dpr || 1); // pixel CSS width = canvas.width / dpr
          const cssWidthPx = merged.width / (ps.dpr || 1);
          // Better compute mm using CSS pixel width (which equals renderCanvas.style.width px)
          // But we've set style width = Math.floor(viewport.width). So convert CSS px to mm assuming 96dpi: mm = px * 25.4 / 96
          const cssPx = parseFloat(ps.renderCanvas.style.width);
          const mmWidth = cssPx * 25.4 / 96;
          const mmHeight = (merged.height / (ps.dpr || 1)) * 25.4 / 96;

          if (!firstAdded) {
            // use existing first page
            doc.setPage(1);
            doc.deletePage(1);
            // add image as first page by using addPage then set current
            doc.addPage([mmWidth, mmHeight], 'portrait');
            doc.setPage(1);
            doc.addImage(dataUrl, 'PNG', 0, 0, mmWidth, mmHeight);
            firstAdded = true;
          } else {
            doc.addPage([mmWidth, mmHeight], 'portrait');
            doc.setPage(doc.getNumberOfPages());
            doc.addImage(dataUrl, 'PNG', 0, 0, mmWidth, mmHeight);
          }
        }

        // Save PDF
        const ts = new Date().toISOString().slice(0,19).replace(/[:T]/g,'-');
        const filename = `edited_${ts}.pdf`;
        doc.save(filename);
        setStatus('Edited PDF exported: ' + filename);
      } catch (err) {
        console.error('Export failed', err);
        setStatus('Export failed: ' + (err.message || err));
      }
    });

    // Download individual pages as images (merged)
    downloadPagesBtn.addEventListener('click', async () => {
      if (!pages.length) { setStatus('No pages to download'); return; }
      setStatus('Preparing page images...');
      for (let i=0;i<pages.length;i++) {
        const ps = pages[i];
        const merged = document.createElement('canvas');
        merged.width = ps.renderCanvas.width;
        merged.height = ps.renderCanvas.height;
        const mctx = merged.getContext('2d');
        mctx.drawImage(ps.renderCanvas, 0, 0, merged.width, merged.height);
        mctx.drawImage(ps.annotCanvas, 0, 0, merged.width, merged.height);
        const dataUrl = merged.toDataURL('image/png');
        const a = document.createElement('a');
        a.href = dataUrl;
        a.download = `${ps.pageNumber}.png`;
        document.body.appendChild(a);
        a.click();
        setTimeout(()=> { try{document.body.removeChild(a);}catch(e){} }, 200);
      }
      setStatus('Page images downloaded');
    });

    // When user selects an image tool, open file dialog and image placement is handled per-page by imgInput listener
    toolImage.addEventListener('click', ()=> imgInput.click());

    // Notes:
    // - Actions are saved per-page in pages[].actions (strokes/text/images). Undo/clear operate on currently "visible" page (approximation).
    // - Export merges the rendered PDF page and the annotation canvas and packs each merged image into a new PDF page at approximate real-world size.
    // - This approach preserves visual edits but does not preserve vector PDF text/editability.

    // Accessibility: keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z') { undoBtn.click(); }
      if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 's') { e.preventDefault(); savePdfBtn.click(); }
    });

    // Final UI status
    setStatus('Ready — upload a PDF to begin editing.');
  </script>
</body>
</html>
