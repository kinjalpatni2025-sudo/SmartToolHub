<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Edit PDF Online - Smarttool Hub</title>
  <meta name="description" content="Edit PDF pages in the browser: draw, add text, add images, then download edited PDF." />
  <link rel="icon" href="https://img.icons8.com/fluency/48/toolbox.png" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css"/>
  <style>
    /* Design matches your uploaded tools */
    :root{--bg:#0b1220;--text:#eaf2ff;--card:#182335;--border:#2a3b55;--primary:#22d3ee;--muted:#9fb3c8;--radius:12px}
    body.light{--bg:#f6f8fb;--text:#0b1220;--card:#ffffff;--border:#e6eefc;--primary:#0b74ff;--muted:#556677}
    *{box-sizing:border-box;margin:0;padding:0}
    body{font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial;background:var(--bg);color:var(--text);min-height:100vh;display:flex;flex-direction:column;transition:background .25s,color .25s}
    .container{max-width:1200px;margin:0 auto;padding:20px;width:100%}
    header{display:flex;align-items:center;justify-content:space-between;gap:12px;background:var(--card);border-bottom:1px solid var(--border);padding:14px 20px}
    .brand{display:flex;gap:12px;align-items:center}
    .brand img{width:46px;height:46px;border-radius:10px}
    .brand .title{font-size:1.25rem;font-weight:700;color:var(--primary);margin:0}
    .brand .tag{font-size:.9rem;color:var(--muted)}
    .header-actions{display:flex;gap:10px;align-items:center}
    .btn-header{border:1px solid var(--border);background:transparent;padding:8px 12px;border-radius:8px;color:var(--text);cursor:pointer;display:flex;align-items:center;gap:6px;text-decoration:none;font-weight:600}
    .btn-header:hover{border-color:var(--primary);color:var(--primary)}

    .tool-content { background:var(--card);border-radius:var(--radius);border:1px solid var(--border);padding:18px;margin-top:20px; }
    .tool-title { font-size:1.6rem;margin-bottom:5px;color:var(--primary); }
    .tool-description { color:var(--muted);margin-bottom:14px; }

    .layout { display:grid; grid-template-columns: 320px 1fr 360px; gap:16px; align-items:start; }
    @media (max-width:1100px){ .layout{ grid-template-columns: 1fr; } }

    .panel { background:var(--bg); border:1px solid var(--border); padding:12px; border-radius:10px; }
    .upload-area { border:2px dashed var(--border); border-radius:10px; padding:12px; text-align:center; cursor:pointer; background:transparent; }
    .upload-area.dragover { border-color:var(--primary); background:rgba(34,211,238,0.03); }

    .thumbs { display:flex; flex-direction:column; gap:8px; max-height:56vh; overflow:auto; padding:6px; }
    .thumb { display:flex; gap:8px; align-items:center; padding:8px; border-radius:8px; border:1px solid var(--border); cursor:pointer; background:var(--card); }
    .thumb.active { border-color:var(--primary); box-shadow:0 4px 20px rgba(34,211,238,0.06); }
    .thumb .tmeta { font-size:0.9rem; color:var(--muted); }

    .viewer { position:relative; display:flex; flex-direction:column; align-items:center; gap:8px; min-height:60vh; justify-content:flex-start; }
    .page-wrap { position:relative; background:#0b0f13; border-radius:8px; padding:10px; border:1px solid var(--border); }
    canvas.baseCanvas { display:block; max-width:100%; height:auto; border-radius:4px; background:white; }
    canvas.overlayCanvas { position:absolute; left:10px; top:10px; pointer-events:auto; touch-action:none; border-radius:4px; }

    .tools { display:flex; gap:8px; flex-wrap:wrap; margin-bottom:8px; }
    .btn { padding:8px 12px; border-radius:8px; border:none; cursor:pointer; font-weight:700; display:inline-flex; align-items:center; gap:8px; }
    .btn-primary { background:var(--primary); color:#00131f; }
    .btn-secondary { background:var(--card); color:var(--text); border:1px solid var(--border); }
    .tool-control { display:flex; gap:8px; align-items:center; color:var(--muted); }

    .right-panel { display:flex; flex-direction:column; gap:10px; max-height:80vh; overflow:auto; }
    .panel h4 { margin:0 0 8px 0; color:var(--primary); }

    .status { color:var(--muted); font-size:0.9rem; margin-top:6px; }
    .footer-actions { display:flex; gap:8px; align-items:center; justify-content:flex-end; margin-top:12px; }

    .text-box { position:absolute; min-width:60px; min-height:28px; padding:6px 8px; border-radius:6px; background:rgba(255,255,255,0.9); color:#00131f; border:1px dashed rgba(0,0,0,0.12); cursor:move; resize:both; overflow:auto; }
    .text-box[contenteditable="true"]:focus { outline:2px solid rgba(34,211,238,0.25); }

    footer{margin-top:auto;padding:14px 0;background:var(--card);border-top:1px solid var(--border)}
    .footer-inner{display:flex;align-items:center;justify-content:space-between;gap:12px;flex-wrap:wrap}
    .footer-links a{color:var(--primary);text-decoration:none;font-weight:600}
  </style>
</head>
<body>
  <header class="container">
    <div class="brand">
      <a href="index.html" style="display:flex;align-items:center;gap:12px;text-decoration:none;">
        <img src="https://img.icons8.com/fluency/48/toolbox.png" alt="Smarttool Hub Logo">
        <div>
          <div class="title">Smarttool Hub</div>
          <div class="tag">Fast • Private • 100% Client-side</div>
        </div>
      </a>
    </div>
    <div class="header-actions">
      <a href="index.html" class="btn-header"><i class="fa-solid fa-house"></i> Home</a>
      <button class="btn-header" id="themeToggle" title="Toggle dark/light mode"><i class="fa-solid fa-moon"></i></button>
    </div>
  </header>

  <main class="container">
    <div class="tool-content">
      <div style="display:flex;justify-content:space-between;align-items:center;gap:12px">
        <div>
          <h1 class="tool-title">Edit PDF Online</h1>
          <div class="tool-description">Upload a PDF, edit pages (draw, add text, add images) and download the edited PDF. All in your browser.</div>
        </div>
        <div class="status" id="statusMsg">Ready</div>
      </div>

      <div class="layout" style="margin-top:12px;">
        <!-- Left: thumbnails & upload -->
        <div class="panel">
          <div class="upload-area" id="uploadArea" title="Click or drop a PDF here">
            <div style="font-weight:700;color:var(--muted)"><i class="fa-solid fa-file-pdf"></i> Drop PDF here or click to choose</div>
            <div style="margin-top:8px;color:var(--muted);font-size:0.9rem">Single PDF supported for editing</div>
            <input type="file" id="fileInput" accept="application/pdf" style="display:none">
          </div>

          <div style="margin-top:10px">
            <div style="display:flex;gap:8px">
              <button id="zoomIn" class="btn btn-secondary"><i class="fa-solid fa-magnifying-glass-plus"></i> Zoom In</button>
              <button id="zoomOut" class="btn btn-secondary"><i class="fa-solid fa-magnifying-glass-minus"></i> Zoom Out</button>
              <button id="fitWidth" class="btn btn-secondary"><i class="fa-solid fa-expand"></i> Fit Width</button>
            </div>
          </div>

          <h4 style="margin-top:12px">Pages</h4>
          <div class="thumbs" id="thumbs"></div>
        </div>

        <!-- Center: viewer & editing canvas -->
        <div class="panel viewer">
          <div class="tools" id="toolbar">
            <div class="tool-control">
              <button id="selectTool" class="btn btn-secondary"><i class="fa-solid fa-mouse-pointer"></i> Select</button>
              <button id="drawTool" class="btn btn-secondary"><i class="fa-solid fa-pen"></i> Draw</button>
              <button id="textTool" class="btn btn-secondary"><i class="fa-solid fa-font"></i> Text</button>
              <button id="imageTool" class="btn btn-secondary"><i class="fa-solid fa-image"></i> Image</button>
            </div>

            <div class="tool-control">
              <label style="font-weight:700;color:var(--muted)">Color</label>
              <input type="color" id="toolColor" value="#ff0000" style="height:34px;border-radius:6px;border:1px solid var(--border)"/>
              <label style="font-weight:700;color:var(--muted)">Size</label>
              <input type="range" id="toolSize" min="1" max="48" value="4"/>
              <span id="sizeVal" style="color:var(--muted);min-width:36px;text-align:center">4</span>
            </div>

            <div class="tool-control" style="margin-left:auto">
              <button id="undoBtn" class="btn btn-secondary"><i class="fa-solid fa-rotate-left"></i> Undo</button>
              <button id="clearBtn" class="btn btn-secondary"><i class="fa-solid fa-trash"></i> Clear</button>
              <button id="savePageBtn" class="btn btn-primary"><i class="fa-solid fa-save"></i> Save Page</button>
            </div>
          </div>

          <div id="pageContainer" style="width:100%;display:flex;justify-content:center;align-items:center;">
            <div class="page-wrap" id="pageWrap" style="display:none;">
              <!-- baseCanvas and overlayCanvas inserted here -->
            </div>
          </div>

          <div style="width:100%;display:flex;justify-content:space-between;align-items:center;margin-top:8px">
            <div style="color:var(--muted)"><span id="currentPageLabel">Page 0 / 0</span></div>
            <div style="display:flex;gap:8px">
              <button id="prevPage" class="btn btn-secondary"><i class="fa-solid fa-chevron-left"></i> Prev</button>
              <button id="nextPage" class="btn btn-secondary">Next <i class="fa-solid fa-chevron-right"></i></button>
            </div>
          </div>

        </div>

        <!-- Right: properties & download -->
        <div class="panel right-panel">
          <div>
            <h4>Tools / Items</h4>
            <div id="itemsList" style="display:flex;flex-direction:column;gap:8px"></div>
          </div>

          <div>
            <h4>Add Image</h4>
            <input type="file" id="stampInput" accept="image/*" />
            <div class="status" style="margin-top:6px">Upload small PNG/JPG to stamp on pages.</div>
          </div>

          <div>
            <h4>Download</h4>
            <div style="display:flex;gap:8px;flex-wrap:wrap">
              <button id="downloadEditedPdf" class="btn btn-primary" disabled><i class="fa-solid fa-file-arrow-down"></i> Download Edited PDF</button>
              <button id="downloadCurrentPage" class="btn btn-secondary" disabled><i class="fa-solid fa-download"></i> Download Current Page</button>
              <button id="resetAll" class="btn btn-secondary"><i class="fa-solid fa-redo"></i> Reset</button>
            </div>
            <div class="status" id="downloadStatus" style="margin-top:8px"></div>
          </div>
        </div>
      </div>

    </div>
  </main>

  <footer class="container">
    <div class="footer-inner">
      <div>© <span id="year"></span> Smarttool Hub</div>
      <div class="footer-links">
        <a href="privacy.html">Privacy</a>
        <a href="terms.html">Terms</a>
        <a href="contact.html">Contact</a>
      </div>
    </div>
  </footer>

  <!-- Libraries -->
  <script src="https://cdn.jsdelivr.net/npm/pdf-lib/dist/pdf-lib.min.js"></script>
  <script src="https://unpkg.com/pdfjs-dist@3.10.120/build/pdf.min.js"></script>

  <script>
    // UI init
    document.getElementById('year').textContent = new Date().getFullYear();
    const themeToggle = document.getElementById('themeToggle');
    if (localStorage.getItem('sth_theme') === 'light') { document.body.classList.add('light'); themeToggle.innerHTML = '<i class="fa-solid fa-sun"></i>'; }
    themeToggle.onclick = () => {
      document.body.classList.toggle('light');
      if (document.body.classList.contains('light')) { themeToggle.innerHTML = '<i class="fa-solid fa-sun"></i>'; localStorage.setItem('sth_theme','light'); }
      else { themeToggle.innerHTML = '<i class="fa-solid fa-moon"></i>'; localStorage.removeItem('sth_theme'); }
    };

    // pdf.js worker
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://unpkg.com/pdfjs-dist@3.10.120/build/pdf.worker.min.js';

    // Elements
    const uploadArea = document.getElementById('uploadArea');
    const fileInput = document.getElementById('fileInput');
    const thumbs = document.getElementById('thumbs');
    const pageWrap = document.getElementById('pageWrap');
    const pageContainer = document.getElementById('pageContainer');
    const pageCountLabel = document.getElementById('currentPageLabel');
    const statusMsg = document.getElementById('statusMsg');

    const selectTool = document.getElementById('selectTool');
    const drawTool = document.getElementById('drawTool');
    const textTool = document.getElementById('textTool');
    const imageTool = document.getElementById('imageTool');
    const toolColor = document.getElementById('toolColor');
    const toolSize = document.getElementById('toolSize');
    const sizeVal = document.getElementById('sizeVal');
    const undoBtn = document.getElementById('undoBtn');
    const clearBtn = document.getElementById('clearBtn');
    const savePageBtn = document.getElementById('savePageBtn');
    const prevPage = document.getElementById('prevPage');
    const nextPage = document.getElementById('nextPage');
    const zoomIn = document.getElementById('zoomIn');
    const zoomOut = document.getElementById('zoomOut');
    const fitWidth = document.getElementById('fitWidth');

    const itemsList = document.getElementById('itemsList');
    const stampInput = document.getElementById('stampInput');
    const downloadEditedPdf = document.getElementById('downloadEditedPdf');
    const downloadCurrentPage = document.getElementById('downloadCurrentPage');
    const resetAll = document.getElementById('resetAll');

    // State
    let pdfDoc = null;
    let pdfArrayBuffer = null;
    let currentPageIndex = 0; // 0-based
    let scale = 1.0;
    let baseCanvas = null; // page rendered canvas
    let overlayCanvas = null; // drawing/text overlay canvas
    let overlayCtx = null;
    let pageImagesCache = {}; // caches page base image dataURL if needed
    let pagesMeta = []; // [{width, height, viewport, edits: {drawStrokes:[], textBoxes:[], images:[]}, edited:Boolean}]
    // drawStrokes: [{color, size, path: [{x,y}, ...]}]
    // textBoxes: [{html, x, y, w, h, fontSize, color}]
    // images: [{dataUrl, x,y,w,h}]
    let activeTool = 'select'; // select, draw, text, image
    let drawing = false;
    let currentStroke = null;
    let dragItem = null; // for text/image dragging
    let stampImageBlob = null;

    // helpers
    function setStatus(msg) { statusMsg.textContent = msg; }
    function enableButton(btn, en) { btn.disabled = !en; }

    // Upload handlers (drag & click)
    uploadArea.addEventListener('click', () => fileInput.click());
    uploadArea.addEventListener('dragover', (e) => { e.preventDefault(); uploadArea.classList.add('dragover'); });
    uploadArea.addEventListener('dragleave', (e) => { e.preventDefault(); uploadArea.classList.remove('dragover'); });
    uploadArea.addEventListener('drop', (e) => { e.preventDefault(); uploadArea.classList.remove('dragover'); const f = e.dataTransfer.files && e.dataTransfer.files[0]; if (f) handlePdfFile(f); });

    fileInput.addEventListener('change', (e) => { const f = e.target.files && e.target.files[0]; if (f) handlePdfFile(f); fileInput.value=''; });

    // zoom controls
    zoomIn.addEventListener('click', () => { scale = Math.min(3, scale + 0.1); renderCurrentPage(); });
    zoomOut.addEventListener('click', () => { scale = Math.max(0.2, scale - 0.1); renderCurrentPage(); });
    fitWidth.addEventListener('click', () => { scale = 1; renderCurrentPage(); });

    // tool UI
    toolSize.addEventListener('input', () => { sizeVal.textContent = toolSize.value; });
    selectTool.addEventListener('click', () => setActiveTool('select'));
    drawTool.addEventListener('click', () => setActiveTool('draw'));
    textTool.addEventListener('click', () => setActiveTool('text'));
    imageTool.addEventListener('click', () => setActiveTool('image'));
    undoBtn.addEventListener('click', undoLast);
    clearBtn.addEventListener('click', clearOverlays);
    savePageBtn.addEventListener('click', saveCurrentPageEdits);

    prevPage.addEventListener('click', () => { if (!pdfDoc) return; if (currentPageIndex > 0) { currentPageIndex--; switchToPage(currentPageIndex); } });
    nextPage.addEventListener('click', () => { if (!pdfDoc) return; if (currentPageIndex < pdfDoc.numPages - 1) { currentPageIndex++; switchToPage(currentPageIndex); } });

    stampInput.addEventListener('change', async (e) => {
      const f = e.target.files && e.target.files[0];
      if (!f) return;
      const dataUrl = await fileToDataUrl(f);
      stampImageBlob = await (async () => { const b = await f.arrayBuffer(); return new Blob([b], { type: f.type }); })();
      setStatus('Stamp image loaded. Use Image tool to place it on page.');
    });

    resetAll.addEventListener('click', () => {
      pdfDoc = null; pdfArrayBuffer = null; pagesMeta = []; pageImagesCache = {}; currentPageIndex = 0;
      thumbs.innerHTML = ''; pageWrap.style.display='none'; setStatus('Reset complete'); downloadEditedPdf.disabled = true; downloadCurrentPage.disabled = true;
    });

    downloadCurrentPage.addEventListener('click', async () => {
      if (!pdfDoc) return;
      const blob = await exportSinglePageBlob(currentPageIndex);
      downloadBlob(blob, `page-${currentPageIndex+1}.pdf`);
    });

    downloadEditedPdf.addEventListener('click', async () => {
      if (!pdfDoc) return;
      setStatus('Preparing edited PDF — please wait...');
      downloadEditedPdf.disabled = true;
      try {
        const mergedBlob = await buildEditedPdf();
        downloadBlob(mergedBlob, `edited_${new Date().toISOString().slice(0,19).replace(/[:T]/g,'-')}.pdf`);
        setStatus('Edited PDF ready.');
      } catch (err) {
        console.error(err);
        setStatus('Failed to build edited PDF.');
      } finally {
        downloadEditedPdf.disabled = false;
      }
    });

    // utilities
    function downloadBlob(blob, filename) {
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = filename; document.body.appendChild(a); a.click();
      setTimeout(()=>{ URL.revokeObjectURL(url); try{ document.body.removeChild(a); }catch(e){} }, 500);
    }

    function fileToDataUrl(file) {
      return new Promise((resolve, reject) => {
        const r = new FileReader();
        r.onload = e => resolve(e.target.result);
        r.onerror = reject;
        r.readAsDataURL(file);
      });
    }

    // Handle PDF file: load with pdf.js, render thumbnails, prepare meta
    async function handlePdfFile(file) {
      setStatus('Loading PDF — please wait...');
      try {
        const ab = await file.arrayBuffer();
        pdfArrayBuffer = ab;
        // load pdf.js document
        const loadingTask = pdfjsLib.getDocument({ data: ab });
        pdfDoc = await loadingTask.promise;
        // init pages meta
        pagesMeta = [];
        for (let i=0;i<pdfDoc.numPages;i++){
          pagesMeta.push({ width:0, height:0, viewport:null, edits: { drawStrokes:[], textBoxes:[], images:[] }, edited:false });
        }
        // render thumbnails (small)
        thumbs.innerHTML = '';
        for (let i=0;i<pdfDoc.numPages;i++){
          const page = await pdfDoc.getPage(i+1);
          const viewport = page.getViewport({ scale: 0.25 });
          const canvas = document.createElement('canvas');
          canvas.width = Math.floor(viewport.width);
          canvas.height = Math.floor(viewport.height);
          const ctx = canvas.getContext('2d');
          await page.render({ canvasContext: ctx, viewport }).promise;
          const thumb = document.createElement('div'); thumb.className='thumb'; thumb.dataset.index = i;
          const img = document.createElement('img'); img.src = canvas.toDataURL('image/png'); img.style.width='60px'; img.style.height='80px'; img.style.objectFit='cover'; img.style.borderRadius='6px';
          const meta = document.createElement('div'); meta.style.flex='1';
          const title = document.createElement('div'); title.textContent = `Page ${i+1}`;
          const tmeta = document.createElement('div'); tmeta.className='tmeta'; tmeta.textContent = `${Math.round(viewport.width)} x ${Math.round(viewport.height)}`;
          meta.appendChild(title); meta.appendChild(tmeta);
          thumb.appendChild(img); thumb.appendChild(meta);
          thumb.addEventListener('click', () => { switchToPage(i); });
          thumbs.appendChild(thumb);
          page.cleanup?.();
        }
        currentPageIndex = 0;
        await switchToPage(0);
        setStatus('PDF loaded. You can edit pages now.');
        downloadEditedPdf.disabled = false;
        downloadCurrentPage.disabled = false;
      } catch (err) {
        console.error('Failed to load PDF', err);
        setStatus('Failed to load PDF.');
      }
    }

    // switch to page index (0-based)
    async function switchToPage(index) {
      if (!pdfDoc) return;
      currentPageIndex = index;
      // mark active thumb
      Array.from(thumbs.children).forEach(ch => ch.classList.toggle('active', Number(ch.dataset.index) === index));
      // render page with scale
      pageWrap.style.display = 'block';
      // remove existing base/overlay canvases and text boxes
      pageWrap.innerHTML = '';
      // render base canvas
      const page = await pdfDoc.getPage(index+1);
      const viewport = page.getViewport({ scale });
      pagesMeta[index].width = viewport.width;
      pagesMeta[index].height = viewport.height;
      pagesMeta[index].viewport = viewport;

      baseCanvas = document.createElement('canvas');
      baseCanvas.className = 'baseCanvas';
      baseCanvas.width = Math.floor(viewport.width);
      baseCanvas.height = Math.floor(viewport.height);
      // style to be responsive within page-wrap
      baseCanvas.style.maxWidth = '100%';
      baseCanvas.style.height = 'auto';

      const baseCtx = baseCanvas.getContext('2d');
      await page.render({ canvasContext: baseCtx, viewport }).promise;

      // overlay for drawing & controls (positioned absolute relative to pageWrap)
      overlayCanvas = document.createElement('canvas');
      overlayCanvas.className = 'overlayCanvas';
      overlayCanvas.width = baseCanvas.width;
      overlayCanvas.height = baseCanvas.height;
      overlayCanvas.style.left = baseCanvas.offsetLeft + 'px';
      overlayCanvas.style.top = baseCanvas.offsetTop + 'px';
      overlayCanvas.style.width = baseCanvas.style.width;
      overlayCanvas.style.maxWidth = baseCanvas.style.maxWidth;
      overlayCanvas.style.height = baseCanvas.style.height;
      overlayCanvas.style.pointerEvents = 'auto';
      overlayCanvas.style.touchAction = 'none';

      overlayCtx = overlayCanvas.getContext('2d');
      overlayCtx.clearRect(0,0,overlayCanvas.width, overlayCanvas.height);

      // scale overlay to fit rendered size (canvas pixel size)
      pageWrap.appendChild(baseCanvas);
      pageWrap.appendChild(overlayCanvas);

      // render existing edits for this page if any (draw strokes, text boxes, images)
      renderEditsForPage(index);

      // attach event handlers for drawing & text
      attachOverlayEvents();

      pageCountLabel.textContent = `Page ${currentPageIndex+1} / ${pdfDoc.numPages}`;
      updateItemsList();
    }

    function attachOverlayEvents() {
      // clear prior listeners by cloning overlayCanvas
      const newOverlay = overlayCanvas.cloneNode(true);
      overlayCanvas.parentNode.replaceChild(newOverlay, overlayCanvas);
      overlayCanvas = newOverlay;
      overlayCtx = overlayCanvas.getContext('2d');

      // drawing handlers
      overlayCanvas.addEventListener('pointerdown', startPointer);
      overlayCanvas.addEventListener('pointermove', movePointer);
      overlayCanvas.addEventListener('pointerup', endPointer);
      overlayCanvas.addEventListener('pointercancel', endPointer);
      overlayCanvas.addEventListener('pointerleave', endPointer);

      // text double click to add a new text box where clicked when text tool active
      overlayCanvas.addEventListener('dblclick', (e) => {
        if (activeTool !== 'text') return;
        const rect = overlayCanvas.getBoundingClientRect();
        const x = Math.round((e.clientX - rect.left) * (overlayCanvas.width / rect.width));
        const y = Math.round((e.clientY - rect.top) * (overlayCanvas.height / rect.height));
        createTextBoxAt(x, y);
      });
    }

    function startPointer(e) {
      if (activeTool === 'draw') {
        drawing = true;
        currentStroke = { color: toolColor.value, size: Number(toolSize.value), path: [] };
        const pt = toLocalPoint(e);
        currentStroke.path.push(pt);
        drawStrokeOnCanvas(currentStroke); // initial dot
      } else if (activeTool === 'select') {
        // selection/dragging of text/image handled separately via elements (not canvas)
      } else if (activeTool === 'image') {
        // place image if stampImageBlob present
        if (!stampImageBlob) { setStatus('Upload stamp image first from right panel'); return; }
        (async () => {
          const dataUrl = await fileToDataUrl(stampImageBlob);
          const rect = overlayCanvas.getBoundingClientRect();
          const x = Math.round((e.clientX - rect.left) * (overlayCanvas.width / rect.width));
          const y = Math.round((e.clientY - rect.top) * (overlayCanvas.height / rect.height));
          createImageOnPage(dataUrl, x, y);
        })();
      }
    }

    function movePointer(e) {
      if (!drawing || !currentStroke) return;
      const pt = toLocalPoint(e);
      currentStroke.path.push(pt);
      drawStrokeOnCanvas(currentStroke);
    }

    function endPointer(e) {
      if (drawing && currentStroke) {
        // commit stroke to page meta
        pagesMeta[currentPageIndex].edits.drawStrokes.push(currentStroke);
        pagesMeta[currentPageIndex].edited = true;
        currentStroke = null;
        drawing = false;
        updateItemsList();
      }
    }

    function toLocalPoint(e) {
      const rect = overlayCanvas.getBoundingClientRect();
      const x = Math.round((e.clientX - rect.left) * (overlayCanvas.width / rect.width));
      const y = Math.round((e.clientY - rect.top) * (overlayCanvas.height / rect.height));
      return { x, y };
    }

    function drawStrokeOnCanvas(stroke) {
      // draw the whole stroke for simplicity
      overlayCtx.lineJoin = 'round';
      overlayCtx.lineCap = 'round';
      overlayCtx.strokeStyle = stroke.color;
      overlayCtx.lineWidth = stroke.size;
      overlayCtx.beginPath();
      const pts = stroke.path;
      if (!pts || !pts.length) return;
      overlayCtx.moveTo(pts[0].x, pts[0].y);
      for (let i=1;i<pts.length;i++){
        overlayCtx.lineTo(pts[i].x, pts[i].y);
      }
      overlayCtx.stroke();
    }

    // Render all saved edits for a page onto the overlay (without modifying base canvas)
    function renderEditsForPage(pageIndex) {
      overlayCtx.clearRect(0,0,overlayCanvas.width, overlayCanvas.height);
      // draw strokes
      const meta = pagesMeta[pageIndex];
      if (!meta) return;
      (meta.edits.drawStrokes || []).forEach(stroke => {
        overlayCtx.lineJoin = 'round';
        overlayCtx.lineCap = 'round';
        overlayCtx.strokeStyle = stroke.color;
        overlayCtx.lineWidth = stroke.size;
        overlayCtx.beginPath();
        const pts = stroke.path;
        if (!pts || !pts.length) return;
        overlayCtx.moveTo(pts[0].x, pts[0].y);
        for (let i=1;i<pts.length;i++) overlayCtx.lineTo(pts[i].x, pts[i].y);
        overlayCtx.stroke();
      });

      // text boxes and images are DOM elements on top of pageWrap — render those by recreating them
      // first remove existing text/image elements inside pageWrap
      Array.from(pageWrap.querySelectorAll('.text-box, .placed-image')).forEach(n => n.remove());
      // add text boxes
      (meta.edits.textBoxes || []).forEach(tb => {
        createTextBoxFromMeta(tb);
      });
      // add images
      (meta.edits.images || []).forEach(imgMeta => {
        createImageElementFromMeta(imgMeta);
      });
    }

    // Text boxes creation
    function createTextBoxAt(x, y) {
      const tb = {
        html: 'Text',
        x, y,
        w: 160, h: 40,
        fontSize: 16,
        color: '#00131f'
      };
      pagesMeta[currentPageIndex].edits.textBoxes.push(tb);
      pagesMeta[currentPageIndex].edited = true;
      createTextBoxFromMeta(tb, true);
      updateItemsList();
    }

    function createTextBoxFromMeta(tb, focus=false) {
      const el = document.createElement('div');
      el.className = 'text-box';
      el.contentEditable = 'true';
      el.innerText = tb.html;
      el.style.left = (10 + (tb.x * (pageWrap.clientWidth - 20) / overlayCanvas.width)) + 'px';
      el.style.top = (10 + (tb.y * (pageWrap.clientHeight - 20) / overlayCanvas.height)) + 'px';
      el.style.width = (tb.w * (pageWrap.clientWidth - 20) / overlayCanvas.width) + 'px';
      el.style.height = (tb.h * (pageWrap.clientHeight - 20) / overlayCanvas.height) + 'px';
      el.style.fontSize = (tb.fontSize * (pageWrap.clientWidth - 20) / overlayCanvas.width) + 'px';
      el.style.color = tb.color;
      el.style.zIndex = 20;
      el.setAttribute('data-meta-index', pagesMeta[currentPageIndex].edits.textBoxes.indexOf(tb));
      // dragging
      makeDraggable(el, (left, top, width, height) => {
        // update tb position in absolute overlay coords
        const relX = Math.round(((left - 10) * overlayCanvas.width) / (pageWrap.clientWidth - 20));
        const relY = Math.round(((top - 10) * overlayCanvas.height) / (pageWrap.clientHeight - 20));
        const relW = Math.round((width * overlayCanvas.width) / (pageWrap.clientWidth - 20));
        const relH = Math.round((height * overlayCanvas.height) / (pageWrap.clientHeight - 20));
        tb.x = relX; tb.y = relY; tb.w = relW; tb.h = relH; pagesMeta[currentPageIndex].edited = true; updateItemsList();
      });
      // commit edits on blur
      el.addEventListener('blur', () => {
        tb.html = el.innerText;
      });
      pageWrap.appendChild(el);
      if (focus) {
        el.focus();
        // position caret at end
        document.execCommand('selectAll', false, null);
        document.getSelection().collapseToEnd();
      }
    }

    // make element draggable & resizable within pageWrap (simple implementation)
    function makeDraggable(el, onUpdate) {
      let dragging = false;
      let startX=0, startY=0, origLeft=0, origTop=0;
      el.addEventListener('pointerdown', (e) => {
        if (e.target === el) {
          dragging = true;
          startX = e.clientX; startY = e.clientY;
          const rect = el.getBoundingClientRect();
          const parentRect = pageWrap.getBoundingClientRect();
          origLeft = rect.left - parentRect.left;
          origTop = rect.top - parentRect.top;
          el.setPointerCapture(e.pointerId);
        }
      });
      window.addEventListener('pointermove', (e) => {
        if (!dragging) return;
        const dx = e.clientX - startX; const dy = e.clientY - startY;
        const newLeft = Math.max(0, origLeft + dx); const newTop = Math.max(0, origTop + dy);
        el.style.left = (10 + newLeft) + 'px';
        el.style.top = (10 + newTop) + 'px';
      });
      window.addEventListener('pointerup', (e) => {
        if (dragging) {
          dragging = false;
          // compute final dims
          const rect = el.getBoundingClientRect(); const parentRect = pageWrap.getBoundingClientRect();
          const left = rect.left - parentRect.left; const top = rect.top - parentRect.top;
          const width = rect.width; const height = rect.height;
          onUpdate(left, top, width, height);
        }
      });
      // simple resizer via CSS resize is allowed because element has resize:both (in style) — after resize, on pointerup above will compute update
    }

    // images insertion functions
    function createImageOnPage(dataUrl, x, y) {
      const imgMeta = { dataUrl, x, y, w: 160, h: 120 };
      pagesMeta[currentPageIndex].edits.images.push(imgMeta);
      pagesMeta[currentPageIndex].edited = true;
      createImageElementFromMeta(imgMeta);
      updateItemsList();
    }

    function createImageElementFromMeta(imgMeta) {
      const el = document.createElement('img');
      el.className = 'placed-image';
      el.src = imgMeta.dataUrl;
      el.style.position = 'absolute';
      el.style.left = (10 + (imgMeta.x * (pageWrap.clientWidth - 20) / overlayCanvas.width)) + 'px';
      el.style.top = (10 + (imgMeta.y * (pageWrap.clientHeight - 20) / overlayCanvas.height)) + 'px';
      el.style.width = (imgMeta.w * (pageWrap.clientWidth - 20) / overlayCanvas.width) + 'px';
      el.style.height = (imgMeta.h * (pageWrap.clientHeight - 20) / overlayCanvas.height) + 'px';
      el.style.zIndex = 30;
      // draggable/resizable
      makeDraggable(el, (left, top, width, height) => {
        imgMeta.x = Math.round(((left - 10) * overlayCanvas.width) / (pageWrap.clientWidth - 20));
        imgMeta.y = Math.round(((top - 10) * overlayCanvas.height) / (pageWrap.clientHeight - 20));
        imgMeta.w = Math.round((width * overlayCanvas.width) / (pageWrap.clientWidth - 20));
        imgMeta.h = Math.round((height * overlayCanvas.height) / (pageWrap.clientHeight - 20));
        pagesMeta[currentPageIndex].edited = true;
        updateItemsList();
      });
      pageWrap.appendChild(el);
    }

    // Undo last stroke
    function undoLast() {
      const meta = pagesMeta[currentPageIndex];
      if (!meta) return;
      if ((meta.edits.drawStrokes || []).length) {
        meta.edits.drawStrokes.pop();
        pagesMeta[currentPageIndex].edited = true;
        renderEditsForPage(currentPageIndex);
        updateItemsList();
        return;
      }
      // else remove last image if any
      if ((meta.edits.images || []).length) {
        meta.edits.images.pop();
        pagesMeta[currentPageIndex].edited = true;
        renderEditsForPage(currentPageIndex);
        updateItemsList();
        return;
      }
      // else remove last text box
      if ((meta.edits.textBoxes || []).length) {
        meta.edits.textBoxes.pop();
        pagesMeta[currentPageIndex].edited = true;
        renderEditsForPage(currentPageIndex);
        updateItemsList();
        return;
      }
      setStatus('Nothing to undo on this page');
    }

    function clearOverlays() {
      const meta = pagesMeta[currentPageIndex];
      if (!meta) return;
      meta.edits = { drawStrokes: [], textBoxes: [], images: [] };
      meta.edited = true;
      renderEditsForPage(currentPageIndex);
      updateItemsList();
    }

    // Save current page edits: flatten overlays onto an image and cache (so later building PDF uses the flattened image)
    async function saveCurrentPageEdits() {
      setStatus('Flattening page edits — please wait...');
      try {
        // combine base canvas and overlays + DOM text/images into a single canvas
        // create a temp canvas with baseCanvas pixel dimensions
        const tmp = document.createElement('canvas');
        tmp.width = baseCanvas.width;
        tmp.height = baseCanvas.height;
        const ctx = tmp.getContext('2d');

        // draw base
        ctx.drawImage(baseCanvas, 0, 0, tmp.width, tmp.height);

        // draw strokes (already in overlayCtx but positions are matching pixels)
        // draw strokes from meta to avoid depending on overlayCanvas CSS transforms
        const meta = pagesMeta[currentPageIndex];
        // draw strokes
        (meta.edits.drawStrokes || []).forEach(stroke => {
          ctx.lineJoin = 'round';
          ctx.lineCap = 'round';
          ctx.strokeStyle = stroke.color;
          ctx.lineWidth = stroke.size;
          ctx.beginPath();
          if (!stroke.path || !stroke.path.length) return;
          ctx.moveTo(stroke.path[0].x, stroke.path[0].y);
          for (let i=1;i<stroke.path.length;i++) ctx.lineTo(stroke.path[i].x, stroke.path[i].y);
          ctx.stroke();
        });
        // draw images (meta coordinates are in canvas pixel space)
        for (const im of (meta.edits.images || [])) {
          const img = await loadImage(im.dataUrl);
          ctx.drawImage(img, im.x, im.y, im.w, im.h);
        }
        // draw text boxes
        ctx.fillStyle = '#ffffff'; // background for text boxes? we will draw text opaque
        ctx.textBaseline = 'top';
        for (const tb of (meta.edits.textBoxes || [])) {
          // background: optional white rectangle
          ctx.fillStyle = 'rgba(255,255,255,0.95)';
          ctx.fillRect(tb.x, tb.y, tb.w, tb.h);
          // draw text
          ctx.fillStyle = tb.color || '#00131f';
          const fontSize = tb.fontSize || 16;
          ctx.font = `${fontSize}px sans-serif`;
          // basic wrap: split lines by \n
          const lines = (tb.html || '').split('\n');
          let y = tb.y + 4;
          for (const line of lines) {
            ctx.fillText(line, tb.x + 6, y);
            y += fontSize + 2;
          }
        }

        // store flattened image in cache for page
        const dataUrl = tmp.toDataURL('image/png');
        pageImagesCache[currentPageIndex] = dataUrl;
        pagesMeta[currentPageIndex].edited = true;
        setStatus('Page flattened and cached.');
      } catch (err) {
        console.error('Failed to flatten', err);
        setStatus('Flatten failed for page.');
      }
    }

    function loadImage(src) {
      return new Promise((resolve, reject) => {
        const i = new Image();
        i.onload = () => resolve(i);
        i.onerror = reject;
        i.src = src;
      });
    }

    // Export a single page as PDF blob (either original page if unedited or flattened image embedded into PDF page)
    async function exportSinglePageBlob(pageIndex) {
      if (!pdfDoc) throw new Error('No PDF loaded');
      try {
        const { PDFDocument, StandardFonts } = PDFLib;
        const srcBytes = pdfArrayBuffer;
        const srcPdf = await PDFDocument.load(srcBytes, { ignoreEncryption: true });
        if (!pagesMeta[pageIndex].edited || !pageImagesCache[pageIndex]) {
          // simply extract single page from original PDF
          const newPdf = await PDFDocument.create();
          const [copied] = await newPdf.copyPages(srcPdf, [pageIndex]);
          newPdf.addPage(copied);
          const bytes = await newPdf.save();
          return new Blob([bytes], { type: 'application/pdf' });
        } else {
          // replaced page: load flattened image and create a single-page PDF with the image sized to original page dimensions
          const imgDataUrl = pageImagesCache[pageIndex];
          const imgBytes = dataURLToUint8Array(imgDataUrl);
          const newPdf = await PDFDocument.create();
          const img = await newPdf.embedPng(imgBytes);
          // use original page size from pagesMeta
          const width = pagesMeta[pageIndex].width;
          const height = pagesMeta[pageIndex].height;
          const page = newPdf.addPage([width, height]);
          page.drawImage(img, { x: 0, y: 0, width, height });
          const bytes = await newPdf.save();
          return new Blob([bytes], { type: 'application/pdf' });
        }
      } catch (err) {
        console.error('exportSinglePageBlob failed', err);
        throw err;
      }
    }

    // Build edited PDF: for pages that are unedited, copy original pages; for edited pages, insert image pages created from flattened cached images (or flatten on-the-fly)
    async function buildEditedPdf() {
      const { PDFDocument } = PDFLib;
      const srcBytes = pdfArrayBuffer;
      const srcPdf = await PDFDocument.load(srcBytes, { ignoreEncryption: true });
      const mergedPdf = await PDFDocument.create();

      for (let i=0;i<srcPdf.getPageCount();i++){
        if (pagesMeta[i] && pagesMeta[i].edited && pageImagesCache[i]) {
          // embed image page
          const imgBytes = dataURLToUint8Array(pageImagesCache[i]);
          const imgEmbed = await mergedPdf.embedPng(imgBytes);
          const width = pagesMeta[i].width;
          const height = pagesMeta[i].height;
          const page = mergedPdf.addPage([width, height]);
          page.drawImage(imgEmbed, { x: 0, y: 0, width, height });
        } else {
          // copy original page(s)
          const [copied] = await mergedPdf.copyPages(srcPdf, [i]);
          mergedPdf.addPage(copied);
        }
      }

      const bytes = await mergedPdf.save();
      return new Blob([bytes], { type: 'application/pdf' });
    }

    function dataURLToUint8Array(dataURL) {
      const arr = dataURL.split(',');
      const bstr = atob(arr[1]);
      let n = bstr.length;
      const u8 = new Uint8Array(n);
      while (n--) u8[n] = bstr.charCodeAt(n);
      return u8;
    }

    // Items list update (shows counts of strokes/text/images)
    function updateItemsList() {
      itemsList.innerHTML = '';
      const meta = pagesMeta[currentPageIndex];
      if (!meta) return;
      const strokes = (meta.edits.drawStrokes || []).length;
      const texts = (meta.edits.textBoxes || []).length;
      const imgs = (meta.edits.images || []).length;
      const edited = meta.edited ? 'Yes' : 'No';
      const makeRow = (label, val) => {
        const r = document.createElement('div'); r.style.display='flex'; r.style.justifyContent='space-between'; r.style.alignItems='center';
        const l = document.createElement('div'); l.textContent = label; l.style.color='var(--muted)';
        const v = document.createElement('div'); v.textContent = val; v.style.fontWeight='700';
        r.appendChild(l); r.appendChild(v); return r;
      };
      itemsList.appendChild(makeRow('Draw strokes', strokes));
      itemsList.appendChild(makeRow('Text boxes', texts));
      itemsList.appendChild(makeRow('Images', imgs));
      itemsList.appendChild(makeRow('Edited?', edited));
    }

    // create image blob from dataURL and put in cache
    function downloadDataURLAsBlob(dataUrl) {
      const u8 = dataURLToUint8Array(dataUrl);
      return new Blob([u8], { type: 'image/png' });
    }

    // Convert Float32Array etc not needed; helper done above

    // create text/image DOM from saved meta when switching pages
    // already done in renderEditsForPage()

    // sanitize filename
    function sanitizeFilenameBase(name) {
      return name.replace(/[\\\/:*?"<>|]/g,'-').slice(0,80);
    }

    // tools switching
    function setActiveTool(tool) {
      activeTool = tool;
      [selectTool, drawTool, textTool, imageTool].forEach(btn => btn.classList.remove('btn-primary'));
      if (tool === 'select') selectTool.classList.add('btn-primary');
      if (tool === 'draw') drawTool.classList.add('btn-primary');
      if (tool === 'text') textTool.classList.add('btn-primary');
      if (tool === 'image') imageTool.classList.add('btn-primary');
      setStatus(`Tool: ${tool}`);
    }
    setActiveTool('select');

    // create an image element and let user place it
    // already handled via stampInput and image tool (click on canvas to place)

    // small helper: push saved edits to pagesMeta when user manipulates DOM text boxes (on blur we already saved)
    // but when switching pages we should capture current DOM text boxes positions => we'll approximate by keeping meta updated via makeDraggable callbacks

    // initial state
    setStatus('Ready');
    setActiveTool('select');

    // Expose debug
    window._editor_state = () => ({ pagesMeta, pageImagesCache, currentPageIndex });

  </script>
</body>
</html>
