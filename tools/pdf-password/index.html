<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Client-side PDF Encrypt / Decrypt (No API Key)</title>
<style>
  body{font-family:Inter,Arial,Helvetica,sans-serif;background:#0b1220;color:#eaf2ff;padding:20px}
  .card{background:#132034;padding:18px;border-radius:10px;max-width:900px;margin:18px auto;border:1px solid #223248}
  h1{color:#22d3ee;margin:0 0 12px}
  label{display:block;margin:10px 0 6px;color:#bcd6ec}
  input[type="file"]{display:block}
  input[type="password"], input[type="text"]{width:100%;padding:10px;border-radius:8px;border:1px solid #2b3c55;background:#08101a;color:#eaf2ff}
  button{padding:10px 14px;border-radius:8px;border:none;background:#22d3ee;color:#00131f;font-weight:700;cursor:pointer;margin-right:8px}
  .muted{color:#93adca;font-size:0.9rem}
  .row{display:flex;gap:12px;flex-wrap:wrap}
  .col{flex:1;min-width:240px}
  pre{background:#07101a;padding:10px;border-radius:6px;overflow:auto;color:#a7c7e6}
  .note{background:#071a1a;padding:10px;border-radius:8px;margin-top:12px;color:#9fd8c9}
</style>
</head>
<body>
  <div class="card">
    <h1>Offline PDF Encrypt / Decrypt (Client-side)</h1>
    <p class="muted">No API key, no server — everything runs in your browser. Note: result is an encrypted blob (.enc), not an Adobe password-protected PDF.</p>

    <h3>Encrypt PDF</h3>
    <label>Select PDF to encrypt</label>
    <input id="encFile" type="file" accept="application/pdf">
    <div class="row" style="margin-top:8px">
      <div class="col">
        <label>Password (to encrypt)</label>
        <input id="encPassword" type="password" placeholder="Enter a strong password">
      </div>
      <div class="col">
        <label>Output filename</label>
        <input id="encFilename" type="text" placeholder="encrypted-file.enc">
      </div>
    </div>
    <div style="margin-top:12px">
      <button id="encryptBtn">Encrypt & Download</button>
      <button id="clearEnc">Clear</button>
    </div>

    <hr style="border-color:#1f344a;margin:18px 0">

    <h3>Decrypt file</h3>
    <label>Select .enc file to decrypt</label>
    <input id="decFile" type="file" accept=".enc,application/octet-stream">
    <div class="row" style="margin-top:8px">
      <div class="col">
        <label>Password (to decrypt)</label>
        <input id="decPassword" type="password" placeholder="Enter password used for encryption">
      </div>
      <div class="col">
        <label>Output filename (e.g., document.pdf)</label>
        <input id="decFilename" type="text" placeholder="original.pdf">
      </div>
    </div>
    <div style="margin-top:12px">
      <button id="decryptBtn">Decrypt & Download</button>
      <button id="clearDec">Clear</button>
    </div>

    <div class="note" id="noteArea">
      <strong>How it works:</strong>
      <ul>
        <li>We derive a key from your password (PBKDF2) and encrypt the PDF with AES-GCM.</li>
        <li>The encrypted file stores (salt || iv || ciphertext) as binary so it can be decrypted later.</li>
        <li>This is NOT a PDF password — to open the PDF you must first decrypt it using the correct password (we provide the decrypt utility above).</li>
      </ul>
    </div>

    <div style="margin-top:14px">
      <strong>Logs / status:</strong>
      <pre id="log" style="height:140px">Ready.</pre>
    </div>
  </div>

<script>
/*
 Client-side AES-GCM encrypt/decrypt using Web Crypto (SubtleCrypto)
 Format of stored file: [ 8 bytes salt length (uint32 BE) | salt | 12 bytes IV | ciphertext... ]
 Simpler: we store: salt(16 bytes) + iv(12 bytes) + ciphertext
 For easier parsing, we'll prefix with 4-byte salt length.
*/

const logEl = document.getElementById('log');
function log(msg){
  const t = new Date().toLocaleTimeString();
  logEl.textContent = `[${t}] ${msg}\\n` + logEl.textContent;
}

// util: convert string to ArrayBuffer
function str2ab(str){ return new TextEncoder().encode(str); }
function ab2str(ab){ return new TextDecoder().decode(ab); }

// derive key from password + salt using PBKDF2
async function deriveKey(password, salt, iterations=200000, keyLen=256){
  const pwKey = await crypto.subtle.importKey('raw', str2ab(password), {name:'PBKDF2'}, false, ['deriveKey']);
  const derived = await crypto.subtle.deriveKey({
    name:'PBKDF2',
    salt: salt,
    iterations: iterations,
    hash: 'SHA-256'
  }, pwKey, {name:'AES-GCM', length: keyLen}, false, ['encrypt','decrypt']);
  return derived;
}

// generate random bytes
function randBytes(length){ return crypto.getRandomValues(new Uint8Array(length)); }

// encrypt ArrayBuffer with password, returns Uint8Array packaged (salt + iv + ciphertext)
async function encryptBuffer(buffer, password){
  const salt = randBytes(16); // 128-bit salt
  const iv = randBytes(12);   // 96-bit IV for AES-GCM
  const key = await deriveKey(password, salt);
  const cipher = await crypto.subtle.encrypt({name:'AES-GCM', iv: iv}, key, buffer);
  const cipherU8 = new Uint8Array(cipher);

  // Package: [salt (16)] [iv (12)] [ciphertext]
  const out = new Uint8Array(salt.byteLength + iv.byteLength + cipherU8.byteLength);
  out.set(salt, 0);
  out.set(iv, salt.byteLength);
  out.set(cipherU8, salt.byteLength + iv.byteLength);
  return out;
}

// decrypt packaged Uint8Array with password -> returns ArrayBuffer plaintext
async function decryptBuffer(packedU8, password){
  if (packedU8.length < 28) throw new Error('File too small or corrupted');
  const salt = packedU8.slice(0,16);
  const iv = packedU8.slice(16,28);
  const ciphertext = packedU8.slice(28);
  const key = await deriveKey(password, salt);
  const plain = await crypto.subtle.decrypt({name:'AES-GCM', iv: iv}, key, ciphertext);
  return plain;
}

// Download helper
function downloadBlob(blob, filename){
  const a = document.createElement('a');
  const url = URL.createObjectURL(blob);
  a.href = url; a.download = filename || 'file';
  document.body.appendChild(a); a.click();
  setTimeout(()=>{ document.body.removeChild(a); URL.revokeObjectURL(url); }, 200);
}

// ========== Encrypt UI ==========
const encFileEl = document.getElementById('encFile');
const encPassEl = document.getElementById('encPassword');
const encNameEl = document.getElementById('encFilename');
const encryptBtn = document.getElementById('encryptBtn');
const clearEnc = document.getElementById('clearEnc');

encryptBtn.addEventListener('click', async ()=>{
  try{
    const file = encFileEl.files[0];
    const password = encPassEl.value;
    if(!file) { alert('Please select a PDF file to encrypt'); return; }
    if(!password || password.length < 4) { alert('Please enter a password (min 4 chars recommended)'); return; }

    log('Reading file: ' + file.name);
    const arrayBuffer = await file.arrayBuffer();
    log('Deriving key and encrypting (this may take a moment)...');
    const packed = await encryptBuffer(arrayBuffer, password);
    const outName = encNameEl.value ? encNameEl.value.trim() : (file.name + '.enc');
    const blob = new Blob([packed], {type: 'application/octet-stream'});
    downloadBlob(blob, outName);
    log('Encryption complete. Downloaded: ' + outName);
  }catch(err){
    console.error(err);
    log('Error during encryption: ' + err.message);
    alert('Encryption failed: ' + err.message);
  }
});

clearEnc.addEventListener('click', ()=>{
  encFileEl.value=''; encPassEl.value=''; encNameEl.value=''; log('Encryption inputs cleared');
});

// ========== Decrypt UI ==========
const decFileEl = document.getElementById('decFile');
const decPassEl = document.getElementById('decPassword');
const decNameEl = document.getElementById('decFilename');
const decryptBtn = document.getElementById('decryptBtn');
const clearDec = document.getElementById('clearDec');

decryptBtn.addEventListener('click', async ()=>{
  try{
    const file = decFileEl.files[0];
    const password = decPassEl.value;
    if(!file) { alert('Please select an encrypted (.enc) file to decrypt'); return; }
    if(!password) { alert('Please enter the password'); return; }
    log('Reading encrypted file: ' + file.name);
    const packed = new Uint8Array(await file.arrayBuffer());
    log('Attempting decryption (this may take a moment)...');
    const plain = await decryptBuffer(packed, password);
    // try to detect MIME — we'll assume PDF; let user set filename
    const outName = decNameEl.value ? decNameEl.value.trim() : 'decrypted.pdf';
    const blob = new Blob([plain], {type: 'application/pdf'});
    downloadBlob(blob, outName);
    log('Decryption complete. Downloaded: ' + outName);
  }catch(err){
    console.error(err);
    log('Decryption failed: ' + err.message);
    alert('Decryption failed — wrong password or corrupted file.');
  }
});

clearDec.addEventListener('click', ()=>{
  decFileEl.value=''; decPassEl.value=''; decNameEl.value=''; log('Decryption inputs cleared');
});

</script>
</body>
</html>
