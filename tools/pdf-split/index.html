<!--
  File: tools/pdf-split/index.html
  Feature set:
    - Upload PDF (drag & drop / file chooser)
    - Password prompt for protected PDFs (client-side)
    - Page thumbnails via pdf.js (lazy)
    - Larger preview modal with rotate & crop UI
    - Extract selected pages -> single PDF (raster embedding)
    - Extract selected pages -> separate PDFs (ZIP)
    - Progress bar, status messages
    - Dark/light toggle persisted in localStorage
    - SEO meta tags + Open Graph + Twitter Card
    - FAQ JSON-LD schema for SEO
    - Inline comments to help customization
-->

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />

  <!-- Primary SEO -->
  <title>Split PDF — Preview, Password Unlock, Rotate & Crop • Smarttool Hub</title>
  <meta name="description" content="Split and extract pages from PDF files in your browser. Preview thumbnails, unlock password-protected PDFs, rotate & crop pages, and download extracted pages as a single PDF or separate PDFs in a ZIP. 100% client-side — files never leave your device." />
  <meta name="keywords" content="split pdf, pdf split, extract pdf pages, pdf page extractor, password protected pdf unlock, pdf crop, pdf rotate, pdf preview, pdf thumbnails, split pdf online" />
  <meta name="robots" content="index,follow" />
  <link rel="canonical" href="https://yourdomain.example/tools/pdf-split/" />

  <!-- Open Graph for social sharing -->
  <meta property="og:title" content="Split PDF — Preview, Password Unlock, Rotate & Crop • Smarttool Hub" />
  <meta property="og:description" content="Preview thumbnails, unlock password-protected PDFs, rotate & crop pages and extract them as new PDFs — all in your browser." />
  <meta property="og:type" content="website" />
  <meta property="og:url" content="https://yourdomain.example/tools/pdf-split/" />
  <meta property="og:image" content="https://yourdomain.example/assets/pdf-split-preview.png" />

  <!-- Twitter card -->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:title" content="Split PDF — Smarttool Hub" />
  <meta name="twitter:description" content="Split and extract pages from PDFs with preview, password unlock, rotate & crop — client-side." />
  <meta name="twitter:image" content="https://yourdomain.example/assets/pdf-split-preview.png" />

  <!-- Favicon -->
  <link rel="icon" href="https://img.icons8.com/fluency/48/toolbox.png" />

  <!-- FontAwesome (icons) -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css"/>

  <!-- Minimal CSS with theme variables; comments explain customization points -->
  <style>
    /* ========== THEME VARIABLES ==========
       Modify these variables to match your site brand colors */
    :root{
      --bg:#0b1220; --text:#eaf2ff; --card:#182335; --border:#2a3b55; --primary:#22d3ee; --muted:#9fb3c8;
    }
    body.light{ --bg:#f6f8fb; --text:#0b1220; --card:#fff; --border:#e6eefc; --primary:#0b74ff; --muted:#556677; }

    /* ========== BASE STYLES ========= */
    *{box-sizing:border-box}
    body{margin:0;font-family:Inter,ui-sans-serif,system-ui,Arial;background:var(--bg);color:var(--text);transition:.18s}
    .container{max-width:1100px;margin:0 auto;padding:18px}

    /* ========== HEADER ========= */
    header{display:flex;justify-content:space-between;align-items:center;background:var(--card);padding:12px;border-bottom:1px solid var(--border);border-radius:6px}
    .brand a{display:flex;gap:12px;align-items:center;text-decoration:none;color:inherit}
    .brand img{width:44px;height:44px;border-radius:8px}
    .title{font-weight:700;color:var(--primary)}
    .tag{font-size:.85rem;color:var(--muted)}
    .header-actions{display:flex;gap:8px;align-items:center}
    .btn-header{border:1px solid var(--border);background:transparent;padding:8px 12px;border-radius:8px;color:var(--text);cursor:pointer;display:flex;gap:8px;align-items:center;text-decoration:none;font-weight:600}

    /* ========== MAIN LAYOUT ========= */
    main{padding:18px 0}
    h1{margin:6px 0 8px;color:var(--primary);font-size:1.5rem}
    .meta{color:var(--muted);margin-bottom:12px}

    /* ========== UPLOADER ========= */
    .uploader{min-height:110px;border-radius:12px;border:2px dashed var(--border);display:flex;flex-direction:column;align-items:center;justify-content:center;padding:18px;background:var(--card);cursor:pointer}
    .uploader:hover{border-color:var(--primary)}
    input[type=file]{display:none}

    /* ========== CONTROLS & PROGRESS ========= */
    .controls{display:flex;gap:12px;align-items:center;margin-top:12px;flex-wrap:wrap}
    .small{padding:6px 8px;border-radius:8px;border:1px solid var(--border);background:transparent;color:var(--text)}
    .progress{height:12px;background:var(--border);border-radius:999px;overflow:hidden;margin-top:12px}
    .progress-bar{height:100%;width:0;background:var(--primary);transition:width .22s}

    /* ========== THUMBNAILS ========= */
    .pages{margin-top:18px;display:flex;flex-wrap:wrap;gap:12px;max-height:420px;overflow:auto;padding:8px}
    .page-card{width:110px;background:var(--card);border:1px solid var(--border);border-radius:8px;padding:8px;display:flex;flex-direction:column;align-items:center;gap:8px;position:relative}
    .page-card canvas{width:96px;height:auto;background:#fff;border-radius:6px}
    .page-label{font-size:.85rem;color:var(--muted);text-align:center}
    .checkbox-overlay{position:absolute;left:6px;top:6px;z-index:6}
    .actions{margin-top:12px;display:flex;gap:10px;flex-wrap:wrap}

    /* ========== MODAL (PREVIEW & CROP) ========= */
    .modal { position:fixed; left:0; top:0; right:0; bottom:0; background:rgba(0,0,0,0.6); display:none; align-items:center; justify-content:center; z-index:9999; padding:18px }
    .modal .card { width:100%; max-width:1100px; background:var(--card); padding:16px; border-radius:12px; border:1px solid var(--border); display:flex; gap:12px; color:var(--text) }
    .modal .left { flex:1; display:flex; flex-direction:column; gap:10px; align-items:center; justify-content:center; overflow:auto; position:relative }
    .modal canvas { background:#fff; border-radius:6px; max-width:100%; height:auto; box-shadow:0 6px 18px rgba(0,0,0,0.4) }
    .modal .right { width:320px; display:flex; flex-direction:column; gap:10px }

    .crop-overlay { position:absolute; border:2px dashed var(--primary); pointer-events:none; z-index:20; }

    footer{margin-top:24px;padding:12px 0;background:var(--card);border-top:1px solid var(--border);border-radius:6px}
    @media(max-width:820px){.controls{flex-direction:column;align-items:flex-start}.page-card{width:30%}.modal .card{flex-direction:column}.modal .right{width:100%}}
  </style>
</head>
<body>
  <!-- ========== HEADER ========== -->
  <header class="container">
    <div class="brand">
      <!-- Clickable logo: update href to your real homepage -->
      <a href="../../index.html" title="Smarttool Hub home">
        <img src="https://img.icons8.com/fluency/48/toolbox.png" alt="Smarttool Hub logo">
        <div>
          <div class="title">Smarttool Hub</div>
          <div class="tag">Fast • Private • Client-side</div>
        </div>
      </a>
    </div>

    <div class="header-actions">
      <!-- Home link -->
      <a href="../../index.html" class="btn-header"><i class="fa-solid fa-house"></i> Home</a>
      <!-- Dark/Light toggle (persisted in localStorage) -->
      <button id="themeToggle" class="btn-header" title="Toggle theme"><i class="fa-solid fa-moon"></i></button>
    </div>
  </header>

  <!-- ========== MAIN ========== -->
  <main class="container">
    <h1>Split PDF — Preview, Password Unlock, Rotate & Crop</h1>
    <p class="meta">Upload a PDF, preview thumbnails, open larger preview to rotate and crop pages, then extract selected pages as a new PDF or separate PDFs (ZIP). If the PDF is password-protected you'll be prompted to enter the password (client-side).</p>

    <!-- UPLOADER: click or drop a file -->
    <label class="uploader" id="uploader">
      <div style="font-size:28px;color:var(--primary)"><i class="fa-solid fa-file-pdf"></i></div>
      <div style="margin-top:8px;font-weight:700">Click or drag & drop a PDF</div>
      <div style="margin-top:6px;color:var(--muted)">Supported: .pdf — single file at a time.</div>
      <input type="file" id="fileInput" accept="application/pdf" />
    </label>

    <!-- Controls: ranges, select/deselect -->
    <div class="controls" role="region" aria-label="split controls">
      <input type="text" id="rangeField" placeholder="Type ranges e.g. 1-3,5 (optional)" class="small" />
      <button id="applyRangeBtn" class="small btn btn-ghost">Apply Range</button>
      <button id="selectAllBtn" class="small btn btn-ghost">Select all</button>
      <button id="deselectAllBtn" class="small btn btn-ghost">Deselect all</button>
      <div style="margin-left:auto;color:var(--muted)">Selected: <span id="selectedCount">0</span></div>
    </div>

    <!-- Progress -->
    <div class="progress" aria-hidden="true"><div class="progress-bar" id="progressBar"></div></div>

    <!-- Thumbnails container -->
    <div class="pages" id="pages" aria-live="polite"></div>

    <!-- Actions -->
    <div class="actions">
      <button id="extractSelectedBtn" class="btn btn-primary" disabled><i class="fa-solid fa-file-arrow-down"></i> Extract selected → single PDF</button>
      <button id="extractZipBtn" class="btn btn-ghost" disabled><i class="fa-solid fa-file-zipper"></i> Extract selected → separate PDFs (ZIP)</button>
      <button id="clearBtn" class="btn btn-ghost" disabled><i class="fa-solid fa-trash-can"></i> Clear</button>
      <div class="status" id="status" style="align-self:center;margin-left:8px;"></div>
    </div>
  </main>

  <!-- ========== FOOTER ========== -->
  <footer class="container">
    <div>© <span id="year"></span> Smarttool Hub</div>
    <div style="color:var(--muted)">Privacy • Terms • Contact</div>
  </footer>

  <!-- ========== Password Modal (for protected PDFs) ==========
       This modal collects the password from the user and returns it to the loader.
  -->
  <div id="passwordModal" class="modal" aria-hidden="true">
    <div class="card" style="max-width:520px">
      <div style="flex:1">
        <h3>Enter PDF password</h3>
        <p style="color:var(--muted)">This PDF is password-protected. Enter the password to decrypt it (client-side).</p>
        <input id="pwdInput" type="password" class="small" placeholder="Password" style="width:100%;margin-top:8px" />
        <div style="margin-top:12px;display:flex;gap:8px;">
          <button id="pwdSubmit" class="btn btn-primary">Unlock</button>
          <button id="pwdCancel" class="btn btn-ghost">Cancel</button>
        </div>
        <div id="pwdMsg" style="color:var(--muted);margin-top:8px"></div>
      </div>
    </div>
  </div>

  <!-- ========== Preview Modal: large page preview + rotate & crop UI ========= -->
  <div id="previewModal" class="modal" aria-hidden="true">
    <div class="card">
      <div class="left">
        <div style="position:relative;">
          <!-- preview canvas where pdf.js renders the page -->
          <canvas id="previewCanvas"></canvas>
          <!-- crop overlay rectangle positioned absolutely on top of canvas -->
          <div id="cropOverlay" class="crop-overlay" style="display:none"></div>
        </div>
        <div style="font-size:.9rem;color:var(--muted)">Drag to draw crop box. Use rotate buttons to change rotation. Click Save to apply changes to this page.</div>
      </div>
      <div class="right">
        <div style="display:flex;gap:8px;">
          <button id="rotateLeft" class="btn btn-ghost small">⟲ Rotate Left</button>
          <button id="rotateRight" class="btn btn-ghost small">⟳ Rotate Right</button>
          <button id="resetTransform" class="btn btn-ghost small">Reset</button>
        </div>

        <div style="margin-top:8px">
          <label style="color:var(--muted)">Crop preset (px)</label>
          <div style="display:flex;gap:6px;margin-top:6px">
            <input id="cropX" class="small" placeholder="x" />
            <input id="cropY" class="small" placeholder="y" />
            <input id="cropW" class="small" placeholder="w" />
            <input id="cropH" class="small" placeholder="h" />
          </div>
          <div style="display:flex;gap:6px;margin-top:8px">
            <button id="applyCropInputs" class="btn btn-ghost small">Apply crop</button>
            <button id="clearCropInputs" class="btn btn-ghost small">Clear crop</button>
          </div>
        </div>

        <div style="margin-top:12px">
          <button id="savePageTransform" class="btn btn-primary small" style="width:100%">Save (apply to this page)</button>
          <button id="closePreview" class="btn btn-ghost small" style="width:100%;margin-top:8px">Close</button>
        </div>
      </div>
    </div>
  </div>

  <!-- ========== FAQ JSON-LD (structured data for SEO) ==========
       Edit or extend the Q/A entries as needed.
  -->
  <script type="application/ld+json">
  {
    "@context":"https://schema.org",
    "@type":"FAQPage",
    "mainEntity":[
      {
        "@type":"Question",
        "name":"How do I extract pages from a PDF?",
        "acceptedAnswer":{"@type":"Answer","text":"Upload your PDF, select pages (or enter ranges), and click Extract selected. You can download as a single PDF or as separate PDF files in a ZIP."}
      },
      {
        "@type":"Question",
        "name":"Can I use password-protected PDFs?",
        "acceptedAnswer":{"@type":"Answer","text":"Yes. If a PDF is password-protected you'll be prompted to enter the password. The password is used client-side; files and passwords are not uploaded to any server."}
      },
      {
        "@type":"Question",
        "name":"Will my files be uploaded?",
        "acceptedAnswer":{"@type":"Answer","text":"No. All processing is performed in your browser. Files are never sent to a remote server."}
      },
      {
        "@type":"Question",
        "name":"Does cropping or rotating affect text quality?",
        "acceptedAnswer":{"@type":"Answer","text":"This tool rasterizes pages (canvas -> image -> embed into PDF) when applying crops/rotations, which produces image-based pages. If you need vector output (preserve selectable text), request a vector copy feature — we can attempt page-copy via pdf-lib for unprotected PDFs."}
      }
    ]
  }
  </script>

  <!-- ========== Libraries ==========
       - pdf.js for rendering thumbnails and preview (client-side)
       - pdf-lib for creating output PDFs
       - jszip for packaging multiple PDFs into ZIP
  -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
  <script>pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';</script>
  <script src="https://unpkg.com/pdf-lib/dist/pdf-lib.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

  <!-- ========== MAIN JAVASCRIPT (detailed comments included) ========== -->
  <script>
  (function(){
    /* -------------------------
       INITIAL UI / THEME SETUP
       ------------------------- */
    const themeBtn = document.getElementById('themeToggle');
    if(localStorage.getItem('sth_theme') === 'light'){
      document.body.classList.add('light');
      themeBtn.innerHTML = '<i class="fa-solid fa-sun"></i>';
    }
    themeBtn.addEventListener('click', ()=> {
      document.body.classList.toggle('light');
      if(document.body.classList.contains('light')){
        themeBtn.innerHTML = '<i class="fa-solid fa-sun"></i>';
        localStorage.setItem('sth_theme','light');
      } else {
        themeBtn.innerHTML = '<i class="fa-solid fa-moon"></i>';
        localStorage.removeItem('sth_theme');
      }
    });
    document.getElementById('year').textContent = new Date().getFullYear();

    /* -------------------------
       DOM REFERENCES
       ------------------------- */
    const uploader = document.getElementById('uploader');
    const fileInput = document.getElementById('fileInput');
    const pagesDiv = document.getElementById('pages');
    const progressBar = document.getElementById('progressBar');
    const statusEl = document.getElementById('status');

    const rangeField = document.getElementById('rangeField');
    const applyRangeBtn = document.getElementById('applyRangeBtn');
    const selectAllBtn = document.getElementById('selectAllBtn');
    const deselectAllBtn = document.getElementById('deselectAllBtn');
    const selectedCountEl = document.getElementById('selectedCount');

    const extractSelectedBtn = document.getElementById('extractSelectedBtn');
    const extractZipBtn = document.getElementById('extractZipBtn');
    const clearBtn = document.getElementById('clearBtn');

    // Password modal elements
    const pwdModal = document.getElementById('passwordModal');
    const pwdInput = document.getElementById('pwdInput');
    const pwdSubmit = document.getElementById('pwdSubmit');
    const pwdCancel = document.getElementById('pwdCancel');
    const pwdMsg = document.getElementById('pwdMsg');

    // Preview modal elements (rotate & crop)
    const previewModal = document.getElementById('previewModal');
    const previewCanvas = document.getElementById('previewCanvas');
    const cropOverlay = document.getElementById('cropOverlay');
    const rotateLeftBtn = document.getElementById('rotateLeft');
    const rotateRightBtn = document.getElementById('rotateRight');
    const resetTransformBtn = document.getElementById('resetTransform');
    const cropX = document.getElementById('cropX');
    const cropY = document.getElementById('cropY');
    const cropW = document.getElementById('cropW');
    const cropH = document.getElementById('cropH');
    const applyCropInputs = document.getElementById('applyCropInputs');
    const clearCropInputs = document.getElementById('clearCropInputs');
    const savePageTransform = document.getElementById('savePageTransform');
    const closePreview = document.getElementById('closePreview');

    /* -------------------------
       APPLICATION STATE
       ------------------------- */
    // pdfData stores original arrayBuffer, pdf.js doc, pageCount, selection set and per-page transforms
    let pdfData = null;

    // modalState keeps temporary transforms while user edits a page
    let modalState = { pageIndex: 0, rotation: 0, crop: null, baseRenderScale: 1.2 };

    /* -------------------------
       SMALL UTILITY FUNCTIONS
       ------------------------- */
    function showStatus(txt, busy=false, hideMs=0){
      statusEl.textContent = txt || '';
      if(busy) statusEl.insertAdjacentHTML('afterbegin','<span class="spinner" aria-hidden="true"></span>');
      if(hideMs) setTimeout(()=> statusEl.textContent = '', hideMs);
    }
    function setProgress(p){ progressBar.style.width = Math.min(100, Math.max(0, Math.round(p))) + '%'; }
    function resetProgress(){ progressBar.style.width = '0%'; }
    function sanitize(name){ return name.replace(/[^a-z0-9_\-\.]/gi, '_'); }
    function triggerDownload(blob, filename){
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(()=> URL.revokeObjectURL(a.href), 3000);
    }
    function escapeHtml(s){ return String(s).replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }

    /* -------------------------
       FILE INPUT / DRAG & DROP
       ------------------------- */
    // Clicking the uploader triggers the hidden file input
    uploader.addEventListener('click', ()=> fileInput.click());

    // Drag & drop UX
    uploader.addEventListener('dragover', e => { e.preventDefault(); uploader.style.borderColor = 'var(--primary)'; });
    uploader.addEventListener('dragleave', e => { uploader.style.borderColor = ''; });
    uploader.addEventListener('drop', e => { e.preventDefault(); uploader.style.borderColor = ''; handleFile(e.dataTransfer.files[0]); });

    // File input change
    fileInput.addEventListener('change', e => handleFile(e.target.files[0]));

    // Main file handler (supports password prompts)
    async function handleFile(file){
      if(!file) return;
      if(!(file.type === 'application/pdf' || file.name.toLowerCase().endsWith('.pdf'))){
        alert('Please select a PDF file.');
        return;
      }
      showStatus('Loading PDF...', true);
      resetProgress();
      try{
        const buffer = await file.arrayBuffer();

        // Attempt to open with pdf.js. If it fails with a password error,
        // ask the user for password via modal and retry.
        let pdfjsDoc = null;
        try {
          pdfjsDoc = await pdfjsLib.getDocument({ data: buffer }).promise;
        } catch(err){
          // Detect password exception (pdf.js throws a PasswordException)
          const msg = String(err && (err.message || err));
          if(/password/i.test(msg) || err && err.name === 'PasswordException'){
            // Prompt user for password (modal)
            const pw = await askPasswordForPdf();
            if(pw === null){
              showStatus('Password entry cancelled', false);
              return;
            }
            // try with password
            try {
              pdfjsDoc = await pdfjsLib.getDocument({ data: buffer, password: pw }).promise;
            } catch(err2){
              console.error('Password failed', err2);
              showStatus('Password incorrect or PDF cannot be opened', false);
              return;
            }
          } else {
            // Some other error opening PDF
            console.error('pdf.js open failed', err);
            showStatus('Failed to open PDF — see console', false);
            return;
          }
        }

        // If we reach here, pdfjsDoc is loaded
        const pageCount = pdfjsDoc.numPages;
        // create per-page transform placeholders
        const pages = Array.from({length: pageCount}, ()=> ({ rotation: 0, crop: null }));
        pdfData = { arrayBuffer: buffer, pdfjsDoc, pageCount, selectedPages: new Set(Array.from({length: pageCount}, (_,i)=>i)), fileName: file.name, pages };
        renderPagesThumbnails();   // render small thumbnails
        updateButtons();
        showStatus('Loaded: ' + pageCount + ' pages', false, 1800);
      } catch(err){
        console.error('Failed to load file', err);
        showStatus('Failed to load PDF — see console', false);
      }
    }

    /* -------------------------
       Password modal helper
       Returns a Promise that resolves to the entered password, or null if canceled.
    */
    function askPasswordForPdf(){
      return new Promise((resolve) => {
        pwdInput.value = '';
        pwdMsg.textContent = '';
        pwdModal.style.display = 'flex';
        pwdModal.removeAttribute('aria-hidden');
        pwdInput.focus();

        const onSubmit = () => { const val = pwdInput.value || ''; closePwd(); resolve(val); };
        const onCancel = () => { closePwd(); resolve(null); };

        function closePwd(){ pwdModal.style.display = 'none'; pwdModal.setAttribute('aria-hidden', 'true'); pwdSubmit.removeEventListener('click', onSubmit); pwdCancel.removeEventListener('click', onCancel); }

        pwdSubmit.addEventListener('click', onSubmit);
        pwdCancel.addEventListener('click', onCancel);
      });
    }

    /* -------------------------
       Thumbnail rendering (small) via pdf.js
       We render all thumbnails sequentially to keep UI responsive.
       Each thumbnail contains a checkbox (overlay) to select/deselect page.
    */
    async function renderPagesThumbnails(){
      pagesDiv.innerHTML = '';
      if(!pdfData) return;
      // Sequentially render each page as a tiny canvas
      for(let p=1;p<=pdfData.pageCount;p++){
        try{
          const page = await pdfData.pdfjsDoc.getPage(p);
          const viewport = page.getViewport({ scale: 0.15 });
          const canvas = document.createElement('canvas');
          canvas.width = Math.round(viewport.width);
          canvas.height = Math.round(viewport.height);
          const ctx = canvas.getContext('2d');
          await page.render({ canvasContext: ctx, viewport }).promise;

          // build card DOM
          const card = document.createElement('div');
          card.className = 'page-card';
          card.dataset.page = p-1;
          card.innerHTML = `
            <label class="checkbox-overlay">
              <input type="checkbox" class="page-select" data-page="${p-1}" ${pdfData.selectedPages.has(p-1) ? 'checked' : ''}>
            </label>
            <canvas></canvas>
            <div class="page-label">Page ${p}</div>
          `;

          // copy rendered thumbnail into displayed canvas
          const displayCanvas = card.querySelector('canvas');
          displayCanvas.width = canvas.width;
          displayCanvas.height = canvas.height;
          displayCanvas.getContext('2d').drawImage(canvas,0,0);

          // clicking the thumbnail canvas opens the large preview modal
          displayCanvas.addEventListener('click', (ev) => {
            openPreviewModal(p-1);
          });

          // checkbox toggles selection set
          card.querySelector('.page-select').addEventListener('change', (ev) => {
            const idx = Number(ev.target.dataset.page);
            if(ev.target.checked) pdfData.selectedPages.add(idx);
            else pdfData.selectedPages.delete(idx);
            updateSelectedCount();
          });

          pagesDiv.appendChild(card);
        } catch(err){
          console.warn('Thumb render failed for page', p, err);
        }
        // small pause to keep UI responsive for many pages
        await new Promise(r=>setTimeout(r, 12));
      }
      updateSelectedCount();
      updateButtons();
    }

    /* -------------------------
       Selection helpers: select all, deselect all, apply range
    */
    function updateSelectedCount(){
      if(!pdfData){ selectedCountEl.textContent = '0'; return; }
      selectedCountEl.textContent = pdfData.selectedPages.size;
      extractSelectedBtn.disabled = pdfData.selectedPages.size === 0;
      extractZipBtn.disabled = pdfData.selectedPages.size === 0;
      clearBtn.disabled = false;
    }

    selectAllBtn.addEventListener('click', ()=> {
      if(!pdfData) return;
      pdfData.selectedPages = new Set(Array.from({length: pdfData.pageCount}, (_,i)=>i));
      // update UI checkboxes if present
      pagesDiv.querySelectorAll('.page-select').forEach(cb => cb.checked = true);
      updateSelectedCount();
    });

    deselectAllBtn.addEventListener('click', ()=> {
      if(!pdfData) return;
      pdfData.selectedPages.clear();
      pagesDiv.querySelectorAll('.page-select').forEach(cb => cb.checked = false);
      updateSelectedCount();
    });

    applyRangeBtn.addEventListener('click', ()=> {
      if(!pdfData) return;
      const txt = rangeField.value.trim();
      if(!txt) return;
      const arr = parseRange(txt, pdfData.pageCount);
      pdfData.selectedPages = new Set(arr);
      // update checkboxes in DOM
      pagesDiv.querySelectorAll('.page-select').forEach(cb => {
        const p = Number(cb.dataset.page);
        cb.checked = pdfData.selectedPages.has(p);
      });
      updateSelectedCount();
    });

    function parseRange(str, pageCount){
      // Parses strings like "1-3,5" -> zero-based page indices
      const tokens = str.split(',').map(s=>s.trim()).filter(Boolean);
      const out = new Set();
      tokens.forEach(t=>{
        if(t.includes('-')){
          const [a,b] = t.split('-').map(x=>parseInt(x,10));
          if(isNaN(a)||isNaN(b)) return;
          const start = Math.max(1, Math.min(a,b));
          const end = Math.min(pageCount, Math.max(a,b));
          for(let i=start;i<=end;i++) out.add(i-1);
        } else {
          const n = parseInt(t,10);
          if(!isNaN(n) && n>=1 && n<=pageCount) out.add(n-1);
        }
      });
      return Array.from(out).sort((a,b)=>a-b);
    }

    /* -------------------------
       PREVIEW MODAL: open, render, rotate, crop interactions
       - openPreviewModal(index): sets modalState and calls renderPreviewCanvas()
       - renderPreviewCanvas(): uses pdf.js to render a larger canvas
       - user can drag to draw crop box (overlay)
       - rotation and crop inputs update modalState
    */
    function openPreviewModal(pageIndex){
      if(!pdfData) return;
      modalState.pageIndex = pageIndex;
      modalState.rotation = pdfData.pages[pageIndex].rotation || 0;
      modalState.crop = pdfData.pages[pageIndex].crop ? {...pdfData.pages[pageIndex].crop} : null;
      previewModal.style.display = 'flex';
      previewModal.removeAttribute('aria-hidden');
      renderPreviewCanvas();
    }

    async function renderPreviewCanvas(){
      const pIdx = modalState.pageIndex;
      const pageNum = pIdx + 1;
      const page = await pdfData.pdfjsDoc.getPage(pageNum);
      // choose scale for modal preview (bigger than thumbnail)
      const scale = modalState.baseRenderScale || 1.2;
      // pdf.js supports rotation in getViewport
      const viewport = page.getViewport({ scale, rotation: modalState.rotation });
      const canvas = previewCanvas;
      canvas.width = Math.round(viewport.width);
      canvas.height = Math.round(viewport.height);
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0,0,canvas.width,canvas.height);
      await page.render({ canvasContext: ctx, viewport }).promise;
      updateCropOverlay(); // position crop overlay if modalState.crop present
      // populate crop input boxes
      if(modalState.crop){
        cropX.value = Math.round(modalState.crop.x);
        cropY.value = Math.round(modalState.crop.y);
        cropW.value = Math.round(modalState.crop.w);
        cropH.value = Math.round(modalState.crop.h);
      } else {
        cropX.value=''; cropY.value=''; cropW.value=''; cropH.value='';
      }
    }

    function closePreviewModal(){
      previewModal.style.display = 'none';
      previewModal.setAttribute('aria-hidden','true');
    }
    closePreview.addEventListener('click', closePreviewModal);

    rotateLeftBtn.addEventListener('click', ()=> {
      modalState.rotation = (modalState.rotation - 90) % 360;
      if(modalState.rotation < 0) modalState.rotation += 360;
      renderPreviewCanvas();
    });
    rotateRightBtn.addEventListener('click', ()=> {
      modalState.rotation = (modalState.rotation + 90) % 360;
      renderPreviewCanvas();
    });
    resetTransformBtn.addEventListener('click', ()=> {
      modalState.rotation = 0;
      modalState.crop = null;
      renderPreviewCanvas();
    });

    /* Crop overlay drawing (mouse-based)
       - User mousedown on canvas -> start point
       - mousemove -> update overlay rectangle
       - mouseup -> finalize crop region in canvas pixel coordinates
    */
    let isDrawing = false, startX = 0, startY = 0;
    previewCanvas.addEventListener('mousedown', (e) => {
      const rect = previewCanvas.getBoundingClientRect();
      isDrawing = true;
      startX = e.clientX - rect.left;
      startY = e.clientY - rect.top;
      cropOverlay.style.display = 'block';
      cropOverlay.style.left = `${startX + rect.left}px`;
      cropOverlay.style.top = `${startY + rect.top}px`;
      cropOverlay.style.width = '0px';
      cropOverlay.style.height = '0px';
    });
    window.addEventListener('mousemove', (e) => {
      if(!isDrawing) return;
      const rect = previewCanvas.getBoundingClientRect();
      const curX = e.clientX - rect.left;
      const curY = e.clientY - rect.top;
      const left = Math.min(startX, curX), top = Math.min(startY, curY);
      const w = Math.abs(curX - startX), h = Math.abs(curY - startY);
      cropOverlay.style.left = `${left + rect.left}px`;
      cropOverlay.style.top = `${top + rect.top}px`;
      cropOverlay.style.width = `${w}px`;
      cropOverlay.style.height = `${h}px`;
    });
    window.addEventListener('mouseup', (e) => {
      if(!isDrawing) return;
      isDrawing = false;
      const rect = previewCanvas.getBoundingClientRect();
      const overlayRect = cropOverlay.getBoundingClientRect();
      const x = overlayRect.left - rect.left;
      const y = overlayRect.top - rect.top;
      const w = overlayRect.width;
      const h = overlayRect.height;
      // clamp coordinates within canvas pixel dimensions
      const cx = Math.max(0, Math.min(previewCanvas.width, x));
      const cy = Math.max(0, Math.min(previewCanvas.height, y));
      const cw = Math.max(0, Math.min(previewCanvas.width - cx, w));
      const ch = Math.max(0, Math.min(previewCanvas.height - cy, h));
      modalState.crop = { x: cx, y: cy, w: cw, h: ch };
      cropX.value = Math.round(cx); cropY.value = Math.round(cy); cropW.value = Math.round(cw); cropH.value = Math.round(ch);
    });

    function updateCropOverlay(){
      if(!modalState.crop){ cropOverlay.style.display = 'none'; return; }
      const rect = previewCanvas.getBoundingClientRect();
      cropOverlay.style.display = 'block';
      cropOverlay.style.left = `${rect.left + modalState.crop.x}px`;
      cropOverlay.style.top = `${rect.top + modalState.crop.y}px`;
      cropOverlay.style.width = `${modalState.crop.w}px`;
      cropOverlay.style.height = `${modalState.crop.h}px`;
    }

    applyCropInputs.addEventListener('click', ()=> {
      const x = Number(cropX.value || 0), y = Number(cropY.value || 0), w = Number(cropW.value || 0), h = Number(cropH.value || 0);
      modalState.crop = { x, y, w, h };
      updateCropOverlay();
    });
    clearCropInputs.addEventListener('click', ()=> {
      modalState.crop = null; cropX.value=''; cropY.value=''; cropW.value=''; cropH.value=''; updateCropOverlay();
    });

    savePageTransform.addEventListener('click', ()=> {
      const idx = modalState.pageIndex;
      pdfData.pages[idx].rotation = modalState.rotation || 0;
      pdfData.pages[idx].crop = modalState.crop ? {...modalState.crop} : null;
      closePreviewModal();
      showStatus('Saved transform for page ' + (idx+1), false, 1400);
    });

    /* -------------------------
       RENDER PIPELINE FOR EXTRACTION
       - We render each page with pdf.js to a canvas (higher resolution),
       - apply rotation & crop on canvas,
       - convert canvas -> PNG blob -> embed into pdf-lib created page.
       - This produces image-based pages (raster). If you need vector output,
         see note in header comments (we can attempt pdf-lib page-copy fallback).
    */

    // Render a given page to a canvas using pdf.js (returns a canvas element)
    async function renderPageToCanvas(pdfjsDoc, pageIndex, scale=2.0, rotation=0){
      const page = await pdfjsDoc.getPage(pageIndex + 1);
      const viewport = page.getViewport({ scale, rotation });
      const canvas = document.createElement('canvas');
      canvas.width = Math.round(viewport.width);
      canvas.height = Math.round(viewport.height);
      const ctx = canvas.getContext('2d');
      await page.render({ canvasContext: ctx, viewport }).promise;
      return canvas;
    }

    // Apply crop & rotation transformations on a canvas and return a new canvas
    function applyCropAndRotationToCanvas(srcCanvas, rotation, crop){
      let source = srcCanvas;
      // If rotation is needed (90/180/270), rotate by drawing into a temporary canvas
      if(rotation % 360 !== 0){
        const angle = rotation % 360;
        const tmp = document.createElement('canvas');
        if(angle === 90 || angle === -270 || angle === 270 || angle === -90){
          tmp.width = source.height; tmp.height = source.width;
        } else {
          tmp.width = source.width; tmp.height = source.height;
        }
        const ctx = tmp.getContext('2d');
        ctx.save();
        if(angle === 90){ ctx.translate(tmp.width, 0); ctx.rotate(Math.PI/2); }
        else if(angle === 180){ ctx.translate(tmp.width, tmp.height); ctx.rotate(Math.PI); }
        else if(angle === 270){ ctx.translate(0, tmp.height); ctx.rotate(-Math.PI/2); }
        ctx.drawImage(source, 0, 0);
        ctx.restore();
        source = tmp;
      }
      // Crop if requested
      if(crop && crop.w > 0 && crop.h > 0){
        const c = document.createElement('canvas');
        c.width = Math.round(crop.w);
        c.height = Math.round(crop.h);
        const ctx = c.getContext('2d');
        ctx.drawImage(source, Math.round(crop.x), Math.round(crop.y), Math.round(crop.w), Math.round(crop.h), 0, 0, Math.round(crop.w), Math.round(crop.h));
        return c;
      } else {
        return source;
      }
    }

    /* -------------------------
       EXTRACTION: single PDF combining selected pages (image-embedding)
    */
    extractSelectedBtn.addEventListener('click', async () => {
      if(!pdfData) return;
      // determine selected pages in order
      let selected = Array.from(pdfData.selectedPages).sort((a,b)=>a-b);
      if(selected.length === 0){
        // default to all pages if nothing selected
        selected = Array.from({length: pdfData.pageCount}, (_,i)=>i);
      }
      showStatus('Extracting pages...', true);
      setProgress(0);
      try{
        const outPdf = await PDFLib.PDFDocument.create();
        const total = selected.length;
        for(let i=0;i<selected.length;i++){
          const pIdx = selected[i];
          const rot = pdfData.pages[pIdx].rotation || 0;
          const crop = pdfData.pages[pIdx].crop ? {...pdfData.pages[pIdx].crop} : null;
          // Render at a reasonable scale to preserve readability while controlling size
          const renderScale = 1.8;
          const rendered = await renderPageToCanvas(pdfData.pdfjsDoc, pIdx, renderScale, 0);
          const finalCanvas = applyCropAndRotationToCanvas(rendered, rot, crop);
          // convert canvas -> PNG blob
          const blob = await new Promise(res => finalCanvas.toBlob(res, 'image/png'));
          const arr = await blob.arrayBuffer();
          const img = await outPdf.embedPng(arr);
          const { width, height } = img.scale(1);
          const page = outPdf.addPage([width, height]);
          page.drawImage(img, { x:0, y:0, width, height });
          setProgress(((i+1)/total)*100);
          await new Promise(r=>setTimeout(r, 30)); // yield to UI
        }
        const bytes = await outPdf.save();
        triggerDownload(new Blob([bytes], { type: 'application/pdf' }), sanitize(pdfData.fileName).replace(/\.[^/.]+$/, '') + '_extracted.pdf');
        showStatus('Extraction complete ✓', false, 2000);
      } catch(err){
        console.error('Extraction error', err);
        showStatus('Extraction failed — see console', false);
      } finally { setTimeout(()=> resetProgress(), 800); }
    });

    /* -------------------------
       EXTRACTION: separate PDFs for each selected page, packaged in ZIP
    */
    extractZipBtn.addEventListener('click', async () => {
      if(!pdfData) return;
      let selected = Array.from(pdfData.selectedPages).sort((a,b)=>a-b);
      if(selected.length === 0) selected = Array.from({length: pdfData.pageCount}, (_,i)=>i);
      showStatus('Creating separate PDFs & ZIP...', true);
      setProgress(0);
      try{
        const zip = new JSZip();
        const total = selected.length;
        for(let i=0;i<selected.length;i++){
          const pIdx = selected[i];
          const rot = pdfData.pages[pIdx].rotation || 0;
          const crop = pdfData.pages[pIdx].crop ? {...pdfData.pages[pIdx].crop} : null;
          const renderScale = 1.8;
          const rendered = await renderPageToCanvas(pdfData.pdfjsDoc, pIdx, renderScale, 0);
          const finalCanvas = applyCropAndRotationToCanvas(rendered, rot, crop);
          const blob = await new Promise(res => finalCanvas.toBlob(res, 'image/png'));
          const arr = await blob.arrayBuffer();
          const outPdf = await PDFLib.PDFDocument.create();
          const img = await outPdf.embedPng(arr);
          const { width, height } = img.scale(1);
          const page = outPdf.addPage([width, height]);
          page.drawImage(img, { x:0, y:0, width, height });
          const bytes = await outPdf.save();
          zip.file(sanitize(pdfData.fileName).replace(/\.[^/.]+$/, '') + '_page_' + (pIdx+1) + '.pdf', bytes);
          setProgress(((i+1)/total)*100);
          await new Promise(r=>setTimeout(r, 20));
        }
        const blob = await zip.generateAsync({ type: 'blob' });
        triggerDownload(blob, sanitize(pdfData.fileName).replace(/\.[^/.]+$/, '') + '_pages.zip');
        showStatus('ZIP ready ✓', false, 1800);
      } catch(err){
        console.error('ZIP creation failed', err);
        showStatus('ZIP creation failed — see console', false);
      } finally { setTimeout(()=> resetProgress(), 800); }
    });

    /* -------------------------
       CLEAR / RESET UI
    */
    clearBtn.addEventListener('click', ()=> {
      if(pdfData && pdfData.pdfjsDoc) try{ pdfData.pdfjsDoc.destroy(); } catch(e){}
      pdfData = null;
      pagesDiv.innerHTML = '';
      rangeField.value = '';
      selectedCountEl.textContent = '0';
      extractSelectedBtn.disabled = true;
      extractZipBtn.disabled = true;
      clearBtn.disabled = true;
      resetProgress();
      showStatus('', false);
    });

    // Update button state helper
    function updateButtons(){
      const has = !!pdfData;
      extractSelectedBtn.disabled = !(has && pdfData.selectedPages.size>0);
      extractZipBtn.disabled = !(has && pdfData.selectedPages.size>0);
      clearBtn.disabled = !has;
      if(has) showStatus(pdfData.pageCount + ' pages loaded', false);
      else showStatus('', false);
    }

    /* -------------------------
       END: initial state
    */
    updateButtons();

    // expose for debugging
    window._sth_pdfData = () => pdfData;

  })();
  </script>
</body>
</html>
