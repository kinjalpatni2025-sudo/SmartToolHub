<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Split PDF — Preview, Password Unlock, Rotate & Crop — Smarttool Hub</title>
<meta name="description" content="Split PDF pages with thumbnail preview, password unlock, large preview modal, rotate and crop pages before extraction. 100% client-side." />
<link rel="icon" href="https://img.icons8.com/fluency/48/toolbox.png" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css"/>
<style>
:root{--bg:#0b1220;--text:#eaf2ff;--card:#182335;--border:#2a3b55;--primary:#22d3ee;--muted:#9fb3c8}
body.light{--bg:#f6f8fb;--text:#0b1220;--card:#fff;--border:#e6eefc;--primary:#0b74ff;--muted:#556677}
*{box-sizing:border-box}
body{margin:0;font-family:Inter,system-ui,Arial;background:var(--bg);color:var(--text);transition:.22s}
.container{max-width:1100px;margin:0 auto;padding:18px}
header{display:flex;justify-content:space-between;align-items:center;background:var(--card);padding:12px;border-bottom:1px solid var(--border)}
.brand a{display:flex;gap:12px;align-items:center;text-decoration:none;color:inherit}
.brand img{width:46px;height:46px;border-radius:8px}
.title{font-weight:700;color:var(--primary)}
.tag{font-size:.85rem;color:var(--muted)}
.header-actions{display:flex;gap:8px;align-items:center}
.btn-header{border:1px solid var(--border);background:transparent;padding:8px 12px;border-radius:8px;color:var(--text);cursor:pointer;display:flex;gap:8px;align-items:center;text-decoration:none;font-weight:600}
main{padding:18px 0}
h1{margin:6px 0 8px;color:var(--primary)}
.meta{color:var(--muted);margin-bottom:12px}
.uploader{min-height:110px;border-radius:12px;border:2px dashed var(--border);display:flex;flex-direction:column;align-items:center;justify-content:center;padding:18px;background:var(--card);cursor:pointer}
.uploader:hover{border-color:var(--primary)}
input[type=file]{display:none}
.controls{display:flex;gap:12px;align-items:center;margin-top:12px;flex-wrap:wrap}
.controls input[type=text]{padding:8px;border-radius:8px;border:1px solid var(--border);background:transparent;color:var(--text)}
.progress{height:12px;background:var(--border);border-radius:999px;overflow:hidden;margin-top:12px}
.progress-bar{height:100%;width:0;background:var(--primary);transition:width .2s}
.pages{margin-top:18px;display:flex;flex-wrap:wrap;gap:12px;max-height:420px;overflow:auto;padding:8px}
.page-card{width:110px;background:var(--card);border:1px solid var(--border);border-radius:8px;padding:8px;display:flex;flex-direction:column;align-items:center;gap:8px;cursor:pointer}
.page-card canvas{width:96px;height:auto;background:#fff;border-radius:6px}
.page-label{font-size:.85rem;color:var(--muted);text-align:center}
.actions{margin-top:12px;display:flex;gap:10px;flex-wrap:wrap}
.btn{padding:10px 14px;border-radius:10px;border:none;cursor:pointer;font-weight:700}
.btn-primary{background:var(--primary);color:#00131f}
.btn-ghost{background:transparent;border:1px solid var(--border);color:var(--text)}
.status{color:var(--muted);display:flex;align-items:center;gap:8px}
.spinner{width:18px;height:18px;border-radius:50%;border:3px solid rgba(255,255,255,0.08);border-top-color:var(--primary);animation:spin .9s linear infinite}
@keyframes spin{to{transform:rotate(360deg)}}

/* Modal for larger preview + crop UI */
.modal { position:fixed; left:0; top:0; right:0; bottom:0; background:rgba(0,0,0,0.6); display:none; align-items:center; justify-content:center; z-index:9999; }
.modal .card { width:90%; max-width:1100px; background:var(--card); padding:16px; border-radius:12px; border:1px solid var(--border); display:flex; gap:12px; color:var(--text); }
.modal .left { flex:1; display:flex; flex-direction:column; gap:10px; align-items:center; justify-content:center; overflow:auto; }
.modal canvas { background:#fff; border-radius:6px; max-width:100%; height:auto; }
.modal .right { width:320px; display:flex; flex-direction:column; gap:10px; }
.small { padding:6px 8px; font-size:.9rem; border-radius:8px; border:1px solid var(--border); background:transparent; color:var(--text); }

/* Crop rectangle overlay */
.crop-overlay { position:absolute; border:2px dashed var(--primary); pointer-events:none; }

footer{margin-top:24px;padding:12px 0;background:var(--card);border-top:1px solid var(--border)}
@media(max-width:820px){.controls{flex-direction:column;align-items:flex-start}.page-card{width:32%}.modal .card{flex-direction:column}.modal .right{width:100%}}
</style>
</head>
<body>
<header class="container">
  <div class="brand">
    <a href="../../index.html" title="Smarttool Hub home">
      <img src="https://img.icons8.com/fluency/48/toolbox.png" alt="Smarttool Hub logo">
      <div>
        <div class="title">Smarttool Hub</div>
        <div class="tag">Fast • Private • Client-side</div>
      </div>
    </a>
  </div>
  <div class="header-actions">
    <a href="../../index.html" class="btn-header"><i class="fa-solid fa-house"></i> Home</a>
    <button id="themeToggle" class="btn-header" title="Toggle theme"><i class="fa-solid fa-moon"></i></button>
  </div>
</header>

<main class="container">
  <h1>Split PDF — Preview, Password Unlock, Rotate & Crop</h1>
  <p class="meta">Upload a PDF, preview thumbnails, open larger preview to rotate and crop pages, then extract selected pages as a new PDF or separate PDFs (ZIP). If the PDF is password-protected you'll be prompted to enter the password (client-side).</p>

  <label class="uploader" id="uploader">
    <div style="font-size:28px;color:var(--primary)"><i class="fa-solid fa-file-pdf"></i></div>
    <div style="margin-top:8px;font-weight:700">Click or drag & drop a PDF</div>
    <div style="margin-top:6px;color:var(--muted)">Supported: .pdf — single file at a time.</div>
    <input type="file" id="fileInput" accept="application/pdf" />
  </label>

  <div class="controls" role="region" aria-label="split controls">
    <input type="text" id="rangeField" placeholder="Type ranges e.g. 1-3,5 (optional)" class="small">
    <button id="applyRangeBtn" class="btn btn-ghost small">Apply Range</button>
    <button id="selectAllBtn" class="btn btn-ghost small">Select all</button>
    <button id="deselectAllBtn" class="btn btn-ghost small">Deselect all</button>
    <div style="margin-left:auto;color:var(--muted)">Selected: <span id="selectedCount">0</span></div>
  </div>

  <div class="progress" aria-hidden="true"><div class="progress-bar" id="progressBar"></div></div>

  <div class="pages" id="pages" aria-live="polite"></div>

  <div class="actions">
    <button id="extractSelectedBtn" class="btn btn-primary" disabled><i class="fa-solid fa-file-arrow-down"></i> Extract selected → single PDF</button>
    <button id="extractZipBtn" class="btn btn-ghost" disabled><i class="fa-solid fa-file-zipper"></i> Extract selected → separate PDFs (ZIP)</button>
    <button id="clearBtn" class="btn btn-ghost" disabled><i class="fa-solid fa-trash-can"></i> Clear</button>
    <div class="status" id="status"></div>
  </div>
</main>

<footer class="container">
  <div>© <span id="year"></span> Smarttool Hub</div>
  <div style="color:var(--muted)">Privacy • Terms • Contact</div>
</footer>

<!-- Password prompt modal -->
<div id="passwordModal" class="modal" aria-hidden="true">
  <div class="card">
    <div style="flex:1">
      <h3>Enter PDF password</h3>
      <p style="color:var(--muted)">This PDF is password-protected. Enter the password to decrypt it (client-side).</p>
      <input id="pwdInput" type="password" class="small" placeholder="Password" style="width:100%;margin-top:8px">
      <div style="margin-top:12px;display:flex;gap:8px;">
        <button id="pwdSubmit" class="btn btn-primary">Unlock</button>
        <button id="pwdCancel" class="btn btn-ghost">Cancel</button>
      </div>
      <div id="pwdMsg" style="color:var(--muted);margin-top:8px"></div>
    </div>
  </div>
</div>

<!-- Larger preview modal with crop/rotate -->
<div id="previewModal" class="modal" aria-hidden="true">
  <div class="card">
    <div class="left">
      <div style="position:relative;">
        <canvas id="previewCanvas"></canvas>
        <div id="cropOverlay" class="crop-overlay" style="display:none"></div>
      </div>
      <div style="font-size:.9rem;color:var(--muted)">Drag to draw crop box. Use rotate buttons to rotate preview. Click Save to apply changes to this page.</div>
    </div>
    <div class="right">
      <div style="display:flex;gap:8px;">
        <button id="rotateLeft" class="btn btn-ghost small">⟲ Rotate Left</button>
        <button id="rotateRight" class="btn btn-ghost small">⟳ Rotate Right</button>
        <button id="resetTransform" class="btn btn-ghost small">Reset</button>
      </div>

      <div style="margin-top:8px">
        <label style="color:var(--muted)">Crop preset (px)</label>
        <div style="display:flex;gap:6px;margin-top:6px">
          <input id="cropX" class="small" placeholder="x" />
          <input id="cropY" class="small" placeholder="y" />
          <input id="cropW" class="small" placeholder="w" />
          <input id="cropH" class="small" placeholder="h" />
        </div>
        <div style="display:flex;gap:6px;margin-top:8px">
          <button id="applyCropInputs" class="btn btn-ghost small">Apply crop</button>
          <button id="clearCropInputs" class="btn btn-ghost small">Clear crop</button>
        </div>
      </div>

      <div style="margin-top:12px">
        <button id="savePageTransform" class="btn btn-primary small" style="width:100%">Save (apply to this page)</button>
        <button id="closePreview" class="btn btn-ghost small" style="width:100%;margin-top:8px">Close</button>
      </div>
    </div>
  </div>
</div>

<!-- JSON-LD FAQ -->
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"FAQPage","mainEntity":[{"@type":"Question","name":"How to extract pages from protected PDFs?","acceptedAnswer":{"@type":"Answer","text":"If the PDF is password-protected you will be prompted for the password. The password is used client-side to decrypt and preview pages. It is not uploaded."}}]}
</script>

<!-- libs -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
<script>pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';</script>
<script src="https://unpkg.com/pdf-lib/dist/pdf-lib.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

<script>
(async function(){
  // ---------- theme + year ----------
  const themeBtn = document.getElementById('themeToggle');
  if(localStorage.getItem('sth_theme') === 'light'){ document.body.classList.add('light'); themeBtn.innerHTML = '<i class="fa-solid fa-sun"></i>'; }
  themeBtn.addEventListener('click', ()=> {
    document.body.classList.toggle('light');
    if(document.body.classList.contains('light')){ themeBtn.innerHTML = '<i class="fa-solid fa-sun"></i>'; localStorage.setItem('sth_theme','light'); }
    else { themeBtn.innerHTML = '<i class="fa-solid fa-moon"></i>'; localStorage.removeItem('sth_theme'); }
  });
  document.getElementById('year').textContent = new Date().getFullYear();

  // ---------- refs ----------
  const uploader = document.getElementById('uploader');
  const fileInput = document.getElementById('fileInput');
  const pagesDiv = document.getElementById('pages');
  const progressBar = document.getElementById('progressBar');
  const statusEl = document.getElementById('status');

  const rangeField = document.getElementById('rangeField');
  const applyRangeBtn = document.getElementById('applyRangeBtn');
  const selectAllBtn = document.getElementById('selectAllBtn');
  const deselectAllBtn = document.getElementById('deselectAllBtn');
  const selectedCountEl = document.getElementById('selectedCount');

  const extractSelectedBtn = document.getElementById('extractSelectedBtn');
  const extractZipBtn = document.getElementById('extractZipBtn');
  const clearBtn = document.getElementById('clearBtn');

  // password modal refs
  const pwdModal = document.getElementById('passwordModal');
  const pwdInput = document.getElementById('pwdInput');
  const pwdSubmit = document.getElementById('pwdSubmit');
  const pwdCancel = document.getElementById('pwdCancel');
  const pwdMsg = document.getElementById('pwdMsg');

  // preview modal refs
  const previewModal = document.getElementById('previewModal');
  const previewCanvas = document.getElementById('previewCanvas');
  const cropOverlay = document.getElementById('cropOverlay');
  const rotateLeftBtn = document.getElementById('rotateLeft');
  const rotateRightBtn = document.getElementById('rotateRight');
  const resetTransformBtn = document.getElementById('resetTransform');
  const cropX = document.getElementById('cropX');
  const cropY = document.getElementById('cropY');
  const cropW = document.getElementById('cropW');
  const cropH = document.getElementById('cropH');
  const applyCropInputs = document.getElementById('applyCropInputs');
  const clearCropInputs = document.getElementById('clearCropInputs');
  const savePageTransform = document.getElementById('savePageTransform');
  const closePreview = document.getElementById('closePreview');

  // ---------- state ----------
  // pdfData: { arrayBuffer, pdfjsDoc, pageCount, selectedPages:Set, fileName, pages:[{ rotation:0, crop:null }] }
  let pdfData = null;
  // preview modal working state
  let modalState = { pageIndex: 0, rotation: 0, crop: null, baseRenderScale:1.2 };

  // ---------- helpers ----------
  function showStatus(txt, busy=false, hideMs=0){
    statusEl.textContent = txt || '';
    if(busy) statusEl.insertAdjacentHTML('afterbegin','<span class="spinner" aria-hidden="true"></span>');
    if(hideMs) setTimeout(()=> statusEl.textContent = '', hideMs);
  }
  function setProgress(p){ progressBar.style.width = Math.min(100,Math.max(0,Math.round(p))) + '%'; }
  function resetProgress(){ progressBar.style.width = '0%'; }
  function sanitize(name){ return name.replace(/[^a-z0-9_\-\.]/gi, '_'); }
  function triggerDownload(blob, filename){
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(()=> URL.revokeObjectURL(a.href), 3000);
  }
  function escapeHtml(s){ return String(s).replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }

  // ---------- file handlers ----------
  uploader.addEventListener('click', ()=> fileInput.click());
  uploader.addEventListener('dragover', e => { e.preventDefault(); uploader.style.borderColor = 'var(--primary)'; });
  uploader.addEventListener('dragleave', e => { uploader.style.borderColor = ''; });
  uploader.addEventListener('drop', e => { e.preventDefault(); uploader.style.borderColor = ''; handleFile(e.dataTransfer.files[0]); });
  fileInput.addEventListener('change', e => handleFile(e.target.files[0]));

  async function handleFile(file){
    if(!file) return;
    if(!(file.type === 'application/pdf' || file.name.toLowerCase().endsWith('.pdf'))){
      alert('Please select a PDF file.');
      return;
    }
    showStatus('Loading PDF...', true);
    resetProgress();
    try{
      const buffer = await file.arrayBuffer();
      // attempt to load with pdf.js; handle password-protected
      let pdfjsDoc = null;
      try {
        pdfjsDoc = await pdfjsLib.getDocument({ data: buffer }).promise;
      } catch(err){
        // if password required, prompt
        if(err && (err.name === 'PasswordException' || /password/i.test(String(err.message || err)))){
          const pw = await askPasswordForPdf();
          if(pw === null){ showStatus('Password entry cancelled', false); return; }
          try {
            pdfjsDoc = await pdfjsLib.getDocument({ data: buffer, password: pw }).promise;
          } catch(err2){
            console.error('Password failed', err2);
            showStatus('Password incorrect or PDF cannot be opened', false);
            return;
          }
        } else {
          console.error('pdf.js open failed', err);
          showStatus('Failed to open PDF — see console', false);
          return;
        }
      }
      const pageCount = pdfjsDoc.numPages;
      // initialize per-page transform state
      const pages = Array.from({length: pageCount}, ()=> ({ rotation: 0, crop: null }));
      pdfData = { arrayBuffer: buffer, pdfjsDoc, pageCount, selectedPages: new Set(Array.from({length: pageCount}, (_,i)=>i)), fileName: file.name, pages };
      renderPagesThumbnails();
      updateButtons();
      showStatus('Loaded: ' + pageCount + ' pages', false, 2000);
    } catch(err){
      console.error('Failed to load file', err);
      showStatus('Failed to load PDF — see console', false);
    }
  }

  // password modal helper
  function askPasswordForPdf(){
    return new Promise((resolve) => {
      pwdInput.value = '';
      pwdMsg.textContent = '';
      pwdModal.style.display = 'flex';
      pwdModal.removeAttribute('aria-hidden');
      pwdInput.focus();
      const onSubmit = () => { const val = pwdInput.value || ''; closePwd(); resolve(val); };
      const onCancel = () => { closePwd(); resolve(null); };
      function closePwd(){ pwdModal.style.display = 'none'; pwdModal.setAttribute('aria-hidden', 'true'); pwdSubmit.removeEventListener('click', onSubmit); pwdCancel.removeEventListener('click', onCancel); }
      pwdSubmit.addEventListener('click', onSubmit);
      pwdCancel.addEventListener('click', onCancel);
    });
  }

  // ---------- render thumbnails ----------
  async function renderPagesThumbnails(){
    pagesDiv.innerHTML = '';
    if(!pdfData) return;
    for(let p=1;p<=pdfData.pageCount;p++){
      try{
        const page = await pdfData.pdfjsDoc.getPage(p);
        const viewport = page.getViewport({ scale: 0.15 });
        const canvas = document.createElement('canvas');
        canvas.width = Math.round(viewport.width);
        canvas.height = Math.round(viewport.height);
        const ctx = canvas.getContext('2d');
        await page.render({ canvasContext: ctx, viewport }).promise;
        const card = document.createElement('div');
        card.className = 'page-card';
        card.dataset.page = p-1;
        card.innerHTML = `<canvas></canvas><div class="page-label">Page ${p}</div>`;
        card.querySelector('canvas').width = canvas.width;
        card.querySelector('canvas').height = canvas.height;
        card.querySelector('canvas').getContext('2d').drawImage(canvas,0,0);
        card.addEventListener('click', () => openPreviewModal(p-1));
        pagesDiv.appendChild(card);
      } catch(err){
        console.warn('Thumb render failed for page', p, err);
      }
    }
    updateSelectedCount();
  }

  // ---------- selection & range ----------
  function updateSelectedCount(){
    if(!pdfData){ selectedCountEl.textContent = '0'; return; }
    selectedCountEl.textContent = pdfData.selectedPages.size;
    extractSelectedBtn.disabled = pdfData.selectedPages.size === 0;
    extractZipBtn.disabled = pdfData.selectedPages.size === 0;
    clearBtn.disabled = false;
  }

  selectAllBtn.addEventListener('click', ()=> {
    if(!pdfData) return;
    pdfData.selectedPages = new Set(Array.from({length: pdfData.pageCount}, (_,i)=>i));
    // checkboxes are not rendered here; updateSelectedCount is enough
    updateSelectedCount();
  });
  deselectAllBtn.addEventListener('click', ()=> {
    if(!pdfData) return;
    pdfData.selectedPages.clear();
    updateSelectedCount();
  });

  applyRangeBtn.addEventListener('click', ()=> {
    if(!pdfData) return;
    const txt = rangeField.value.trim();
    if(!txt) return;
    const arr = parseRange(txt, pdfData.pageCount);
    pdfData.selectedPages = new Set(arr);
    updateSelectedCount();
  });

  function parseRange(str, pageCount){
    const tokens = str.split(',').map(s=>s.trim()).filter(Boolean);
    const out = new Set();
    tokens.forEach(t=>{
      if(t.includes('-')){
        const [a,b] = t.split('-').map(x=>parseInt(x,10));
        if(isNaN(a)||isNaN(b)) return;
        const start = Math.max(1, Math.min(a,b));
        const end = Math.min(pageCount, Math.max(a,b));
        for(let i=start;i<=end;i++) out.add(i-1);
      } else {
        const n = parseInt(t,10);
        if(!isNaN(n) && n>=1 && n<=pageCount) out.add(n-1);
      }
    });
    return Array.from(out).sort((a,b)=>a-b);
  }

  // ---------- preview modal (rotate/crop) ----------
  function openPreviewModal(pageIndex){
    if(!pdfData) return;
    modalState.pageIndex = pageIndex;
    modalState.rotation = pdfData.pages[pageIndex].rotation || 0;
    modalState.crop = pdfData.pages[pageIndex].crop ? {...pdfData.pages[pageIndex].crop} : null;
    previewModal.style.display = 'flex'; previewModal.removeAttribute('aria-hidden');
    renderPreviewCanvas();
  }

  async function renderPreviewCanvas(){
    const pIdx = modalState.pageIndex;
    const pageNum = pIdx + 1;
    const page = await pdfData.pdfjsDoc.getPage(pageNum);
    // choose scale for modal preview (bigger)
    const scale = modalState.baseRenderScale || 1.2;
    const viewport = page.getViewport({ scale, rotation: modalState.rotation });
    // create large canvas
    const canvas = previewCanvas;
    canvas.width = Math.round(viewport.width);
    canvas.height = Math.round(viewport.height);
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0,0,canvas.width,canvas.height);
    await page.render({ canvasContext: ctx, viewport }).promise;
    // apply crop overlay if exists
    updateCropOverlay();
    // populate crop input fields if any
    if(modalState.crop){
      cropX.value = Math.round(modalState.crop.x);
      cropY.value = Math.round(modalState.crop.y);
      cropW.value = Math.round(modalState.crop.w);
      cropH.value = Math.round(modalState.crop.h);
    } else { cropX.value=''; cropY.value=''; cropW.value=''; cropH.value=''; }
  }

  function closePreviewModal(){
    previewModal.style.display = 'none'; previewModal.setAttribute('aria-hidden','true');
  }
  closePreview.addEventListener('click', closePreviewModal);

  rotateLeftBtn.addEventListener('click', ()=> {
    modalState.rotation = (modalState.rotation - 90) % 360;
    if(modalState.rotation < 0) modalState.rotation += 360;
    renderPreviewCanvas();
  });
  rotateRightBtn.addEventListener('click', ()=> {
    modalState.rotation = (modalState.rotation + 90) % 360;
    renderPreviewCanvas();
  });
  resetTransformBtn.addEventListener('click', ()=> {
    modalState.rotation = 0;
    modalState.crop = null;
    renderPreviewCanvas();
  });

  // crop overlay drawing (mouse)
  let isDrawing = false, startX=0, startY=0;
  previewCanvas.addEventListener('mousedown', (e) => {
    const rect = previewCanvas.getBoundingClientRect();
    isDrawing = true;
    startX = e.clientX - rect.left;
    startY = e.clientY - rect.top;
    cropOverlay.style.display = 'block';
    cropOverlay.style.left = `${startX + rect.left}px`;
    cropOverlay.style.top = `${startY + rect.top}px`;
    cropOverlay.style.width = '0px';
    cropOverlay.style.height = '0px';
  });
  window.addEventListener('mousemove', (e) => {
    if(!isDrawing) return;
    const rect = previewCanvas.getBoundingClientRect();
    const curX = e.clientX - rect.left;
    const curY = e.clientY - rect.top;
    const left = Math.min(startX, curX), top = Math.min(startY, curY);
    const w = Math.abs(curX - startX), h = Math.abs(curY - startY);
    cropOverlay.style.left = `${left + rect.left}px`;
    cropOverlay.style.top = `${top + rect.top}px`;
    cropOverlay.style.width = `${w}px`;
    cropOverlay.style.height = `${h}px`;
  });
  window.addEventListener('mouseup', (e) => {
    if(!isDrawing) return;
    isDrawing = false;
    const rect = previewCanvas.getBoundingClientRect();
    const overlayRect = cropOverlay.getBoundingClientRect();
    // calculate crop relative to canvas pixel coords
    const x = overlayRect.left - rect.left;
    const y = overlayRect.top - rect.top;
    const w = overlayRect.width;
    const h = overlayRect.height;
    // clamp
    const cx = Math.max(0, Math.min(previewCanvas.width, x));
    const cy = Math.max(0, Math.min(previewCanvas.height, y));
    const cw = Math.max(0, Math.min(previewCanvas.width - cx, w));
    const ch = Math.max(0, Math.min(previewCanvas.height - cy, h));
    modalState.crop = { x: cx, y: cy, w: cw, h: ch };
    cropX.value = Math.round(cx); cropY.value = Math.round(cy); cropW.value = Math.round(cw); cropH.value = Math.round(ch);
  });

  function updateCropOverlay(){
    if(!modalState.crop){
      cropOverlay.style.display = 'none';
      return;
    }
    const rect = previewCanvas.getBoundingClientRect();
    cropOverlay.style.display = 'block';
    cropOverlay.style.left = `${rect.left + modalState.crop.x}px`;
    cropOverlay.style.top = `${rect.top + modalState.crop.y}px`;
    cropOverlay.style.width = `${modalState.crop.w}px`;
    cropOverlay.style.height = `${modalState.crop.h}px`;
  }

  applyCropInputs.addEventListener('click', ()=> {
    const x = Number(cropX.value || 0), y = Number(cropY.value || 0), w = Number(cropW.value || 0), h = Number(cropH.value || 0);
    modalState.crop = { x, y, w, h };
    updateCropOverlay();
  });
  clearCropInputs.addEventListener('click', ()=> {
    modalState.crop = null; cropX.value=''; cropY.value=''; cropW.value=''; cropH.value=''; updateCropOverlay();
  });

  savePageTransform.addEventListener('click', ()=> {
    const idx = modalState.pageIndex;
    pdfData.pages[idx].rotation = modalState.rotation || 0;
    pdfData.pages[idx].crop = modalState.crop ? {...modalState.crop} : null;
    closePreviewModal();
    showStatus('Saved transform for page ' + (idx+1), false, 1400);
  });

  // ---------- extraction using rendering pipeline ----------
  // helper to render a page to a canvas at given scale/rotation and return canvas
  async function renderPageToCanvas(pdfjsDoc, pageIndex, scale=2.0, rotation=0){
    const page = await pdfjsDoc.getPage(pageIndex + 1);
    const viewport = page.getViewport({ scale, rotation });
    const canvas = document.createElement('canvas');
    canvas.width = Math.round(viewport.width);
    canvas.height = Math.round(viewport.height);
    const ctx = canvas.getContext('2d');
    await page.render({ canvasContext: ctx, viewport }).promise;
    return canvas;
  }

  // apply crop & rotate to a rendered canvas and return a canvas
  function applyCropAndRotationToCanvas(srcCanvas, rotation, crop){
    // rotation is degrees (0,90,180,270); crop given in srcCanvas px coordinates
    let source = srcCanvas;
    // if rotation provided, rotate canvas first
    if(rotation % 360 !== 0){
      const angle = rotation % 360;
      const tmp = document.createElement('canvas');
      if(angle === 90 || angle === -270){ tmp.width = source.height; tmp.height = source.width; }
      else if(angle === 270 || angle === -90){ tmp.width = source.height; tmp.height = source.width; }
      else { tmp.width = source.width; tmp.height = source.height; }
      const ctx = tmp.getContext('2d');
      ctx.save();
      if(angle === 90){ ctx.translate(tmp.width, 0); ctx.rotate(Math.PI/2); }
      else if(angle === 180){ ctx.translate(tmp.width, tmp.height); ctx.rotate(Math.PI); }
      else if(angle === 270){ ctx.translate(0, tmp.height); ctx.rotate(-Math.PI/2); }
      ctx.drawImage(source, 0, 0);
      ctx.restore();
      source = tmp;
    }
    // apply crop if provided
    if(crop && crop.w > 0 && crop.h > 0){
      const c = document.createElement('canvas');
      c.width = Math.round(crop.w);
      c.height = Math.round(crop.h);
      const ctx = c.getContext('2d');
      ctx.drawImage(source, Math.round(crop.x), Math.round(crop.y), Math.round(crop.w), Math.round(crop.h), 0, 0, Math.round(crop.w), Math.round(crop.h));
      return c;
    } else {
      return source;
    }
  }

  // combine selected pages into a single PDF (raster-based embedding via canvas images)
  extractSelectedBtn.addEventListener('click', async () => {
    if(!pdfData) return;
    // compute selected pages list (in order)
    let selected = Array.from(pdfData.selectedPages).sort((a,b)=>a-b);
    if(selected.length === 0){
      // default to all pages
      selected = Array.from({length: pdfData.pageCount}, (_,i)=>i);
    }
    showStatus('Extracting pages...', true);
    setProgress(0);
    try{
      const outPdf = await PDFLib.PDFDocument.create();
      const total = selected.length;
      for(let i=0;i<selected.length;i++){
        const pIdx = selected[i];
        // use per-page rotation and crop stored earlier
        const rot = pdfData.pages[pIdx].rotation || 0;
        const crop = pdfData.pages[pIdx].crop ? {...pdfData.pages[pIdx].crop} : null;
        // render at reasonable scale depending on page size — choose scale so resulting PDF looks crisp but not huge
        const renderScale = 1.8; // tweak if needed
        const rendered = await renderPageToCanvas(pdfData.pdfjsDoc, pIdx, renderScale, 0); // render original orientation, handle rotation via transform
        const finalCanvas = applyCropAndRotationToCanvas(rendered, rot, crop);
        // convert canvas to blob (PNG) and embed into pdf-lib
        const blob = await new Promise(res => finalCanvas.toBlob(res, 'image/png'));
        const arr = await blob.arrayBuffer();
        const img = await outPdf.embedPng(arr);
        const { width, height } = img.scale(1);
        const page = outPdf.addPage([width, height]);
        page.drawImage(img, { x:0, y:0, width, height });
        setProgress(((i+1)/total)*100);
        await new Promise(r=>setTimeout(r, 30));
      }
      const bytes = await outPdf.save();
      triggerDownload(new Blob([bytes], { type: 'application/pdf' }), sanitize(pdfData.fileName).replace(/\.[^/.]+$/, '') + '_extracted.pdf');
      showStatus('Extraction complete ✓', false, 2000);
    } catch(err){
      console.error('Extraction error', err);
      showStatus('Extraction failed — see console', false);
    } finally { setTimeout(()=> resetProgress(), 800); }
  });

  // extract selected pages as separate PDFs inside ZIP (raster-based)
  extractZipBtn.addEventListener('click', async () => {
    if(!pdfData) return;
    let selected = Array.from(pdfData.selectedPages).sort((a,b)=>a-b);
    if(selected.length === 0) selected = Array.from({length: pdfData.pageCount}, (_,i)=>i);
    showStatus('Creating separate PDFs & ZIP...', true);
    setProgress(0);
    try{
      const zip = new JSZip();
      const total = selected.length;
      for(let i=0;i<selected.length;i++){
        const pIdx = selected[i];
        const rot = pdfData.pages[pIdx].rotation || 0;
        const crop = pdfData.pages[pIdx].crop ? {...pdfData.pages[pIdx].crop} : null;
        const renderScale = 1.8;
        const rendered = await renderPageToCanvas(pdfData.pdfjsDoc, pIdx, renderScale, 0);
        const finalCanvas = applyCropAndRotationToCanvas(rendered, rot, crop);
        const blob = await new Promise(res => finalCanvas.toBlob(res, 'image/png'));
        const arr = await blob.arrayBuffer();
        const outPdf = await PDFLib.PDFDocument.create();
        const img = await outPdf.embedPng(arr);
        const { width, height } = img.scale(1);
        const page = outPdf.addPage([width,height]);
        page.drawImage(img, { x:0, y:0, width, height });
        const bytes = await outPdf.save();
        zip.file(sanitize(pdfData.fileName).replace(/\.[^/.]+$/, '') + '_page_' + (pIdx+1) + '.pdf', bytes);
        setProgress(((i+1)/total)*100);
        await new Promise(r=>setTimeout(r, 20));
      }
      const blob = await zip.generateAsync({ type: 'blob' });
      triggerDownload(blob, sanitize(pdfData.fileName).replace(/\.[^/.]+$/, '') + '_pages.zip');
      showStatus('ZIP ready ✓', false, 1800);
    } catch(err){
      console.error('ZIP creation failed', err);
      showStatus('ZIP creation failed — see console', false);
    } finally { setTimeout(()=> resetProgress(), 800); }
  });

  // ---------- clear ----------
  clearBtn.addEventListener('click', ()=> {
    if(pdfData && pdfData.pdfjsDoc) try{ pdfData.pdfjsDoc.destroy(); } catch(e){}
    pdfData = null;
    pagesDiv.innerHTML = '';
    rangeField.value = '';
    selectedCountEl.textContent = '0';
    extractSelectedBtn.disabled = true;
    extractZipBtn.disabled = true;
    clearBtn.disabled = true;
    resetProgress();
    showStatus('', false);
  });

  // ---------- helper UI updates ----------
  function updateButtons(){
    const has = !!pdfData;
    extractSelectedBtn.disabled = !(has && pdfData.selectedPages.size>0);
    extractZipBtn.disabled = !(has && pdfData.selectedPages.size>0);
    clearBtn.disabled = !has;
    if(has) showStatus(pdfData.pageCount + ' pages loaded', false);
    else showStatus('', false);
  }

  // ---------- expose modal open for page click (we need to update selectedPages when toggling) ----------
  // modify page-card click previously -> here add checkbox behavior: on clicking thumbnail, open modal and also toggle selection if Ctrl or Shift used
  // But simpler: thumbnails open modal only; selection controlled via range/select/deselect

  // add a small checkbox overlay to thumbnails to toggle selection
  // Re-render pages with selection overlay
  async function renderPagesThumbnails(){
    pagesDiv.innerHTML = '';
    if(!pdfData) return;
    for(let p=1;p<=pdfData.pageCount;p++){
      try{
        const page = await pdfData.pdfjsDoc.getPage(p);
        const viewport = page.getViewport({ scale: 0.15 });
        const canvas = document.createElement('canvas');
        canvas.width = Math.round(viewport.width);
        canvas.height = Math.round(viewport.height);
        const ctx = canvas.getContext('2d');
        await page.render({ canvasContext: ctx, viewport }).promise;
        const card = document.createElement('div');
        card.className = 'page-card';
        card.dataset.page = p-1;
        // checkbox html & thumbnail
        card.innerHTML = `
          <div style="position:relative;">
            <label style="position:absolute;left:6px;top:6px;z-index:5;">
              <input type="checkbox" class="page-select" data-page="${p-1}" ${pdfData.selectedPages.has(p-1) ? 'checked' : ''}>
            </label>
            <canvas></canvas>
          </div>
          <div class="page-label">Page ${p}</div>
        `;
        card.querySelector('canvas').width = canvas.width;
        card.querySelector('canvas').height = canvas.height;
        card.querySelector('canvas').getContext('2d').drawImage(canvas,0,0);
        // click canvas to open preview modal
        card.querySelector('canvas').addEventListener('click', (ev) => {
          // avoid click when checkbox clicked
          openPreviewModal(p-1);
        });
        // checkbox handler
        card.querySelector('.page-select').addEventListener('change', (ev) => {
          const idx = Number(ev.target.dataset.page);
          if(ev.target.checked) pdfData.selectedPages.add(idx);
          else pdfData.selectedPages.delete(idx);
          updateSelectedCount();
        });
        pagesDiv.appendChild(card);
      } catch(err){
        console.warn('Thumb render failed for page', p, err);
      }
    }
    updateSelectedCount();
    updateButtons();
  }

  // ensure re-render initial if pdfData loaded earlier
  if(pdfData) renderPagesThumbnails();

  // ---------- end ----------
})();
</script>
</body>
</html>
