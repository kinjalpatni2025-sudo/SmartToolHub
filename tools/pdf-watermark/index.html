<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Delete PDF Pages — Smarttool Hub</title>
  <link rel="icon" href="https://img.icons8.com/fluency/48/toolbox.png"/>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css"/>
  <style>
    :root{
      --bg:#0b1220;--text:#eaf2ff;--card:#182335;--border:#2a3b55;
      --primary:#22d3ee;--muted:#9fb3c8;--radius:12px;
    }
    body.light{
      --bg:#f6f8fb;--text:#0b1220;--card:#ffffff;--border:#e6eefc;
      --primary:#0b74ff;--muted:#556677;
    }
    *{box-sizing:border-box}
    body{
      margin:0;font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial;
      background:var(--bg);color:var(--text);transition:background .18s,color .18s;min-height:100vh;display:flex;flex-direction:column;
    }
    .container{max-width:1200px;margin:0 auto;padding:20px;width:100%}
    header{display:flex;align-items:center;justify-content:space-between;background:var(--card);border-bottom:1px solid var(--border);padding:12px 20px;border-radius:10px}
    .brand{display:flex;align-items:center;gap:12px}
    .brand img{width:46px;height:46px;border-radius:10px}
    .brand .title{font-size:1.15rem;font-weight:700;color:var(--primary)}
    .btn{padding:8px 12px;border-radius:8px;border:none;cursor:pointer;font-weight:700;display:inline-flex;align-items:center;gap:8px}
    .btn-primary{background:var(--primary);color:#00131f}
    .btn-ghost{background:transparent;border:1px solid var(--border);color:var(--text);padding:8px 12px;border-radius:8px}
    .theme-btn{background:transparent;border:1px solid var(--border);color:var(--text);padding:8px 10px;border-radius:8px;cursor:pointer}
    .tool-card{background:var(--card);border:1px solid var(--border);border-radius:12px;padding:20px;margin-top:18px}
    .tool-title{font-size:1.4rem;color:var(--primary);margin:0 0 8px}
    .muted{color:var(--muted)}
    .row{display:flex;gap:12px;flex-wrap:wrap;align-items:center}
    input[type=file]{padding:8px;border-radius:8px;border:1px solid var(--border);background:transparent;color:var(--text)}
    .files-section{margin-top:16px;display:flex;flex-direction:column;gap:16px}
    .file-block{border:1px solid var(--border);padding:12px;border-radius:10px;background:rgba(255,255,255,0.01)}
    .file-header{display:flex;align-items:center;justify-content:space-between;gap:12px}
    .pages-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(140px,1fr));gap:12px;margin-top:12px}
    .page-item{padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.02);text-align:center;background:rgba(255,255,255,0.01)}
    .page-item canvas{max-width:100%;height:auto;border-radius:6px;display:block;margin:0 auto 8px}
    .controls{display:flex;gap:8px;flex-wrap:wrap;margin-top:14px}
    .preview-block{margin-top:12px;padding:10px;border-radius:8px;border:1px solid var(--border);background:rgba(255,255,255,0.02)}
    iframe.preview{width:100%;height:420px;border:none;border-radius:6px}
    .small{font-size:.9rem}
    footer{margin-top:20px;padding:12px 0;color:var(--muted)}
    .watermark-row{display:flex;gap:12px;align-items:center;flex-wrap:wrap;margin-top:10px}
    .watermark-preview{width:120px;height:70px;object-fit:contain;border:1px solid var(--border);border-radius:6px;background:rgba(255,255,255,0.01)}
    @media (max-width:720px){
      .pages-grid{grid-template-columns:repeat(2,1fr)}
      header{flex-direction:column;align-items:flex-start;gap:10px}
    }
  </style>
</head>
<body>
  <header class="container">
    <div class="brand">
      <img src="https://img.icons8.com/fluency/48/toolbox.png" alt="logo">
      <div>
        <div class="title">Smarttool Hub</div>
        <div class="muted small">Delete PDF Pages — with Image Watermark</div>
      </div>
    </div>

    <div style="display:flex;gap:10px;align-items:center">
      <a href="../../index.html" class="btn-ghost" title="Home"><i class="fa-solid fa-house"></i></a>
      <button id="themeToggle" class="theme-btn" title="Toggle dark/light mode"><i id="themeIcon" class="fa-solid fa-moon"></i></button>
    </div>
  </header>

  <main class="container">
    <div class="tool-card">
      <h2 class="tool-title">Delete PDF Pages (multi-file) + Image Watermark</h2>
      <p class="muted">Select one or more PDF files, preview pages, choose pages to remove. Upload an image to use as a watermark (PNG with transparency recommended). Click <strong>Delete Selected Pages</strong> to produce edited PDFs — each edited PDF will have the watermark applied to every page, will be shown in preview, and will be automatically downloaded. Manual downloads are also provided.</p>

      <div class="row" style="margin-top:8px;">
        <input id="fileInput" type="file" accept="application/pdf" multiple />
        <button id="loadBtn" class="btn btn-primary"><i class="fa-solid fa-file-import"></i> Load Files</button>
        <button id="clearBtn" class="btn btn-ghost"><i class="fa-solid fa-trash-arrow-up"></i> Clear</button>
      </div>

      <div class="row watermark-row">
        <label class="muted">Watermark image (optional):</label>
        <input id="watermarkInput" type="file" accept="image/png, image/jpeg" />
        <img id="watermarkPreview" class="watermark-preview" alt="No watermark selected" src="https://img.icons8.com/ios-filled/100/000000/transparent.png" />
        <label class="muted small">Opacity:</label>
        <input id="wmOpacity" type="range" min="0" max="100" value="15" />
        <span id="wmOpacityLabel" class="small muted">15%</span>
      </div>

      <div id="filesSection" class="files-section"></div>

      <div class="controls">
        <button id="deleteBtn" class="btn btn-primary" disabled><i class="fa-solid fa-trash"></i> Delete Selected Pages</button>
        <button id="downloadAllBtn" class="btn btn-ghost" disabled><i class="fa-solid fa-download"></i> Download All Edited</button>
      </div>

      <div id="globalStatus" class="muted small" style="margin-top:10px"></div>

      <div id="editedPreviews" style="margin-top:16px"></div>
    </div>
  </main>

  <footer class="container">
    © <span id="year"></span> Smarttool Hub
  </footer>

  <!-- Libraries -->
  <script src="https://unpkg.com/pdf-lib/dist/pdf-lib.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>

  <script>
    // set year
    document.getElementById('year').textContent = new Date().getFullYear();

    // theme toggle (landing page behavior)
    const themeToggle = document.getElementById('themeToggle');
    const themeIcon = document.getElementById('themeIcon');
    if (localStorage.getItem('sth_theme') === 'light') {
      document.body.classList.add('light');
      themeIcon.className = 'fa-solid fa-sun';
      themeToggle.title = 'Switch to dark mode';
    } else {
      themeIcon.className = 'fa-solid fa-moon';
      themeToggle.title = 'Switch to light mode';
    }
    themeToggle.addEventListener('click', () => {
      document.body.classList.toggle('light');
      const isLight = document.body.classList.contains('light');
      if (isLight) {
        localStorage.setItem('sth_theme','light');
        themeIcon.className = 'fa-solid fa-sun';
        themeToggle.title = 'Switch to dark mode';
      } else {
        localStorage.removeItem('sth_theme');
        themeIcon.className = 'fa-solid fa-moon';
        themeToggle.title = 'Switch to light mode';
      }
    });

    // Elements
    const fileInput = document.getElementById('fileInput');
    const loadBtn = document.getElementById('loadBtn');
    const clearBtn = document.getElementById('clearBtn');
    const filesSection = document.getElementById('filesSection');
    const deleteBtn = document.getElementById('deleteBtn');
    const downloadAllBtn = document.getElementById('downloadAllBtn');
    const globalStatus = document.getElementById('globalStatus');
    const editedPreviews = document.getElementById('editedPreviews');

    const watermarkInput = document.getElementById('watermarkInput');
    const watermarkPreview = document.getElementById('watermarkPreview');
    const wmOpacity = document.getElementById('wmOpacity');
    const wmOpacityLabel = document.getElementById('wmOpacityLabel');

    // state per file
    // { file, arrayBuffer, pdfLibDoc, pdfjsDoc, pageCount, deletedPages:Set, editedBlob, editedUrl }
    let filesState = [];
    let watermarkImageBytes = null; // ArrayBuffer of watermark image (if provided)
    let watermarkImageMime = null;

    // pdf.js worker from CDN
    if (window.pdfjsLib) {
      pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    }

    function setGlobalStatus(msg, isError=false) {
      globalStatus.textContent = msg;
      globalStatus.style.color = isError ? '#ff8a8a' : '';
    }

    // handle watermark input
    watermarkInput.addEventListener('change', async (e) => {
      const f = e.target.files[0];
      if (!f) {
        watermarkImageBytes = null;
        watermarkImageMime = null;
        watermarkPreview.src = '';
        watermarkPreview.alt = 'No watermark selected';
        return;
      }
      watermarkImageMime = f.type || 'image/png';
      watermarkImageBytes = await f.arrayBuffer();

      // Show preview
      const url = URL.createObjectURL(new Blob([watermarkImageBytes], {type: watermarkImageMime}));
      watermarkPreview.src = url;
      watermarkPreview.alt = f.name;
      // revoke after some time
      setTimeout(() => URL.revokeObjectURL(url), 30000);
    });

    wmOpacity.addEventListener('input', () => {
      wmOpacityLabel.textContent = wmOpacity.value + '%';
    });

    clearBtn.onclick = () => {
      filesState.forEach(f => { if (f.editedUrl) URL.revokeObjectURL(f.editedUrl); });
      filesState = [];
      filesSection.innerHTML = '';
      editedPreviews.innerHTML = '';
      deleteBtn.disabled = true;
      downloadAllBtn.disabled = true;
      watermarkInput.value = '';
      watermarkImageBytes = null;
      watermarkImageMime = null;
      watermarkPreview.src = '';
      fileInput.value = '';
      setGlobalStatus('');
    };

    loadBtn.onclick = async () => {
      setGlobalStatus('');
      filesSection.innerHTML = '';
      editedPreviews.innerHTML = '';
      filesState.forEach(f => { if (f.editedUrl) URL.revokeObjectURL(f.editedUrl); });
      filesState = [];

      const fileList = Array.from(fileInput.files || []);
      if (fileList.length === 0) { setGlobalStatus('Please select one or more PDF files.'); return; }

      setGlobalStatus('Loading files — rendering thumbnails (this may take a while for large PDFs)...');
      loadBtn.disabled = true;
      clearBtn.disabled = true;

      for (let i = 0; i < fileList.length; i++) {
        const file = fileList[i];
        try {
          const arrayBuffer = await file.arrayBuffer();
          const pdfLibDoc = await PDFLib.PDFDocument.load(new Uint8Array(arrayBuffer));
          const pdfjsDoc = await pdfjsLib.getDocument({data: arrayBuffer}).promise;
          const pageCount = pdfjsDoc.numPages;

          const state = {
            file, arrayBuffer, pdfLibDoc, pdfjsDoc, pageCount,
            deletedPages: new Set(), editedBlob: null, editedUrl: null
          };
          filesState.push(state);

          const block = document.createElement('div');
          block.className = 'file-block';
          block.dataset.fileIndex = i;

          const header = document.createElement('div');
          header.className = 'file-header';
          header.innerHTML = `<div><strong>${escapeHtml(file.name)}</strong> — <span class="muted small">${pageCount} pages</span></div>
                              <div>
                                <button class="btn btn-ghost btn-select-all small">Select All</button>
                                <button class="btn btn-ghost btn-deselect-all small">Deselect All</button>
                              </div>`;
          block.appendChild(header);

          const pagesGrid = document.createElement('div');
          pagesGrid.className = 'pages-grid';
          pagesGrid.setAttribute('aria-label', `Pages for ${file.name}`);

          // Render thumbnails
          for (let p = 1; p <= pageCount; p++) {
            const page = await pdfjsDoc.getPage(p);
            const viewport = page.getViewport({ scale: 0.5 });
            const canvas = document.createElement('canvas');
            canvas.width = Math.floor(viewport.width);
            canvas.height = Math.floor(viewport.height);
            const ctx = canvas.getContext('2d');

            await page.render({ canvasContext: ctx, viewport }).promise;

            const pageItem = document.createElement('div');
            pageItem.className = 'page-item';
            pageItem.innerHTML = `
              <div style="min-height:1px"></div>
              <label style="cursor:pointer;display:block">
                <div style="display:flex;justify-content:center;margin-bottom:6px"></div>
                <input type="checkbox" data-file-index="${filesState.length - 1}" data-page-index="${p - 1}"> Page ${p}
              </label>
            `;
            pageItem.querySelector('div').appendChild(canvas);

            // double click toggles
            pageItem.addEventListener('dblclick', () => {
              const cb = pageItem.querySelector('input[type=checkbox]');
              cb.checked = !cb.checked;
              const fi = parseInt(cb.dataset.fileIndex,10);
              const pi = parseInt(cb.dataset.pageIndex,10);
              updateDeletedSet(fi, pi, cb.checked);
            });
            pageItem.querySelector('input[type=checkbox]').addEventListener('change', (ev) => {
              const cb = ev.target;
              const fi = parseInt(cb.dataset.fileIndex,10);
              const pi = parseInt(cb.dataset.pageIndex,10);
              updateDeletedSet(fi, pi, cb.checked);
            });

            pagesGrid.appendChild(pageItem);
          }

          header.querySelector('.btn-select-all').addEventListener('click', () => {
            pagesGrid.querySelectorAll('input[type=checkbox]').forEach(cb => {
              cb.checked = true;
              updateDeletedSet(parseInt(cb.dataset.fileIndex,10), parseInt(cb.dataset.pageIndex,10), true);
            });
          });
          header.querySelector('.btn-deselect-all').addEventListener('click', () => {
            pagesGrid.querySelectorAll('input[type=checkbox]').forEach(cb => {
              cb.checked = false;
              updateDeletedSet(parseInt(cb.dataset.fileIndex,10), parseInt(cb.dataset.pageIndex,10), false);
            });
          });

          block.appendChild(pagesGrid);
          filesSection.appendChild(block);

        } catch (err) {
          console.error('Error loading', file.name, err);
          const errBlock = document.createElement('div');
          errBlock.className = 'file-block';
          errBlock.innerHTML = `<strong>${escapeHtml(file.name)}</strong> — <span class="muted">Failed to load (possibly encrypted or corrupted)</span>`;
          filesSection.appendChild(errBlock);
        }
      } // end for

      loadBtn.disabled = false;
      clearBtn.disabled = false;

      if (filesState.length > 0) {
        deleteBtn.disabled = true; // require selection
        setGlobalStatus(`Loaded ${filesState.length} file(s). Select pages to delete.`);
      } else setGlobalStatus('No files loaded.');
    };

    function updateDeletedSet(fileIndex, pageIndex, checked) {
      const s = filesState[fileIndex];
      if (!s) return;
      if (checked) s.deletedPages.add(pageIndex);
      else s.deletedPages.delete(pageIndex);
      const any = filesState.some(f => f.deletedPages.size > 0);
      deleteBtn.disabled = !any;
    }

    // Core: create edited PDF per file, add watermark, preview, download (auto)
    deleteBtn.onclick = async () => {
      if (filesState.length === 0) { setGlobalStatus('No files loaded.'); return; }
      setGlobalStatus('Creating edited PDFs — please wait...');
      deleteBtn.disabled = true;
      loadBtn.disabled = true;
      clearBtn.disabled = true;
      downloadAllBtn.disabled = true;
      editedPreviews.innerHTML = '';

      // prepare watermark image in pdf-lib format if provided
      let wmEmbed = null;
      let wmIsPng = true;
      if (watermarkImageBytes) {
        // We'll create an object URL only for preview; for embedding we use the ArrayBuffer
        // Determine mime from input variable watermarkImageMime
        wmIsPng = watermarkImageMime && watermarkImageMime.toLowerCase().includes('png');
      }

      for (let fi = 0; fi < filesState.length; fi++) {
        const f = filesState[fi];
        try {
          // Build new PDF using pdf-lib by copying pages we want to keep
          const srcPdfBytes = new Uint8Array(f.arrayBuffer);
          const srcDoc = await PDFLib.PDFDocument.load(srcPdfBytes);
          const newPdf = await PDFLib.PDFDocument.create();

          // If watermark present, we'll embed it once into newPdf after copying pages
          // determine keep pages (indices)
          const keep = [];
          for (let p = 0; p < f.pageCount; p++) if (!f.deletedPages.has(p)) keep.push(p);
          // copy pages if any
          if (keep.length > 0) {
            const copied = await newPdf.copyPages(srcDoc, keep);
            copied.forEach(pg => newPdf.addPage(pg));
          } // else zero-page PDF

          // embed watermark if present (or fallback to small default icon)
          let embedImage;
          if (watermarkImageBytes) {
            if (wmIsPng) embedImage = await newPdf.embedPng(watermarkImageBytes);
            else embedImage = await newPdf.embedJpg(watermarkImageBytes);
          } else {
            // fallback small default watermark (tiny transparent PNG data URL)
            const defaultPngDataUrl = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAAQCAYAAAB49pXqAAAAH0lEQVR42u3NMQEAAAgDINc/9K3hHBwN1cZQkQIECBAsM8GQwAAAABJRU5ErkJggg==';
            const res = await fetch(defaultPngDataUrl);
            const ab = await res.arrayBuffer();
            embedImage = await newPdf.embedPng(ab);
          }

          // if newPdf has pages, draw watermark onto each
          if (newPdf.getPageCount() > 0) {
            const opacity = Math.max(0, Math.min(1, parseInt(wmOpacity.value || '15', 10) / 100));
            for (let pi = 0; pi < newPdf.getPageCount(); pi++) {
              const page = newPdf.getPage(pi);
              const { width, height } = page.getSize();

              // scale watermark to 50% width (or smaller for small pages)
              const imgWidth = embedImage.width || 300;
              const imgHeight = embedImage.height || 100;
              // target width = min( (width * 0.6), imgWidth ) but scaled proportionally
              const targetW = Math.min(width * 0.6, imgWidth * 2); // allow upscaling if small image
              const scale = targetW / imgWidth;
              const targetH = imgHeight * scale;

              const x = (width - targetW) / 2;
              const y = (height - targetH) / 2;

              page.drawImage(embedImage, {
                x, y, width: targetW, height: targetH, opacity
              });
            }
          }

          const newBytes = await newPdf.save();
          const editedBlob = new Blob([newBytes], { type: 'application/pdf' });
          if (f.editedUrl) URL.revokeObjectURL(f.editedUrl);
          f.editedBlob = editedBlob;
          f.editedUrl = URL.createObjectURL(editedBlob);

          // preview + download (auto)
          const preview = document.createElement('div');
          preview.className = 'preview-block';
          preview.innerHTML = `
            <div style="display:flex;justify-content:space-between;align-items:center;gap:12px">
              <div><strong>${escapeHtml(f.file.name)}</strong> — <span class="muted small">${keep.length} pages kept, ${f.deletedPages.size} removed</span></div>
              <div style="display:flex;gap:8px;align-items:center">
                <a class="btn btn-ghost small" href="${f.editedUrl}" download="${safeFileName(f.file.name.replace(/\.pdf$/i,'') + '-edited.pdf')}"><i class="fa-solid fa-download"></i> Download</a>
                <button class="btn btn-ghost small" data-open-preview>Open Preview</button>
              </div>
            </div>
            <div style="margin-top:10px;display:none" data-preview-container>
              <iframe class="preview" src="${f.editedUrl}"></iframe>
            </div>
          `;
          preview.querySelector('[data-open-preview]').addEventListener('click', () => {
            const cont = preview.querySelector('[data-preview-container]');
            cont.style.display = cont.style.display === 'none' ? 'block' : 'none';
          });
          editedPreviews.appendChild(preview);

          // auto-download (user asked "download on any other change" — we auto-download edited file)
          triggerDownload(editedBlob, safeFileName(f.file.name.replace(/\.pdf$/i,'') + '-edited.pdf'));

        } catch (err) {
          console.error('Error processing file', f.file.name, err);
          const fail = document.createElement('div');
          fail.className = 'preview-block';
          fail.innerHTML = `<strong>${escapeHtml(f.file.name)}</strong> — <span class="muted">Failed to create edited PDF</span>`;
          editedPreviews.appendChild(fail);
        }
      } // end for files

      setGlobalStatus('Edited PDFs created & downloaded (also available via download buttons below).');
      downloadAllBtn.disabled = false;
      deleteBtn.disabled = false;
      loadBtn.disabled = false;
      clearBtn.disabled = false;
    };

    // Download all edited PDFs (manual)
    downloadAllBtn.onclick = () => {
      filesState.forEach(f => {
        if (f.editedBlob && f.editedUrl) {
          triggerDownload(f.editedBlob, safeFileName(f.file.name.replace(/\.pdf$/i,'') + '-edited.pdf'));
        }
      });
    };

    // Utility: trigger download
    function triggerDownload(blob, filename) {
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(() => { try { URL.revokeObjectURL(a.href); } catch(e){} }, 3000);
    }

    // Helpers
    function safeFileName(name) {
      return name.replace(/[<>:"/\\|?*\x00-\x1F]/g, '_');
    }
    function escapeHtml(s){ if (!s) return ''; return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#039;'); }

    // revoke object URLs on unload
    window.addEventListener('beforeunload', () => {
      filesState.forEach(f => { if (f.editedUrl) URL.revokeObjectURL(f.editedUrl); });
    });

    // parse selection helpers (not visible UI here - pages selected via checkboxes)
    function parsePageListInput(str, maxPage) {
      // returns sorted unique 1-based page numbers
      const out = new Set();
      if (!str || !str.trim()) return [];
      const parts = str.split(',');
      for (const p of parts) {
        if (p.includes('-')) {
          const [a,b] = p.split('-').map(x => parseInt(x.trim(),10));
          if (!isNaN(a) && !isNaN(b)) {
            for (let i=Math.max(1,a); i<=Math.min(maxPage,b); i++) out.add(i);
          }
        } else {
          const n = parseInt(p.trim(),10);
          if (!isNaN(n) && n>=1 && n<=maxPage) out.add(n);
        }
      }
      return Array.from(out).sort((a,b)=>a-b);
    }

    // small UX: when checkboxes change, enable delete button
    // Already handled in updateDeletedSet: sets deleteBtn.disabled accordingly

    // escape for filenames when downloading
  </script>
</body>
</html>
